#+title: Emacs — Packages — Applications
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/applications.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Applications

#+name: general-keybindings-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=elfeed-keybinds-show-mode prefix=""
(mapconcat (lambda (line)
             (let* ((key      (nth 0 line))
                    (function (nth 1 line))
                    (comment  (or (nth 2 line) ""))
                    (package  (or (nth 3 line) "")))
               (format "\"%s%s\" %s"
                       prefix
                       key
                       (if (string= "" comment)
                           (if (member function '("" "nil")) "nil" (concat "#'" function))
                         (format "'(%s :wk %s%s)"
                                 (if (member function '("" "nil")) ":ignore t" function)
                                 (if (member function '("none" "nil")) "t" (concat "\"" comment "\""))
                                 (if (string-blank-p package) "" (concat ":package " package)))))))
           table
           "\n")
#+end_src

#+begin_src emacs-lisp
(use-package transient
  :straight (:build t)
  :defer t)
#+end_src

** AI
*** chatgpt-shell
#+begin_src emacs-lisp
(use-package chatgpt-shell
  :straight t
  :after (password-store)
  :commands (chatgpt-shell)
  :bind (("C-c a p" . chatgpt-shell-prompt)
         ("C-c a s" . chatgpt-shell)
         ("C-c a cd" . dorneanu/+chatgpt-shell-check-diff)
         ("C-c a cp" . dorneanu/+chatgpt-shell-check-paragraph)
         ("C-c a P" . dorneanu/+chatgpt-shell-check-and-correct-paragraph)
         ("C-c a u" . +retrive-text-content-from-page)
         ("C-c a r" . chatgpt-shell-proofread-region))
  :config
  (setq chatgpt-shell-openai-key (password-store-get "emacs/chatgpt"))
  <<chatgpt-shell-custom-functions>>
  :custom
  ;; From https://github.com/jwiegley/dot-emacs/blob/master/init.org
  ;; I might need to change these
  (chatgpt-shell-system-prompts
   '(("English" .
      "I want you to act as an English translator, spelling corrector and improver. I will speak to you in any language and you will detect the language, translate it and answer in the corrected and improved version of my text, in English. I want you to replace my simplified A0-level words and sentences with more beautiful and elegant, upper level English words and sentences. Keep the meaning same, but make them more literary. I want you to only reply the correction, the improvements and nothing else, do not write explanations.")
     ("General" .
      "You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels.")
     ("Programming" .
      "The user is a programmer with very limited time. You treat their time as precious. You do not repeat obvious things, including their query. You are as concise as possible in responses. You never apologize for confusions because it would waste their time. You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels. Don't explain code snippets. Whenever you output updated code for the user, only show diffs, instead of entire snippets.")
     ("Positive Programming" .
      "Your goal is to help the user become an amazing computer programmer. You are positive and encouraging. You love see them learn. You do not repeat obvious things, including their query. You are as concise in responses. You always guide the user go one level deeper and help them see patterns. You never apologize for confusions because it would waste their time. You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels. Don't explain code snippets. Whenever you output updated code for the user, only show diffs, instead of entire snippets.")
     )))
#+end_src
**** Custom functions
***** chatgpt-shell-checks
For ChatGPT:
#+name: chatgpt-shell-custom-functions
#+begin_src emacs-lisp
;; https://www.reddit.com/r/emacs/comments/185n3yo/emacs_meets_chatgpt_for_flawless_grammar_and/
(defun chatgpt-shell-check-paragraph (text)
   "Send TEXT to ChatGPT for spell and grammar checking."
   ;; trim both sides to make diff easier
   (if (string= text "")
       (error "nothing to send to chatGPT"))
   (message "sending [%s]" text)
   (let ((response (chatgpt-shell-post-prompt
                    (concat
                     "Please correct the spelling and grammar of the following paragraph."
                     "Maintain existing org-mode syntax expressions like =this=, *this* and ~this~."
                     "Only return the corrected paragraph, not the original text or this prompt."
                     " If there is no change, return 'It looks good'."
                     "Here's the text:\n\n" text)
                    nil "gpt-3.5-turbo" nil nil nil nil)))
     response))

(defun dorneanu/+chatgpt-shell-check-and-correct-paragraph ()
   "Check and correct the current paragraph using ChatGPT."
   (interactive)
   (let* ((bounds (bounds-of-thing-at-point 'paragraph))
          (start (car bounds))
          (end (cdr bounds))
          (original-text (string-trim-left (buffer-substring-no-properties start end)))
          (point-offset (- end (point))) ; Save the offset of point from end
          (checked-text (chatgpt-shell-check-paragraph original-text)))
     (when checked-text
       (if (string-prefix-p "It looks good" checked-text)
           (message "It looks good")
         (save-excursion
           (goto-char start)
           (delete-region start end)
           (insert "\n") ; Insert a newline here
           (insert checked-text)
           (chatgpt-shell-check-diff original-text checked-text)
           ;; Move the point to its new position relative to the end
           (goto-char (- (cdr (bounds-of-thing-at-point 'paragraph)) point-offset)))))))

(defun chatgpt-shell-check-diff (original-text checked-text)
   (let ((buffer-ori (get-buffer-create "*chatgpt-grammar-original*"))
         (buffer-new (get-buffer-create "*chatgpt-grammar-checked*"))
         (reg-A-end nil)
         (reg-B-end nil)
         )
     (set-buffer buffer-ori)
     (erase-buffer)
     (insert original-text)
     (setq reg-A-end (point-max))
     (set-buffer buffer-new)
     (erase-buffer)
     (insert checked-text)
     (setq reg-B-end (point-max))
     (ediff-regions-internal buffer-ori 1 reg-A-end
                             buffer-new 1 reg-B-end
                             nil 'ediff-regions-wordwise 'word-mode nil)))

#+end_src
*** gptel
#+begin_src emacs-lisp
(use-package gptel
  :straight (:build t)
  ;; :config
  ;; ChatGPT
  ;; (setq gptel-api-key (password-store-get "emacs/chatgpt"))
  ;; ;; Anthropic / Claude 3
  ;; (gptel-make-anthropic "Claude"
  ;; :stream t
  ;; :key (password-store-get "emacs/chatgpt"))
  ;; OPTIONAL configuration
  ;; (setq
  ;;  gptel-model "claude-3-sonnet-20240229" ;  "claude-3-opus-20240229" also available
  ;;  gptel-backend (gptel-make-anthropic "Claude"
  ;;                                      :STREAM T :key "your-api-KEY"))
)
#+END_src
** Browsers
*** Eww
Since Emacs 29, it is possible to automatically rename ~eww~ buffers to
a more human-readable name, see [[https://protesilaos.com/codelog/2021-10-15-emacs-29-eww-rename-buffers/][Prot’s blog]] post on the matter.
#+begin_src emacs-lisp
(use-package eww
  :defer t
  :straight (:type built-in)
  :config
  (setq eww-auto-rename-buffer 'title))
#+end_src

Set default browser to chrome:
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-chrome)
#+end_src

*** XWidgets Webkit Browser
#+begin_src emacs-lisp 
(use-package xwidget
  :bind
  (:map xwidget-webkit-mode-map
        ("M-w" . xwidget-webkit-copy-selection-as-kill)
        ("M-4" . kill-buffer-and-window)))

(phundrak/evil
 :keymaps 'xwidget-webkit-mode-map
 "<mouse-4>" #'xwidget-webkit-scroll-down-line
 "<mouse-5>" #'xwidget-webkit-scroll-up-line
 "c"         #'xwidget-webkit-scroll-backward
 "t"         #'xwidget-webkit-scroll-up-line
 "s"         #'xwidget-webkit-scroll-down-line
 "r"         #'xwidget-webkit-scroll-forward
 "h"         #'xwidget-webkit-goto-history
 "C"         #'xwidget-webkit-back
 "R"         #'xwidget-webkit-forward
 "C-r"       #'xwidget-webkit-reload
 "j"         nil
 "k"         nil
 "l"         nil
 "H"         nil
 "L"         nil
 "X"         #'kill-buffer-and-window
 "C-d"       #'xwidget-webkit-scroll-up
 "C-u"       #'xwidget-webkit-scroll-down)
#+end_src

#+RESULTS:

** Buffers
*** ibuffer
#+begin_src emacs-lisp
(use-package ibuffer
  :custom
  (ibuffer-default-display-maybe-show-predicates t)
  (ibuffer-expert t)
  (askjdhasdkjh)
  (ibuffer-formats
   '((mark modified read-only " "
           (name 16 -1)
           " "
           (size 6 -1 :right)
           " "
           (mode 16 16)
           " " filename)
     (mark " "
           (name 16 -1)
           " " filename)))
  (ibuffer-maybe-show-regexps nil)
  (ibuffer-saved-filter-groups
   '(("default"
      ("Magit"
       (or

        (mode . magit-status-mode)
        (mode . magit-log-mode)
        (name . "\\*magit")
        (name . "magit-")
        (name . "git-monitor")))
      ("Coq"
       (or
        (mode . coq-mode)
        (name . "\\<coq\\>")
        (name . "_CoqProject")))
      ("Commands"
       (or
        (mode . shell-mode)
        (mode . eshell-mode)
        (mode . term-mode)
        (mode . compilation-mode)))
      ("Haskell"
       (or
        (mode . haskell-mode)
        (mode . haskell-cabal-mode)
        (mode . haskell-literate-mode)))
      ("Rust"
       (or
        (mode . rust-mode)
        (mode . cargo-mode)
        (name . "\\*Cargo")
        (name . "^\\*rls\\(::stderr\\)?\\*")
        (name . "eglot")))
      ("Nix"
       (mode . nix-mode))
      ("C++"
       (or
        (mode . c-mode)
        (mode . c++-mode)))
      ("Lisp"
       (mode . emacs-lisp-mode))
      ("Dired"
       (mode . dired-mode))
      ("Gnus"
       (or
        (mode . message-mode)
        (mode . mail-mode)
        (mode . gnus-group-mode)
        (mode . gnus-summary-mode)
        (mode . gnus-article-mode)
        (name . "^\\.newsrc-dribble")
        (name . "^\\*\\(sent\\|unsent\\|fetch\\)")
        (name . "^ \\*\\(nnimap\\|nntp\\|nnmail\\|gnus\\|server\\|mm\\*\\)")
        (name . "\\(Original Article\\|canonical address\\|extract address\\)")))
      ("Org"
       (or
        (name . "^\\*Calendar\\*$")
        (name . "^\\*Org Agenda")
        (name . "^ \\*Agenda")
        (name . "^diary$")
        (mode . org-mode)))
      ("Emacs"
       (or
        (name . "^\\*scratch\\*$")
        (name . "^\\*Messages\\*$")
        (name . "^\\*\\(Customize\\|Help\\)")
        (name . "\\*\\(Echo\\|Minibuf\\)"))))))
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-shrink-to-minimum-size t t)
  (ibuffer-use-other-window t)
  :init
  (add-hook 'ibuffer-mode-hook
            #'(lambda ()
                (ibuffer-switch-to-saved-filter-groups "default"))))
#+end_src
** Calendar
I am using the built-in calendar of Emacs, but as I use Evil and the
bépo layout, many keybindings available by default or through
=evil-collection= don’t fit my needs perfectly.
#+begin_src emacs-lisp
(use-package calendar
  :straight (:type built-in)
  :defer t
  :general
  (:keymaps 'calendar-mode-map
   "»"     #'calendar-scroll-left
   "«"     #'calendar-scroll-right
   "M-»"   #'calendar-scroll-left-three-months
   "M-«"   #'calendar-scroll-right-three-months
   "M-r"   #'calendar-scroll-left
   "M-c"   #'calendar-scroll-right
   "M-S-r" #'calendar-scroll-left-three-months
   "M-S-c" #'calendar-scroll-right-three-months
   "q"     #'calendar-exit)
  (phundrak/major-leader-key
    :keymaps 'calendar-mode-map
    "="   #'calendar-count-days-region
    "^"   '(:ignore t :wk "beginning")
    "^ w" #'calendar-beginning-of-week
    "^ m" #'calendar-beginning-of-month
    "^ y" #'calendar-beginning-of-year
    "$"   '(:ignore t :wk "end")
    "$w"  #'calendar-end-of-week
    "$m"  #'calendar-end-of-month
    "$y"  #'calendar-end-of-year
    "a"   '(:ignore t :wk "appointment")
    "aa"  #'appt-add
    "ad"  #'appt-delete
    "A"   #'org-calendar-goto-agenda
    "b"   '(:ignore t :wk "go back")
    "bd"  '(calendar-backward-day :wk "a day")
    "bw"  '(calendar-backward-week :wk "a week")
    "bm"  '(calendar-backward-month :wk "a month")
    "by"  '(calendar-backward-year :wk "a year")
    "d"   '(:ignore t :wk "diary")
    "da"  '(diary-show-all-entries :wk "all entries")
    "dd"  '(diary-view-entries :wk "entries")
    "dm"  #'diary-mark-entries
    "do"  #'diary-view-other-diary-entries
    "di"  '(:ignore t :wk "insert")
    "die" '(diary-insert-entry :wk "entry")
    "die" '(diary-insert-block-entry :wk "block entry")
    "diw" '(diary-insert-weekly-entry :wk "weekly")
    "dim" '(diary-insert-monthly-entry :wk "monthly")
    "diy" '(diary-insert-yearly-entry :wk "yearly")
    "F"   '(:ignore t :wk "files")
    "Fa"  #'org-calendar-goto-agenda
    "f"   '(:ignore t :wk "go forward")
    "fd"  '(calendar-forward-day :wk "a day")
    "fw"  '(calendar-forward-week :wk "a week")
    "fm"  '(calendar-forward-month :wk "a month")
    "fy"  '(calendar-forward-year :wk "a year")
    "g"   '(:ignore t :wk "goto")
    "gd"  #'calendar-goto-date
    "gm"  #'calendar-other-month
    "gt"  #'calendar-goto-today
    "h"   '(:ignore t :wk "holidays")
    "hl"  #'calendar-list-holidays
    "hm"  #'calendar-mark-holidays
    "H"   '(:ignore t :wk "HTML export")
    "Hm"  #'cal-html-cursor-month
    "Hy"  #'cal-html-cursor-year
    "M"   #'calendar-other-month))
#+end_src
** Compilation
*** Compilation mode
After reading about a blog article, I found out it is possible to run
quite a few things through ~compilation-mode~, so why not? First, let’s
redefine some keybinds for this mode. I’ll also define a general
keybind in order to re-run my programs from other buffers than the
~compilation-mode~ buffer. I also want to follow the output of the
compilation buffer, as well as enable some syntax highlighting.
#+begin_src emacs-lisp
(use-package compile
  :defer t
  :straight (compile :type built-in)
  :hook (compilation-filter . colorize-compilation-buffer)
  :init
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
  :general
  (phundrak/evil
    :keymaps 'compilation-mode-map
    "g" nil
    "r" nil
    "R" #'recompile
    "h" nil)
  (phundrak/leader-key
    "R" #'recompile)
  :config
  (setq compilation-scroll-output t))
#+end_src

** Debugging
*** COMMENT esup
Debug emacs init startup time
Run ~M-x esup~ to see where the time is spend during emacs startup.

#+BEGIN_SRC emacs-lisp
(use-package esup
  :straight t
  :defer t)
#+END_SRC

*** explain-pause-mode
#+begin_src emacs-lisp
(use-package explain-pause-mode
  :straight (explain-pause-mode :type git :host github :repo "lastquestion/explain-pause-mode"))
  :straight t
  ;; :config
  ;; (explain-pause-mode)

#+end_src
** Email
*** mu4e
**** General config
#+begin_src emacs-lisp
;; Make sure we find the mu4e package
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")

(use-package mu4e
  :ensure nil
  :commands (mu4e)
  :bind (("C-c a m" . mu4e)
         :map mu4e-main-mode-map
         ("U" . mu4e-update-mail-and-index-background)
         :map mu4e-headers-mode-map
         ("TAB" . mu4e-headers-next-unread)
         ("j" . mu4e-view-headers-next)
         ("k" . mu4e-view-headers-prev)
         ("J" . mu4e-search-maildir)
         ;; ("j" . mu4e-move-to-junk)
         ;; ("M" . mu4e-headers-mark-all-unread-read) ; Mark all as read
         :map mu4e-view-mode-map
         ("A" . mu4e-view-attachment-action)
         ("M-o" . ace-link-mu4e)
         ("o" . ace-link-mu4e)
         ("n" . mu4e-scroll-up)
         ("p" . mu4e-scroll-down)
         ("J" . mu4e-view-headers-next)
         ("K" . mu4e-view-headers-prev)
         ;; ("j" . mu4e-move-to-junk)
         )
  :init
  ;; From https://github.com/Phundrak/dotfiles/blob/master/org/config/emacs.org
  ;; (defun mu4e--main-action-str (name func)
  ;;   "This seems to be needed until evil-collection supports the latest version of mu4e."
  ;;   "mu4e-main-action")
  ;; (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)

  ;; Prefer text over html/ritchtext
  (setq mm-discouraged-alternatives '("text/html" "text/richtext"))

  ;; Use completing-read (which is ivy) instead of ido
  (setq mu4e-completing-read-function 'completing-read)

  ;; set mu4e as default mail client
  (setq mail-user-agent 'mu4e-user-agent)

  ;; SMTP related
  (setq message-send-mail-function        'smtpmail-send-it
        smtpmail-stream-type              'tls)

  :config
  ;; Set mu binary
  (setq mu4e-mu-binary "/usr/bin/mu")

  ;; Use passwords from password-store
  (setq auth-sources '(password-store))
  (setq auth-source-debug t)

  ;; Choose which fields to show
  (setq mu4e-headers-fields
        '(
          (:maildir    . 13)
          (:human-date . 12)
          (:flags      . 6)
          (:from       . 22)
          (:subject    . nil)))

  ;; Refresh mail using isync every 10 minutes
  (setq mu4e-update-interval (* 10 60))

  ;; Command used to retrieve new mails
  (setq mu4e-get-mail-command "mbsync -a")

  ;; Defaults
  (setq mu4e-maildir (getenv "MU4E_MAILDIR"))
  (setq-default mu4e-drafts-folder "/private/Drafts")
  (setq-default mu4e-sent-folder   "/private/Sent")
  (setq-default mu4e-trash-folder  "/private/Trash")

  ;; Set citation settings
  (setq message-citation-line-format "\nOn %a, %b %d, %Y at %r %z, %N wrote:\n")
  (setq message-citation-line-function 'message-insert-formatted-citation-line)

  ;; Fancy stuff
  (setq mu4e-use-fancy-chars t)
  <<mu4e-fancy-marks>>

  ;; And change default threading characters to some "nicer" looking chars
  (setq mu4e-headers-thread-child-prefix '("├>" . "├→ "))
  (setq mu4e-headers-thread-last-child-prefix '("└>" . "└→ "))
  (setq mu4e-headers-thread-connection-prefix '("│" . "│ "))
  (setq mu4e-headers-thread-orphan-prefix '("┬>" . "┬→ "))
  (setq mu4e-headers-thread-single-orphan-prefix '("─>" . "─→ "))

  ;; Also change to some nicer characters for marks
  ;; (setq mu4e-headers-new-mark    '("N" . "📨"))
  (setq mu4e-headers-passed-mark  '("P" . "›"))
  (setq mu4e-headers-replied-mark '("R" . "‹"))
  (setq mu4e-headers-seen-mark   '("S" . ""))
  ;; (setq mu4e-headers-attach-mark '("a" . "📎"))
  (setq mu4e-headers-personal-mark '("p" . ""))
  ;; (setq mu4e-headers-unread-mark '("u" . "📫"))

  ;; Set date format (header view)
  (setq mu4e-headers-date-format "%F")

  ;; How should html context be converted
  ;; (setq mu4e-html2text-command "/usr/bin/w3m -T text/html")
  (setq mu4e-html2text-command "iconv -c -t utf-8 | pandoc -f html -t plain")

  ;; Improve rendering of rich-text messages (html)
  (setq shr-color-visible-luminance-min 80)

  ;; Show email address as well and not only the name
  (setq-default mu4e-view-show-addresses t)

  ;; Don't reply to self
  (setq mu4e-compose-dont-reply-to-self t)

  ;; Setup some handy shortcuts
  ;; you can quickly switch to your Inbox -- press ``ji''
  ;; then, when you want archive some messages, move them to
  ;; the 'All Mail' folder by pressing ``ma''.

  ;; View mail in browser with "a V"
  (add-to-list 'mu4e-view-actions
               '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  (add-to-list 'mu4e-view-actions
               '("fViewInChrome" . mu4e-action-view-in-chrome) t)
  (add-to-list 'mu4e-view-actions
               '("xViewXWidget" . mu4e-action-view-with-xwidget) t)

  (setq mu4e-maildir-shortcuts
        '(
          ("/variomedia/inbox"   . ?v)
          ("/gmail/inbox"    . ?g)
          ("/cashlink/inbox"   . ?c)
          ("/private/Trash"   . ?t)
          ("/private/Drafts"  . ?d)
          ("/private/Junk"    . ?j)
          ("/private/Archive" . ?a)))

  ;; Set contexts
  (dorneanu/set-mu4e-contexts)
  )

<<mu4e-view-mode>>

#+end_src

#+RESULTS:
| closure | (t) | nil                       | (visual-fill-column-mode) |
| lambda  | nil | (visual-fill-column-mode) |                           |

**** Bookmarks
#+BEGIN_SRC emacs-lisp
(setq mu4e-bookmarks
      `(
        ("maildir:/Sent" "Sent messages" ?s)
        ("flag:unread AND NOT flag:trashed" "Unread messages" ?U)
        ("date:today..now AND NOT flag:trashed" "Today's messages" ?t)
        ("date:7d..now AND NOT flag:trashed" "Last 7 days" ?w)
        ("date:1m..now AND NOT flag:trashed" "Last month" ?m)
        ("date:1y..now AND NOT flag:trashed" "Last year" ?y)
        ("flag:trashed AND NOT flag:trashed" "Trash" ?T)
        ("from:yo@dev.to AND NOT flag:trashed" "dev.to" ?d)
        ("from:jira@*" "Jira" ?j)
        ("from:notifications@github.com" "Github" ?g)
        ;; (,(s-join " "
        ;;           '("OR noreply@tagesspiegel.de"
        ;;             "OR support@lagedernation.org"
        ;;             "OR hello@blinkist.com"
        ;;             "OR info@smarticular.net"
        ;;             "OR newsletter@*"
        ;;             "OR support@xeroshoes.com"))
        ;;  "Newletter" ?n)
        ("mime:image/* AND NOT flag:trashed" "Messages with images" ?p)))
#+END_SRC

**** Fancy stuff
From https://github.com/Phundrak/dotfiles

#+name: mu4e-fancy-marks-tbl
| Mark      | Flag | Icon        |
|-----------+------+-------------|
| draft     | D    | pencil      |
| flagged   | F    | flag        |
| new       | N    | rss         |
| passed    | P    | check       |
| replied   | R    | reply       |
| seen      | S    | eye         |
| unread    | u    | eye-slash   |
| trashed   | T    | trash       |
| attach    | a    | paperclip   |
| encrypted | x    | lock        |
| signed    | s    | certificate |

#+name: mu4e-fancy-marks-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=mu4e-fancy-marks-tbl
(mapconcat (lambda (line)
             (let ((mark (car line))
                   (flag (cadr line))
                   (icon (caddr line)))
               (format "mu4e-headers-%s-mark `(\"%s\" . ,(all-the-icons-faicon \"%s\" :height 0.8))"
                       mark
                       flag
                       icon)))
           table
           "\n")
#+end_src

#+RESULTS[c6ed5d4bec4c10339a7de52a70822af74d782e62]: mu4e-fancy-marks-gen
#+begin_example
mu4e-headers-draft-mark `("D" . ,(all-the-icons-faicon "pencil" :height 0.8))
mu4e-headers-flagged-mark `("F" . ,(all-the-icons-faicon "flag" :height 0.8))
mu4e-headers-new-mark `("N" . ,(all-the-icons-faicon "rss" :height 0.8))
mu4e-headers-passed-mark `("P" . ,(all-the-icons-faicon "check" :height 0.8))
mu4e-headers-replied-mark `("R" . ,(all-the-icons-faicon "reply" :height 0.8))
mu4e-headers-seen-mark `("S" . ,(all-the-icons-faicon "eye" :height 0.8))
mu4e-headers-unread-mark `("u" . ,(all-the-icons-faicon "eye-slash" :height 0.8))
mu4e-headers-trashed-mark `("T" . ,(all-the-icons-faicon "trash" :height 0.8))
mu4e-headers-attach-mark `("a" . ,(all-the-icons-faicon "paperclip" :height 0.8))
mu4e-headers-encrypted-mark `("x" . ,(all-the-icons-faicon "lock" :height 0.8))
mu4e-headers-signed-mark `("s" . ,(all-the-icons-faicon "certificate" :height 0.8))
#+end_example

Let’s enable them and set them:
#+name: mu4e-fancy-marks
#+begin_src emacs-lisp :tangle no
(setq mu4e-use-fancy-chars t
      <<mu4e-fancy-marks-gen()>>)
#+end_src

**** View mode
#+name: mu4e-view-mode
#+begin_src emacs-lisp :tangle no
(add-hook 'mu4e-view-mode-hook (lambda () (visual-fill-column-mode)))
#+end_src

**** Contexts
Set contexts
#+begin_src emacs-lisp
(defun dorneanu/set-mu4e-contexts ()
  "Set mail contexts for mu4e"
  (interactive)
  (setq mu4e-contexts
        `( ,(make-mu4e-context
             :name "gmail"
             :enter-func (lambda () (mu4e-message "Entering gmail context"))
             :leave-func (lambda () (mu4e-message "Leaving gmail context"))
             ;; we match based on the contact-fields of the message
             :match-func
             (lambda (msg)
               (when msg
                 (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/gmail/personal/username"))
                     (user-full-name    . "Cyneox")
                     (smtpmail-smtp-user . ,(password-store-get "mail/gmail/personal/username"))
                     (smtpmail-smtp-server  . "smtp.gmail.com")
                     (smtpmail-default-smtp-server  . "smtp.gmail.com")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-compose-signature . "Cyneox via Gmail")
                     (mu4e-drafts-folder  . "/[Gmail]/drafts")
                     (mu4e-sent-folder  . "/[Gmail]/sent")
                     (mu4e-refile-folder  . "/[Gmail]/All Mail")
                     (mu4e-trash-folder  . "/[Gmail]/bin")))
           ,(make-mu4e-context
             :name "variomedia"
             :enter-func (lambda () (mu4e-message "Switch to the variomedia context"))
             :match-func
             (lambda (msg)
               (when msg
                 (string-prefix-p "/variomedia" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/personal/username"))
                     (user-full-name    . "Victor Dorneanu")
                     (smtpmail-smtp-user . ,(password-store-get "mail/personal/username")) (smtpmail-smtp-server  . "smtp.variomedia.de")
                     (smtpmail-default-smtp-server  . "smtp.variomedia.de")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-compose-signature . "Victor via Emacs")
                     (mu4e-drafts-folder  . "/variomedia/drafts")
                     (mu4e-sent-folder  . "/variomedia/sent")
                     (mu4e-trash-folder  . "/variomedia/bin")))
           ,(make-mu4e-context
             :name "cashlink"
             :enter-func (lambda () (mu4e-message "Switch to the cashlink context"))
             :match-func
             (lambda (msg)
               (when msg
                 (string-prefix-p "/cashlink" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/gmail/work/username"))
                     (user-full-name    . "Victor Dorneanu")
                     (smtpmail-smtp-user . ,(password-store-get "mail/gmail/work/username"))
                     (smtpmail-smtp-server  . "smtp.gmail.com")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-drafts-folder  . "/cashlink/drafts")
                     (mu4e-sent-folder  . "/cashlink/sent")
                     (mu4e-trash-folder  . "/cashlink/bin")
                     (mu4e-compose-signature . ,(concat "Victor Dorneanu\n" "Security Architect @ Cashlink\n"))
                     ))))
  )

#+end_src

#+RESULTS:
: dorneanu/set-mu4e-contexts
**** Reply
I often want to reply without the original message:
#+begin_src emacs-lisp
;; From https://github.com/djcb/mu/issues/2345
;; (after! mu4e
;;   (defun dorneanu/mu4e-delete-citation ()
;;     (delete-region (point) (point-max)))

;;   (defun dorneanu/mu4e-reply (prefix)
;;     (interactive "P")
;;     (setq mu4e-compose-cite-function (if prefix
;;                                          #'dorneanu/mu4e-delete-citation
;;                                        #'message-cite-original-without-signature))
;;     (mu4e-compose-reply))

;;   (define-key mu4e-view-mode-map "R" #'dorneanu/mu4e-reply)
;;   (define-key mu4e-headers-mode-map "R" #'dorneanu/mu4e-reply)
;;   )
#+end_src
** empv
Watch YouTube videos from Emacs using ~mpv~. I also learned you can save the
position and resume whenever the same video is played again (read [[https://unix.stackexchange.com/questions/414639/is-it-possible-to-continue-movies-from-where-one-leaves-in-mpv-as-can-be-done-in][here]]).

#+begin_src emacs-lisp
(use-package empv
  :straight t
  :after (embark browse-url)
  :config

  (setq empv-invidious-instance "https://yewtu.be/")
  (add-to-list 'empv-mpv-args "--ytdl-format=best")

  (defun dorneanu/empv-play-url (url &optional _)
    (interactive)
    (empv-toggle-video)
    (empv-play url)))

;; Handle youtube links using mpv
(with-eval-after-load 'browse-url
  (add-to-list 'browse-url-handlers (cons "^https://\\(www.\\)?youtube.com\\|https://youtu.be" #'dorneanu/empv-play-url)))

#+end_src
** Feeds
*** elfeed

Elfeed is a nice Atom and RSS reader for Emacs. The only thing I want
to change for now is the default search filter: I want to see not only
unread news but read news as well, a bit like my emails; and where the
database is to be stored.
#+begin_src emacs-lisp
(use-package elfeed
  :defer t
  :straight (:build t)
  :config
  <<elfeed-open-youtube-with-mpv>>
  :custom
  ((elfeed-search-filter "@1-week-ago +unread +daily -devto -youtube -hn")
   (elfeed-db-directory "~/.elfeed")
   (elfeed-goodies/wide-threshold 0.2)
   (elfeed-set-timeout 36000)))
#+end_src

Custom functions:

#+begin_src emacs-lisp
(defun hp/elfeed-entry-line-draw (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (concat "[" (mapconcat 'identity tags ",") "]"))
         (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                         elfeed-goodies/tag-column-width 4))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               title-width)
                        :left))
         (tag-column (elfeed-format-column
                      tags-str (elfeed-clamp (length tags-str)
                                             elfeed-goodies/tag-column-width
                                             elfeed-goodies/tag-column-width)
                      :left))
         (feed-column (elfeed-format-column
                       feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width)
                       :left))
         ;; (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 6 :left))
         ;; (entry-authors (concatenate-authors
         ;;                 (elfeed-meta entry :authors)))
         ;; (authors-column (elfeed-format-column entry-authors elfeed-goodies/tag-column-width :left))
         )
    (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
        (progn
          ;; (insert (propertize entry-score 'face 'elfeed-search-feed-face) " ")
          (insert (propertize date 'face 'elfeed-search-date-face) " ")
          (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
          (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
          ;; (insert (propertize authors-column 'face 'elfeed-search-tag-face) " ")
          (insert (propertize title 'face title-faces 'kbd-help title))
          )
      (insert (propertize title 'face title-faces 'kbd-help title))))
  )

#+end_src

I don’t want YouTube videos to be open with my web browser when I
invoke ~elfeed-show-visit~, so I’ll advise this function to make it
possible to modify the behaviour of said function. Oh, and I already
made [[file:../../scripts.md#ytplay][a neat package]] for playing YouTube videos and friends through
[[https://ytdl-org.github.io/youtube-dl/][youtube-dl]] or its superior fork [[https://github.com/yt-dlp/yt-dlp][yt-dlp]] in mpv.

#+name: elfeed-open-youtube-with-mpv
#+begin_src emacs-lisp
(defun my/elfeed-filter-youtube-videos (orig-fun &rest args)
  "Open with mpv the video leading to PATH"
  (let ((link (elfeed-entry-link elfeed-show-entry)))
    (when link
      (if (string-match-p ".*youtube\.com.*watch.*" link)
          ;; This is a YouTube video, open it with mpv
          (progn
            (require 'ytplay)
            (ytplay link))
        (apply orig-fun args)))))

(advice-add 'elfeed-show-visit :around #'my/elfeed-filter-youtube-videos)
#+end_src

A future improvement to be made is to let the user chose the
resolution of the video before it is launched. I may not always have
the best internet connection, and viewing 4K videos on a 1080p display
is not something very useful.
**** elfeed-goodies
Elfeed-goodies is a package which enhances the Elfeed experience.
Aside from running its setup command as soon as possible, I also set
in this code block all my keybinds for Elfeed here.
#+begin_src emacs-lisp
(use-package elfeed-goodies
  :defer t
  :after elfeed
  :commands elfeed-goodies/setup
  :straight (:build t)
  :init
  (elfeed-goodies/setup)
  :custom
  (elfeed-goodies/feed-source-column-width 28)
  (elfeed-goodies/tag-column-width 28)
  :config
  (setq elfeed-search-print-entry-function 'hp/elfeed-entry-line-draw)
  :general
  (phundrak/undefine
    :keymaps '(elfeed-show-mode-map elfeed-search-mode-map)
    :packages 'elfeed
    "DEL" nil
    "s"   nil)
  (phundrak/evil
    :keymaps 'elfeed-show-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-show-mode)>>)
  (phundrak/evil
    :keymaps 'elfeed-search-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-search-mode)>>)
  (phundrak/major-leader-key
    :keymaps 'elfeed-search-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-search-mode-prefixed)>>))
#+end_src

**** elfeed-org
Last but not least, my Elfeed configuration is stored in an org file
thanks to ~elfeed-org~.
#+begin_src emacs-lisp
(use-package elfeed-org
  :defer nil
  :after elfeed
  :straight (:build t)
  :init
  (elfeed-org)
  :config
  (setq rmh-elfeed-org-files '("~/work/repos/org/elfeed.org.gpg")))
#+end_src
**** elfeed-tube
#+begin_src emacs-lisp
(use-package elfeed-tube
  :straight (:build t)
  :after elfeed
  :config
  (elfeed-tube-setup)
  :bind (:map elfeed-show-mode-map
         ("C-c C-x m" . #'dorneanu/elfeed-play-with-mpv)
         ("C-c C-x f" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)
         :map elfeed-search-mode-map
         ("C-c C-x m" . #'dorneanu/elfeed-play-with-mpv)
         ("C-c C-x f" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)))

;; https://github.com/skeeto/elfeed/issues/267
(defun dorneanu/elfeed-play-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (quality-arg "")
        (quality-val (completing-read "Max height resolution (0 for unlimited): " '("0" "480" "720") nil nil)))
    (setq quality-val (string-to-number quality-val))
    (message "Opening %s with height≤%s with mpv..." (elfeed-entry-link entry) quality-val)
    (when (< 0 quality-val)
      (setq quality-arg (format "--ytdl-format=[height<=?%s]" quality-val)))
    (start-process "elfeed-mpv" nil "mpv" quality-arg (elfeed-entry-link entry))))

#+end_src

**** functions
#+begin_src emacs-lisp
(defun dorneanu/elfeed-search-browse-url-xwidget (&optional use-generic-p)
  "open with xwidget"
  (interactive "P")
  ;; Split window and focus there
  (split-window-right)
  (balance-windows)
  (other-window 1)
  (let ((browse-url-browser-function #'xwidget-webkit-browse-url))
    (elfeed-search-browse-url use-generic-p)))
#+end_src
**** reddigg
Use reddigg to show reddit threads.
#+begin_src emacs-lisp
(use-package reddigg
  :straight t
  :after elfeed
  :config
  (defun my/elfeed-reddit-show-commments (&optional link)
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (if link link (elfeed-entry-link entry))))
      (reddigg-view-comments link))))
#+end_src
**** hnreader
#+begin_src emacs-lisp
(use-package hnreader
  :straight t
  :after (elfeed))
#+end_src
Open in same window
#+begin_src emacs-lisp
(setq hnreader-view-comments-in-same-window nil)
#+end_src

Use hnreader to show HN threads
#+begin_src emacs-lisp
(defun my/elfeed-hn-show-commments (&optional link)
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (if link link (elfeed-entry-link entry))))
    (setq-local hnreader-view-comments-in-same-window nil)
    (hnreader-promise-comment (format "%s" link))))
#+end_src

Use hnread to show HN threads for a URL at point
#+begin_src emacs-lisp
(defun my/elfeed-hn-show-comments-at-point ()
  "Kill the url at point."
  (interactive)
  (setq-local hnreader-view-comments-in-same-window t)
  (hnreader-comment (format "%s" (url-get-url-at-point))))
#+end_src

**** Keybindings
First, here are the keybinds for Elfeed’s ~elfeed-show-mode~. They
aren’t prefixed by ~SPC~ like most of my keybinds, a direct keypress
will directly launch the function.
#+name: elfeed-keybinds-show-mode
| Key | Function                      | Comment |
|-----+-------------------------------+---------|
| +   | elfeed-show-tag               |         |
| -   | elfeed-show-untag             |         |
| «   | elfeed-show-prev              |         |
| »   | elfeed-show-next              |         |
| b   | elfeed-show-visit             |         |
| C   | elfeed-kill-link-url-at-point |         |
| d   | elfeed-show-save-enclosure    |         |
| l   | elfeed-show-next-link         |         |
| o   | elfeed-goodies/show-ace-link  |         |
| q   | elfeed-kill-buffer            |         |
| S   | elfeed-show-new-live-search   |         |
| u   | elfeed-show-tag--unread       |         |
| y   | elfeed-show-yank              |         |

Same thing, different mode, here are my keybinds for
~elfeed-search-mode~.
#+name: elfeed-keybinds-search-mode
| Key | Function                                  | Comment |
|-----+-------------------------------------------+---------|
| «   | elfeed-search-first-entry                 |         |
| »   | elfeed-search-last-entry                  |         |
| b   | elfeed-search-browse-url                  |         |
| f   |                                           | filter  |
| fc  | elfeed-search-clear-filter                |         |
| fl  | elfeed-search-live-filter                 |         |
| fs  | elfeed-search-set-filter                  |         |
| u   |                                           | update  |
| us  | elfeed-search-fetch                       |         |
| uS  | elfeed-search-update                      |         |
| uu  | elfeed-update                             |         |
| uU  | elfeed-search-update--force               |         |
| y   | elfeed-search-yank                        |         |
| x   | elfeed-search-untag-all-unread            |         |
| X   | dorneanu/elfeed-search-browse-url-xwidget |         |
| TAB | elfeed-search-show-entry                  |         |

I have some additional keybinds for ~elfeed-search-mode~, but these one
are prefixed with ~,~ (and ~M-m~).
#+name: elfeed-keybinds-search-mode-prefixed
| Key | Function                            | Comment |
|-----+-------------------------------------+---------|
| c   | elfeed-db-compact                   |         |
| t   |                                     | tag     |
| gr  | my/elfeed-reddit-show-commments     |         |
| gh  | my/elfeed-hn-show-comments-at-point |         |
| tt  | elfeed-search-tag-all-unread        |         |
| tu  | elfeed-search-untag-all-unread      |         |
| tT  | elfeed-search-tag-all               |         |
| tU  | elfeed-search-untag-all             |         |

** File Management
*** Dired
Dired is Emacs’ built-in file manager. It’s really great, and replaces
any graphical file manager for me most of the time because:
- I am not limited to /x/ tabs or panes
- All actions can be done with keybindings
- I get a consistent behaviour between Dired and Emacs, since it’s the
  same thing.
I used to have an extensive configuration for Dired with a couple of
additional packages to make it more usable. Dirvish rendered that
obsolete!
#+begin_src emacs-lisp
(use-package dirvish
  :straight (:build t)
  :defer t
  :init (dirvish-override-dired-mode)
  :custom
  (dirvish-quick-access-entries
   '(("h" "~/" "Home")
     ("d" "~/Downloads/" "Downloads")
     ("c" "~/org/config" "Config")
     ("C" "~/Documents/conlanging/content" "Conlanging")))
  (dirvish-mode-line-format
   '(:left (sort file-time "" file-size symlink) :right (omit yank index)))
  (dirvish-attributes '(all-the-icons file-size collapse subtree-state vc-state git-msg))
  :config
  (dirvish-peek-mode)
  (dirvish-side-follow-mode)
  <<dired-drag-and-drop>>
  <<dired-listing-flags>>
  <<dired-files-and-dirs>>
  <<dirvish-exa-offload>>
  (setq dired-dwim-target         t
        dired-recursive-copies    'always
        dired-recursive-deletes   'top
        delete-by-moving-to-trash t
        dirvish-preview-dispatchers (cl-substitute 'pdf-preface 'pdf dirvish-preview-dispatchers))
  :general
  (phundrak/evil
    :keymaps 'dirvish-mode-map
    :packages '(dired dirvish)
    "q" #'dirvish-quit
    "TAB" #'dirvish-subtree-toggle)
  (phundrak/major-leader-key
    :keymaps 'dirvish-mode-map
    :packages '(dired dirvish)
    "A"   #'gnus-dired-attach
    "a"   #'dirvish-quick-access
    "d"   #'dirvish-dispatch
    "e"   #'dirvish-emerge-menu
    "f"   '(:ignore t :which-key "fd")
    "ff"   #'dirvish-fd
    "fj"   #'dirvish-fd-jump
    "F"   #'dirvish-file-info-menu
    "h"   '(:ignore t :which-key "history")
    "hp"  #'dirvish-history-go-backward
    "hn"  #'dirvish-history-go-forward
    "hj"  #'dirvish-history-jump
    "hl"  #'dirvish-history-last
    "l"   '(:ignore t :which-key "layout")
    "ls"  #'dirvish-layout-switch
    "lt"  #'dirvish-layout-toggle
    "m"   #'dirvish-mark-menu
    "s"   #'dirvish-quicksort
    "S"   #'dirvish-setup-menu
    "t"   #'dirvish-layout-toggle
    "y"   #'dirvish-yank-menu
    "n"   #'dirvish-narrow))
#+end_src

It requires some programs which can be installed like so:
#+begin_src sh :dir /sudo::~/ :exports code :tangle no :results verbatim
pacman -S --needed --noprogressbar --noconfirm --color=never \
       fd poppler ffmpegthumbnailer mediainfo imagemagick tar unzip
#+end_src

Since Emacs 29, it is possible to enable drag-and-drop between Emacs
and other applications.
#+name: dired-drag-and-drop
#+begin_src emacs-lisp :tangle no
(csetq dired-mouse-drag-files                   t
       mouse-drag-and-drop-region-cross-program t)
#+end_src

In Dirvish, it’s best to use the long name of flags whenever possible,
otherwise some commands won’t work.
#+name: dired-listing-flags
#+begin_src emacs-lisp :tangle no
(csetq dired-listing-switches (string-join '("--all"
                                             "--human-readable"
                                             "--time-style=long-iso"
                                             "--group-directories-first"
                                             "-lv1")
                                           " "))
#+end_src

However, it is possible to instead use =eza= when it is available (it’s
a replacement to the unmaintained =exa=). Instead of making Emacs’ main
thread to the file listing in a directory, we offload it to an
external thread.
#+name: dirvish-exa-offload
#+begin_src emacs-lisp :tangle no
(dirvish-define-preview eza (file)
  "Use `eza' to generate directory preview."
  :require ("eza")
  (when (file-directory-p file)
    `(shell . ("eza" "--color=always" "-al" ,file))))

(add-to-list 'dirvish-preview-dispatchers 'eza)
#+end_src

Finally, some directories need to be set for Dired to store various
files and images.
#+name: dired-files-and-dirs
#+begin_src emacs-lisp :tangle no
(let ((my/file (lambda (path &optional dir)
                 (expand-file-name path (or dir user-emacs-directory))))
      (my/dir (lambda (path &optional dir)
                (expand-file-name (file-name-as-directory path)
                                  (or dir user-emacs-directory)))))
  (csetq image-dired-thumb-size             150
         image-dired-dir                    (funcall my/dir "dired-img")
         image-dired-db-file                (funcall my/file "dired-db.el")
         image-dired-gallery-dir            (funcall my/dir "gallery")
         image-dired-temp-image-file        (funcall my/file "temp-image" image-dired-dir)
         image-dired-temp-rotate-image-file (funcall my/file "temp-rotate-image" image-dired-dir)))
#+end_src

Copying files with Dired is a blocking process. It’s usually fine when
there’s not a lot to copy, but it becomes annoying when moving larger
files. The package ~dired-rsync~ allows copying files with ~rsync~ in the
background; we can then carry on with our tasks while the copy is
happening.
#+begin_src emacs-lisp
(use-package dired-rsync
  :if (executable-find "rsync")
  :defer t
  :straight (:build t)
  :general
  (phundrak/evil
    :keymaps 'dired-mode-map
    :packages 'dired-rsync
    "C-r" #'dired-rsync))
#+end_src

*** Tramp

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize))

(use-package tramp
  :defer t
  :custom
  (tramp-default-method "ssh")
  (tramp-auto-save-directory "~/.cache/emacs/backups")
  :config
  ;; (add-to-list 'tramp-remote-path (expand-file-name "~/.nix-profile/bin"))

  ;; jww (2018-02-20): Without this change, tramp ends up sending hundreds of
  ;; shell commands to the remote side to ask what the temporary directory is.
  (put 'temporary-file-directory 'standard-value '("/tmp"))

  ;; Setting this with `:custom' does not take effect.
  ;; (setq tramp-persistency-file-name (user-data "tramp"))
)

;; Change default shell to bash
(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))

;; Ignore "Remote file error: Forbidden reentrant call of Tramp"
(setq debug-ignored-errors
      (cons 'remote-file-error debug-ignored-errors))
#+end_src
** Hydra
Some inspirations from https://github.com/rememberYou/.emacs.d/blob/master/config.org

#+begin_src emacs-lisp
(use-package hydra
  :straight t)

(use-package hydra-examples
  :ensure nil)


(use-package major-mode-hydra
  :straight t
  :after hydra
  :preface
  (defun with-alltheicon (icon str &optional height v-adjust face)
    "Display an icon from all-the-icon."
    (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-faicon (icon str &optional height v-adjust face)
    "Display an icon from Font Awesome icon."
    (s-concat (all-the-icons-faicon icon ':v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-fileicon (icon str &optional height v-adjust face)
    "Display an icon from the Atom File Icons package."
    (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-octicon (icon str &optional height v-adjust face)
    "Display an icon from the GitHub Octicons."
    (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str)))
#+end_src

*** Hydra / Windows

Group window-related commands.

#+begin_src emacs-lisp
  (pretty-hydra-define hydra-windows
    (:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "windows" "Windows" 1 -0.05))
    ("Window"
     (("b" balance-windows "balance")
      ("c" centered-window-mode "center")
      ("i" enlarge-window "heighten")
      ("j" shrink-window-horizontally "narrow")
      ("k" shrink-window "lower")
      ("u" winner-undo "undo")
      ("r" winner-redo "redo")
      ("l" enlarge-window-horizontally "widen")
      ("s" switch-window-then-swap-buffer "swap" :color teal))
     "Zoom"
     (("-" text-scale-decrease "out")
      ("+" text-scale-increase "in")
      ("=" (text-scale-increase 0) "reset"))))
#+end_src
*** Hydra / Window Nav
From https://github.com/doomemacs/doomemacs/blob/master/modules/ui/hydra/autoload/windows.el

#+begin_src emacs-lisp
(defhydra +hydra/window-nav (:hint nil)
  "
          Split: _v_ert  _s_:horz
         Delete: _c_lose  _o_nly
  Switch Window: _h_:left  _j_:down  _k_:up  _l_:right  _u_:undo  _r_:redo
        Buffers: _p_revious  _n_ext  _b_:select  _f_ind-file
         Resize: _H_:splitter left  _J_:splitter down  _K_:splitter up  _L_:splitter right
           Move: _a_:up  _z_:down  _i_menu
"
  ("z" scroll-up-line)
  ("a" scroll-down-line)
  ("i" idomenu)

  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("u" winner-undo)
  ("r" winner-redo)

  ("p" previous-buffer)
  ("n" next-buffer)
  ("b" switch-to-buffer)
  ("f" find-file)

  ("s" split-window-below)
  ("v" split-window-right)

  ("c" delete-window)
  ("o" delete-other-windows)

  ("H" hydra-move-splitter-left)
  ("J" hydra-move-splitter-down)
  ("K" hydra-move-splitter-up)
  ("L" hydra-move-splitter-right)

  ("+" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("=" (text-scale-increase 0) "reset")

  ("q" nil))
#+end_src
*** Hydra / Flyspell
#+begin_src emacs-lisp
(defhydra flyspell-hydra ()
  "
Spell Commands^^           Add To Dictionary^^              Other
--------------^^---------- -----------------^^------------- -----^^---------------------------
[_b_] check whole buffer   [_B_] add word to dict (buffer)  [_t_] toggle spell check
[_r_] check region         [_G_] add word to dict (global)  [_q_] exit
[_d_] change dictionary    [_S_] add word to dict (session) [_Q_] exit and disable spell check
[_n_] next error
[_c_] correct before point
[_s_] correct at point
"
  ("B" nil)
  ("b" flyspell-buffer)
  ("r" flyspell-region)
  ("d" ispell-change-dictionary)
  ("G" nil)
  ("n" flyspell-goto-next-error)
  ("c" flyspell-correct-wrapper)
  ("Q" flyspell-mode :exit t)
  ("q" nil :exit t)
  ("S" nil)
  ("s" flyspell-correct-at-point)
  ("t" nil))
#+end_src
*** Hydra / ORG
**** hydra-org-jump
From [[https://sriramkswamy.github.io/dotemacs/]]

#+begin_src emacs-lisp
(defhydra sk/hydra-org-jump (:color pink :hint nil)
  "
 ^Outline^          ^Item^   ^Table^   ^Block^   ^Link^
 ^^^^^^^^^^^-------------------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _u_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _p_ ^ ^   ^ ^ _P_ ^ ^    _q_ quit
 _h_ ^+^ _l_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^   _b_ ^+^ _f_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _d_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _n_ ^ ^   ^ ^ _N_ ^ ^
"
  ("j" outline-next-visible-heading)
  ("k" outline-previous-visible-heading)
  ("l" org-down-element)
  ("h" org-up-element)
  ("J" org-forward-heading-same-level)
  ("K" org-backward-heading-same-level)
  ("u" org-next-item)
  ("d" org-previous-item)
  ("f" org-table-next-field)
  ("b" org-table-previous-field)
  ("n" org-next-block)
  ("p" org-previous-block)
  ("N" org-next-link)
  ("P" org-previous-link)
  ("q" nil :color blue))
#+end_src
**** hydra-org-babel-transient
#+begin_src emacs-lisp :tangle no
(defhydra org-babel-transient ()
  "
^Navigate^                    ^Interact
^^^^^^^^^^^------------------------------------------
[_t_/_s_] navigate src blocs  [_x_] execute src block
[_g_]^^   goto named block    [_'_] edit src block
[_z_]^^   recenter screen     [_q_] quit
"
  ("q" nil :exit t)
  ("t" org-babel-next-src-block)
  ("s" org-babel-previous-src-block)
  ("g" org-babel-goto-named-src-block)
  ("z" recenter-top-bottom)
  ("x" org-babel-execute-maybe)
  ("'" org-edit-special :exit t))
#+end_src
*** Hydra / merge
Group Merge commands.

#+begin_src emacs-lisp
(pretty-hydra-define hydra-merge
  (:hint nil :color pink :quit-key "q" :title (with-octicon "mark-github" "Magit" 1 -0.05))
  ("Move"
   (("n" smerge-next "next")
    ("p" smerge-prev "previous"))
   "Keep"
   (("RET" smerge-keep-current "current")
    ("a" smerge-keep-all "all")
    ("b" smerge-keep-base "base")
    ("l" smerge-keep-lower "lower")
    ("u" smerge-keep-upper "upper"))
   "Diff"
   (("<" smerge-diff-base-upper "upper/base")
    ("=" smerge-diff-upper-lower "upper/lower")
    (">" smerge-diff-base-lower "base/lower")
    ("R" smerge-refine "redefine")
    ("E" smerge-ediff "ediff"))
   "Other"
   (("C" smerge-combine-with-next "combine")
    ("r" smerge-resolve "resolve")
    ("k" smerge-kill-current "kill current"))))
#+end_src
jk
*** Hydra / smerge
From https://github.com/dakra/dmacs/blob/nil/init.org

#+begin_src emacs-lisp
(use-package smerge-mode
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (hydra-smerge/body))))
  :config
  (require 'hydra)
  (defhydra hydra-smerge
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("q" nil "cancel" :color blue)))
#+end_src
*** Hydra / modeline                                                 :todo:
#+begin_src emacs-lisp
(pretty-hydra-define hydra-modeline
  (:title "Modeline" :color amaranth :quit-key ("q" "C-g"))
   ("Icon"
    (("i" (setq doom-modeline-icon (not doom-modeline-icon))
      "display icons" :toggle doom-modeline-icon)
     ("u" (setq doom-modeline-unicode-fallback (not doom-modeline-unicode-fallback))
      "unicode fallback" :toggle doom-modeline-unicode-fallback)
     ("m" (setq doom-modeline-major-mode-icon (not doom-modeline-major-mode-icon))
      "major mode" :toggle doom-modeline-major-mode-icon)
     ("c" (setq doom-modeline-major-mode-color-icon (not doom-modeline-major-mode-color-icon))
      "colorful major mode" :toggle doom-modeline-major-mode-color-icon)
     ("s" (setq doom-modeline-buffer-state-icon (not doom-modeline-buffer-state-icon))
      "buffer state" :toggle doom-modeline-buffer-state-icon)
     ("o" (setq doom-modeline-buffer-modification-icon (not doom-modeline-buffer-modification-icon))
      "modification" :toggle doom-modeline-buffer-modification-icon)
     ("x" (setq doom-modeline-time-icon (not doom-modeline-time-icon))
      "time" :toggle doom-modeline-time-icon)
     ("v" (setq doom-modeline-modal-icon (not doom-modeline-modal-icon))
      "modal" :toggle doom-modeline-modal-icon))
    "Segment"
    (("g h" (setq doom-modeline-hud (not doom-modeline-hud))
      "hud" :toggle doom-modeline-hud)
     ("g m" (setq doom-modeline-minor-modes (not doom-modeline-minor-modes))
      "minor modes" :toggle doom-modeline-minor-modes)
     ("g w" (setq doom-modeline-enable-word-count (not doom-modeline-enable-word-count))
      "word count" :toggle doom-modeline-enable-word-count)
     ("g e" (setq doom-modeline-buffer-encoding (not doom-modeline-buffer-encoding))
      "encoding" :toggle doom-modeline-buffer-encoding)
     ("g i" (setq doom-modeline-indent-info (not doom-modeline-indent-info))
      "indent" :toggle doom-modeline-indent-info)
     ("g c" (setq doom-modeline-display-misc-in-all-mode-lines (not doom-modeline-display-misc-in-all-mode-lines))
      "misc info" :toggle doom-modeline-display-misc-in-all-mode-lines)
     ("g l" (setq doom-modeline-lsp (not doom-modeline-lsp))
      "lsp" :toggle doom-modeline-lsp)
     ("g k" (setq doom-modeline-workspace-name (not doom-modeline-workspace-name))
      "workspace" :toggle doom-modeline-workspace-name)
     ("g g" (setq doom-modeline-github (not doom-modeline-github))
      "github" :toggle doom-modeline-github)
     ("g n" (setq doom-modeline-gnus (not doom-modeline-gnus))
      "gnus" :toggle doom-modeline-gnus)
     ("g u" (setq doom-modeline-mu4e (not doom-modeline-mu4e))
      "mu4e" :toggle doom-modeline-mu4e)
     ("g r" (setq doom-modeline-irc (not doom-modeline-irc))
      "irc" :toggle doom-modeline-irc)
     ("g f" (setq doom-modeline-irc-buffers (not doom-modeline-irc-buffers))
      "irc buffers" :toggle doom-modeline-irc-buffers)
     ("g s" (progn
              (setq doom-modeline-checker-simple-format (not doom-modeline-checker-simple-format))
              (and (bound-and-true-p flycheck-mode) (flycheck-buffer)))
      "simple checker" :toggle doom-modeline-checker-simple-format)
     ("g t" (setq doom-modeline-time (not doom-modeline-time))
      "time" :toggle doom-modeline-time)
     ("g v" (setq doom-modeline-env-version (not doom-modeline-env-version))
      "version" :toggle doom-modeline-env-version))
    "Style"
    (("a" (setq doom-modeline-buffer-file-name-style 'auto)
      "auto"
      :toggle (eq doom-modeline-buffer-file-name-style 'auto))
     ("b" (setq doom-modeline-buffer-file-name-style 'buffer-name)
      "buffer name"
      :toggle (eq doom-modeline-buffer-file-name-style 'buffer-name))
     ("f" (setq doom-modeline-buffer-file-name-style 'file-name)
      "file name"
      :toggle (eq doom-modeline-buffer-file-name-style 'file-name))
     ("t u" (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
      "truncate upto project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-upto-project))
     ("t f" (setq doom-modeline-buffer-file-name-style 'truncate-from-project)
      "truncate from project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-from-project))
     ("t w" (setq doom-modeline-buffer-file-name-style 'truncate-with-project)
      "truncate with project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-with-project))
     ("t e" (setq doom-modeline-buffer-file-name-style 'truncate-except-project)
      "truncate except project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-except-project))
     ("t r" (setq doom-modeline-buffer-file-name-style 'truncate-upto-root)
      "truncate upto root"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-upto-root))
     ("t a" (setq doom-modeline-buffer-file-name-style 'truncate-all)
      "truncate all"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-all))
     ("t n" (setq doom-modeline-buffer-file-name-style 'truncate-nil)
      "truncate none"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-nil))
     ("r f" (setq doom-modeline-buffer-file-name-style 'relative-from-project)
      "relative from project"
      :toggle (eq doom-modeline-buffer-file-name-style 'relative-from-project))
     ("r t" (setq doom-modeline-buffer-file-name-style 'relative-to-project)
      "relative to project"
      :toggle (eq doom-modeline-buffer-file-name-style 'relative-to-project)))
    "Project Detection"
    (("p a" (setq doom-modeline-project-detection 'auto)
      "auto"
      :toggle (eq doom-modeline-project-detection 'auto))
     ("p f" (setq doom-modeline-project-detection 'ffip)
      "ffip"
      :toggle (eq doom-modeline-project-detection 'ffip))
     ("p i" (setq doom-modeline-project-detection 'projectile)
      "projectile"
      :toggle (eq doom-modeline-project-detection 'projectile))
     ("p p" (setq doom-modeline-project-detection 'project)
      "project"
      :toggle (eq doom-modeline-project-detection 'project))
     ("p n" (setq doom-modeline-project-detection nil)
      "disable"
      :toggle (eq doom-modeline-project-detection nil)))
    "Misc"
    (("n" (progn
            (message "Fetching GitHub notifications...")
            (run-with-timer 300 nil #'doom-modeline--github-fetch-notifications)
            (browse-url "https://github.com/notifications"))
      "github notifications" :exit t)
     ("e" (cond ((bound-and-true-p flycheck-mode)
                 (flycheck-list-errors))
                ((bound-and-true-p flymake-mode)
                 (flymake-show-diagnostics-buffer)))
      "list errors" :exit t)
     ("w" (if (bound-and-true-p grip-mode)
              (grip-browse-preview)
            (message "Not in preview"))
      "browse preview" :exit t)
     ("z h" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-height
                     (symbol-value 'doom-modeline-height)))
      "set height" :exit t)
     ("z w" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-bar-width
                     (symbol-value 'doom-modeline-bar-width)))
      "set bar width" :exit t)
     ("z g" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-github-interval
                     (symbol-value 'doom-modeline-github-interval)))
      "set github interval" :exit t)
     ("z n" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-gnus-timer
                     (symbol-value 'doom-modeline-gnus-timer)))
      "set gnus interval" :exit t))))

#+end_src
*** Hydra / unicode
From https://github.com/dakra/dmacs/blob/nil/init.org
Add here circled digits like: ②
#+begin_src emacs-lisp
(defun dakra/insert-unicode (unicode-name)
  "Same as C-x 8 enter UNICODE-NAME."
  (insert-char (gethash unicode-name (ucs-names))))

(defhydra dakra/hydra-unicode (:color blue :hint nil)
  "
     Unicode  _c_ €   _a_ ä   _A_ Ä
              _d_ °   _o_ ö   _O_ Ö
              _e_ €   _u_ Ü   _U_ Ü
              _p_ £   _s_ ß
              _m_ µ
              _r_ →
     "
  ("a" (dakra/insert-unicode "LATIN SMALL LETTER A WITH DIAERESIS"))
  ("A" (dakra/insert-unicode "LATIN CAPITAL LETTER A WITH DIAERESIS"))
  ("o" (dakra/insert-unicode "LATIN SMALL LETTER O WITH DIAERESIS")) ;;
  ("O" (dakra/insert-unicode "LATIN CAPITAL LETTER O WITH DIAERESIS"))
  ("u" (dakra/insert-unicode "LATIN SMALL LETTER U WITH DIAERESIS")) ;;
  ("U" (dakra/insert-unicode "LATIN CAPITAL LETTER U WITH DIAERESIS"))
  ("s" (dakra/insert-unicode "LATIN SMALL LETTER SHARP S"))
  ("c" (dakra/insert-unicode "COPYRIGHT SIGN"))
  ("d" (dakra/insert-unicode "DEGREE SIGN"))
  ("e" (dakra/insert-unicode "EURO SIGN"))
  ("p" (dakra/insert-unicode "POUND SIGN"))
  ("r" (dakra/insert-unicode "RIGHTWARDS ARROW"))
  ("m" (dakra/insert-unicode "MICRO SIGN")))
#+end_src
** Icons
** Misc
*** Keycast
In case I am sharing my screen with people and I want to show which
functions are called on my keystrokes since I don’t exactly use
standard keybindings.

#+begin_src emacs-lisp
(use-package keycast
  :defer t
  :straight (:build t)
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (add-hook 'pre-command-hook 'keycast--update t)
      (remove-hook 'pre-command-hook 'keycast--update)))
  (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
#+end_src
** Navigation
*** ~avy~
~avy~ is a really convenient way of jumping around and performing
actions on these selections, but I’ll need some configuration to make
it bépo-compatible.
#+begin_src emacs-lisp
(use-package avy
  :defer t
  :straight t
  :config
  (csetq avy-keys           '(?a ?u ?i ?e ?c ?t ?s ?r ?n)
         avy-dispatch-alist '((?x . avy-action-kill-move)
                              (?X . avy-action-kill-stay)
                              (?T . avy-action-teleport)
                              (?m . avy-action-mark)
                              (?C . avy-action-copy)
                              (?y . avy-action-yank)
                              (?Y . avy-action-yank-line)
                              (?I . avy-action-ispell)
                              (?z . avy-action-zap-to-char)))
  (defun my/avy-goto-url ()
    "Jump to url with avy."
    (interactive)
    (avy-jump "https?://"))
  (defun my/avy-open-url ()
    "Open url selected with avy."
    (interactive)
    (my/avy-goto-url)
    (browse-url-at-point))
  :general
  (phundrak/evil
    :pakages 'avy
    "gc" #'evil-avy-goto-char-timer
    "gl" #'evil-avy-goto-line)
  (phundrak/leader-key
    :packages 'avy
    :infix "j"
    "b" #'avy-pop-mark
    "c" #'evil-avy-goto-char-timer
    "l" #'avy-goto-line)
  (phundrak/leader-key
    :packages 'avy
    :infix "A"
    "c"  '(:ignore t :which-key "copy")
    "cl" #'avy-copy-line
    "cr" #'avy-copy-region
    "k"  '(:ignore t :which-key "kill")
    "kl" #'avy-kill-whole-line
    "kL" #'avy-kill-ring-save-whole-line
    "kr" #'avy-kill-region
    "kR" #'avy-kill-ring-save-region
    "m"  '(:ignore t :which-key "move")
    "ml" #'avy-move-line
    "mr" #'avy-move-region
    "mt" #'avy-transpose-lines-in-region
    "n"  #'avy-next
    "p"  #'avy-prev
    "u"  #'my/avy-goto-url
    "U"  #'my/avy-open-url)
  (phundrak/major-leader-key
    :packages '(avy org)
    :keymaps 'org-mode-map
    "A" '(:ignore t :which-key "avy")
    "Ar" #'avy-org-refile-as-child
    "Ah" #'avy-org-goto-heading-timer))
#+end_src
** PDF Tools
~pdf-tools~ enables PDF support for Emacs, much better than its built-in
support with DocView. Aside from the classical settings such as
keybinds, I also enable the midnight colours by default; think of it
as an equivalent of Zathura’s recolour feature which kind of enables a
dark mode for PDFs.
#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :magic ("%PDF" . pdf-view-mode)
  :straight (:build t)
  :hook (pdf-tools-enabled . pdf-view-midnight-minor-mode)
  :general
  (phundrak/evil
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "y"   #'pdf-view-kill-ring-save
    "t"   #'evil-collection-pdf-view-next-line-or-next-page
    "s"   #'evil-collection-pdf-view-previous-line-or-previous-page)
  (phundrak/major-leader-key
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "a"  '(:ignore t :which-key "annotations")
    "aD" #'pdf-annot-delete
    "at" #'pdf-annot-attachment-dired
    "ah" #'pdf-annot-add-highlight-markup-annotation
    "al" #'pdf-annot-list-annotations
    "am" #'pdf-annot-markup-annotation
    "ao" #'pdf-annot-add-strikeout-markup-annotation
    "as" #'pdf-annot-add-squiggly-markup-annotation
    "at" #'pdf-annot-add-text-annotation
    "au" #'pdf-annot-add-underline-markup-annotation

    "f"  '(:ignore t :which-key "fit")
    "fw" #'pdf-view-fit-width-to-window
    "fh" #'pdf-view-fit-height-to-window
    "fp" #'pdf-view-fit-page-to-window

    "s"  '(:ignore t :which-key "slice/search")
    "sb" #'pdf-view-set-slice-from-bounding-box
    "sm" #'pdf-view-set-slice-using-mouse
    "sr" #'pdf-view-reset-slice
    "ss" #'pdf-occur

    "o"  'pdf-outline
    "m"  'pdf-view-midnight-minor-mode)
  :config
  (with-eval-after-load 'pdf-view
    (csetq pdf-view-midnight-colors '("#d8dee9" . "#2e3440"))))
#+end_src

One thing ~pdf-tools~ doesn’t handle is restoring the PDF to the last
point it was visited --- in other words, open the PDF where I last
left it.
#+begin_src emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :defer t
  :straight (:build t)
  :hook (pdf-view-mode . pdf-view-restore-mode)
  :config
  (setq pdf-view-restore-filename (expand-file-name ".tmp/pdf-view-restore"
                                                    user-emacs-directory)))
#+end_src
** Project Management
*** Version control
**** diffs
#+begin_src emacs-lisp
;; From https://github.com/dakra/dmacs/blob/nil/init.org
(use-package diff-mode
  :config
  ;; Shorten file headers like Magit's diff format.
  (setq diff-font-lock-prettify t))

(use-package ediff
  :defer t
  :config
  ;; Always expand files before diffing (especially org files)
  (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
  ;; Do everything in one frame
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  ;; Split ediff windows horizontally by default
  (setq ediff-split-window-function 'split-window-horizontally))

#+end_src

*** Magit
#+begin_src emacs-lisp
(use-package magit
  :straight (:build t)
  :defer t
  :init
  (setq forge-add-default-bindings nil)
  :config
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source)
  <<magit-angular-keywords-highlight>>
  (csetq magit-clone-default-directory "~/fromGIT/"
         magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (with-eval-after-load 'evil-collection
    (phundrak/evil
      :packages '(evil-collection magit)
      :keymaps '(magit-mode-map magit-log-mode-map magit-status-mode-map)
      :states 'normal
      "t" #'magit-tag
      "s" #'magit-stage))
  :general
  (:keymaps '(git-rebase-mode-map)
   :packages 'magit
   "C-t" #'evil-next-line
   "C-s" #'evil-previous-line)
  (phundrak/major-leader-key
    :keymaps 'git-rebase-mode-map
    :packages 'magit
    "," #'with-editor-finish
    "k" #'with-editor-cancel
    "a" #'with-editor-cancel)
  (phundrak/leader-key
    :infix   "g"
    :packages 'magit
    ""   '(:ignore t :wk "git")
    "b"  #'magit-blame
    "c"  #'magit-clone
    "d"  #'magit-dispatch
    "i"  #'magit-init
    "s"  #'magit-status
    "l"  #'magit-log
    "y"  #'my/yadm
    "S"  #'magit-stage-file
    "U"  #'magit-unstage-file
    "f"  '(:ignore t :wk "file")
    "fd" #'magit-diff
    "fc" #'magit-file-checkout
    "fl" #'magit-file-dispatch
    "fF" #'magit-find-file))
#+end_src

There is currently a bug in Emacs TRAMP as described in issue [[https://github.com/magit/magit/issues/4720][#4720]] of
Magit and bug [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=62093][62093]] of Emacs. A workaround is to redefine the old
=tramp-send-command= function through an advice.
#+begin_src emacs-lisp
(defun my--tramp-send-command--workaround-stty-icanon-bug (conn-vec orig-command &rest args)
  "See: https://github.com/magit/magit/issues/4720"
  (let ((command
         (if (string= "stty -icrnl -icanon min 1 time 0" orig-command)
             "stty -icrnl"
           orig-command)))
    (append (list conn-vec command) args)))

(defun my--tramp-send-command--workaround-stty-icanon-bug--filter-args (args)
  (apply #'my--tramp-send-command--workaround-stty-icanon-bug args))

(advice-add 'tramp-send-command :filter-args
            #'my--tramp-send-command--workaround-stty-icanon-bug--filter-args)
#+end_src

I also want to highlight these angular-style keywords in commit messages.
#+name: magit-angular-keywords-highlight
#+begin_src emacs-lisp :tangle no
(defun my/magit-log-highlight-angular-keywords (_rev msg)
  "Highlight angular-style keywords in commit messages."
  (let ((boundary 0))
    (when (string-match (rx (seq (or "feat" "fix" "docs" "style" "refactor"
                                     "perf" "test" "chore")
                                 (* "(" (* (not ")")) ")")
                                 ":"))
                        msg
                        boundary)
        (setq boundary (match-end 0))
        (magit--put-face (match-beginning 0) boundary
                         'magit-keyword msg)))
  msg)

(advice-add #'magit-log-propertize-keywords
            :after
            #'my/magit-log-highlight-angular-keywords)
#+end_src

[[https://github.com/alphapapa][Alphapapa]] also created an awesome package for Magit: magit-todos which
display in the Magit buffer a list of TODOs found in the current
project to remind you of what to do next.

First, let’s setup our todo keywords with =hl-todo=. A good few todo
keywords are already defined in the =hl-todo-keyword-faces= variable.
Why not use them? =hl-todo-mode= enables fontlock highlight of these
keywords in a buffer. Let’s enable this mode globally.
#+begin_src emacs-lisp
;; (use-package hl-todo
;;   :defer t
;;   :straight (:build t)
;;   :init (global-hl-todo-mode 1)
;;   :general
;;   (phundrak/leader-key
;;     :packages '(hl-todo)
;;     :infix "c"
;;     ""  '(:ignore t :which-key "todos")
;;     "n" #'hl-todo-next
;;     "p" #'hl-todo-previous))
#+end_src

We can now configure properly =magit-todos=. Notice my custom function
hooked to =magit-mode-hook=. This is because this package tries to find
TODOs in all files in the current project, and my yadm repository’s
root is my =$HOME=. So, yeah, no =magit-todos= in yadm.
#+begin_src emacs-lisp
;; (use-package magit-todos
;;   :straight (:build t)
;;   :after (magit hl-todo)
;;   :init
;;   (with-eval-after-load 'magit
;;    (defun my/magit-todos-if-not-yadm ()
;;      "Deactivate magit-todos if in yadm Tramp connection.
;; If `magit--default-directory' points to a yadm Tramp directory,
;; deactivate `magit-todos-mode', otherwise enable it."
;;      (if (string-prefix-p "/yadm:" magit--default-directory)
;;          (magit-todos-mode -1)
;;        (magit-todos-mode +1)))
;;    (add-hook 'magit-mode-hook #'my/magit-todos-if-not-yadm))
;;   :config
;;   (csetq magit-todos-ignore-case t))
#+end_src

*** Forge

#+begin_src emacs-lisp
;; (use-package forge
;;   :after magit
;;   :straight (:build t)
;;   :init
;;   (evil-collection-forge-setup)
;;   :general
;;   (phundrak/major-leader-key
;;     :keymaps 'forge-topic-mode-map
;;     "c"  #'forge-create-post
;;     "e"  '(:ignore t :which-key "edit")
;;     "ea" #'forge-edit-topic-assignees
;;     "ed" #'forge-edit-topic-draft
;;     "ek" #'forge-delete-comment
;;     "el" #'forge-edit-topic-labels
;;     "em" #'forge-edit-topic-marks
;;     "eM" #'forge-merge
;;     "en" #'forge-edit-topic-note
;;     "ep" #'forge-edit-post
;;     "er" #'forge-edit-topic-review-requests
;;     "es" #'forge-edit-topic-state
;;     "et" #'forge-edit-topic-title))
#+end_src
**** browse-at-remote
#+begin_src emacs-lisp
(use-package browse-at-remote
  :straight t
  :bind (("C-c G" . browse-at-remote))
  :general
  (phundrak/leader-key
    :infix   "g"
    :packages 'magit
    ""   '(:ignore t :wk "git")
    "y"  #'browse-at-remote-kill
    "o" #'browse-at-remote))
#+end_src
**** diff-hl-mode
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   ;; (prog-mode . diff-hl-mode)
   ;; (org-mode . diff-hl-mode)
   (dired-mode . diff-hl-dired-mode)))
#+end_src

#+RESULTS:
| org-download-enable | diff-hl-dired-mode |

*** Projectile
First, I need to install ~ripgrep~, a faster reimplementation of ~grep~,
which will be very useful when managing projects.
#+begin_src emacs-lisp
(use-package ripgrep
  :if (executable-find "rg")
  :straight (:build t)
  :defer t)
#+end_src

Now, I can use projectile, which is sort of the /de facto/ standard
project manager in Emacs. I know there’s ~project.el~, but… Eh… I’m used
to projectile.
#+begin_src emacs-lisp
(use-package projectile
  :straight t
  :diminish projectile-mode
  ;; :custom ((projectile-completion-system 'default))
  :config
  (projectile-mode)
  ;; (setq projectile-completion-system 'default)
  ;; (setq projectile-switch-project-action #'projectile-dired)

  (add-to-list 'projectile-ignored-projects "~/")
  (add-to-list 'projectile-globally-ignored-files "node_modules")
  (add-to-list 'projectile-globally-ignored-files ".cache")
  (add-to-list 'projectile-globally-ignored-files "_cache")
  (add-to-list 'projectile-globally-ignored-files "~")
  (add-to-list 'projectile-globally-ignored-files "^#")
  (add-to-list 'projectile-globally-ignored-directories "^node_modules$")
  :general
  (phundrak/leader-key
    "p" '(:keymap projectile-command-map :which-key "projectile")))
#+end_src

And of course, there is a counsel package dedicated to projectile.
#+begin_src emacs-lisp
;; (use-package counsel-projectile
;;   :straight (:build t)
;;   :after (counsel projectile)
;;   :config (counsel-projectile-mode))
#+end_src

*** Recentf
The built-in package ~recentf~ keeps track of recently opened files. But
by default, it only follows the twenty most recent files, that not
nearly enough for me, so I raise it to two hundred. I also don’t want
recentf to follow the Elfeed database, so I add it to the list of
excluded files.
#+begin_src emacs-lisp
(use-package recentf
  :straight (:build t :type built-in)
  :custom ((recentf-max-saved-items 2000))
  :config
  (add-all-to-list 'recentf-exclude
                   `(,(rx (* any)
                          (or "elfeed-db"
                              "eln-cache"
                              "conlanging/content"
                              "org/config"
                              "/Mail/Sent"
                              ".cache/")
                          (* any)
                          (? (or "html" "pdf" "tex" "epub")))
                     ,(rx (* any)
                          ".elc"
                          eol)
                     ,(rx "/"
                          (or "rsync" "ssh" "tmp" "yadm" "sudoedit" "sudo")
                          (* any)))))
#+end_src

*** ejira
Still not convinced, but let's activate it:

#+begin_src emacs-lisp
(use-package jiralib2
  :straight t
  :commands (ejira-mode)
  :init
  (defun dorneanu/setup-jira ()
    (interactive)
    (setq jiralib2-url              (password-store-get "emacs/ejira-url")
          jiralib2-auth             'token
          jiralib2-token             (password-store-get "emacs/ejira-token")
          jiralib2-user-login-name  (password-store-get "emacs/ejira-user"))))



(use-package ejira
  :straight (ejira :build t
                      :type git
                      :host github
                      :repo "nyyManni/ejira")
  :after (jiralib2)
  :init
  (setq
   ;; NOTE, this directory needs to be in `org-agenda-files'`
   ejira-org-directory       "~/work/jira"
   ejira-projects            '("QDS" "INI")

   ejira-priorities-alist    '(("Highest" . ?A)
                               ("High"    . ?B)
                               ("Medium"  . ?C)
                               ("Low"     . ?D)
                               ("Lowest"  . ?E))
   ejira-todo-states-alist   '(("To Do"       . 1)
                               ("In Progress" . 2)
                               ("Done"        . 4)))
  ;; Update my jira projects
  (defun dorneanu/jira-update-projects ()
    (interactive)
    (let ((org-agenda-files nil))
      (ejira-update-my-projects)))


  :config
  ;; Tries to auto-set custom fields by looking into /editmeta
  ;; of an issue and an epic.
  (add-hook 'jiralib2-post-login-hook #'ejira-guess-epic-sprint-fields)

  ;; Make the issues visisble in your agenda by adding `ejira-org-directory'
  ;; into your `org-agenda-files'.
  (add-to-list 'org-agenda-files ejira-org-directory))

#+end_src
*** wakatime
#+begin_src emacs-lisp
(use-package wakatime-mode
  :straight t
  :config
  (setq
   ;; TODO: Need to change these to something more flexible/portable
   wakatime-python-bin "/home/victor/.pyenv/versions/emacs/bin/python"
   wakatime-cli-path "/home/victor/.pyenv/versions/emacs/bin/wakatime")
  (global-wakatime-mode))
#+end_src
*** WIP jira

** rg.el
#+begin_src emacs-lisp
(use-package rg
  :straight t
  :config
  (rg-enable-default-bindings)
  ;; Not sure if I really need this
  (rg-define-toggle "--multiline --multiline-dotall" "u")
  (rg-define-toggle "--word-regexp" "w")
  (rg-define-toggle "--files-with-matches" "L")
  ;; Highlight longer
  (setq next-error-highlight-no-select t)
  (add-hook 'next-error-hook #'recenter)
  (add-hook 'next-error-hook #'focus-mode)
)
#+end_src

Configure custom searches
#+begin_src emacs-lisp
;; search in org roam folder
(rg-define-search my/rg-org-roam-directory
  :query ask
  :format regexp
  :files "everything"
  :dir org-roam-directory
  :confirm prefix)

;; search in org roam folder where I have transcripts from the Huberman Lab
(rg-define-search my/rg-org-roam-directory-huberman
  :query ask
  :format regexp
  :files "everything"
  :dir (concat org-roam-directory "/rez/huberman-lab")
  :confirm prefix)

(setq dotemacs-directory "/cs/priv/repos/dotemacs")
(rg-define-search my/rg-dotemacs
  :query ask
  :format regexp
  :files "everything"
  :dir dotemacs-directory
  :confirm prefix)

#+end_src

** Screenshots
*** emacsshot
From https://gitlab.com/marcowahl/emacsshot
#+begin_src emacs-lisp
(use-package emacsshot
  :straight t
  :bind(("C-x a s f" . my/emacsshot-snap-frame)
        ("C-x a s w" . my/emacsshot-snap-window))
  :config
  (defun copy-file-content-to-clipboard (file-path)
    (shell-command (format "xclip -selection clipboard -t image/png -i %s" file-path)))
  (defun my/emacsshot-snap-window ()
    (interactive)
    (emacsshot-snap-window)
    (copy-file-content-to-clipboard "~/emacsshot.png")
    )
  (defun my/emacsshot-snap-frame ()
    (interactive)
    (emacsshot-snap-frame)
    (copy-file-content-to-clipboard "~/emacsshot.png")
    ))
#+end_src

** Security
*** COMMENT Bitwarden
This package is still a very much work in progress one I’m developing
in order to interact with Bitwarden in Emacs with the help of the
[[https://github.com/bitwarden/cli][Bitwarden CLI]]. Use at your own risks.
#+begin_src emacs-lisp
(use-package bitwarden
  :defer t
  :straight (bitwarden :build t
                       :type git
                       :host nil
                       :repo "https://labs.phundrak.com/phundrak/bitwarden.el"))
#+end_src

*** pass
#+begin_src emacs-lisp
(use-package pass
  :straight t)
#+end_src
*** epa-file
Configure GPG assistant

#+begin_src emacs-lisp
(use-package epa-file
  :ensure nil
  :config
  (setq
   epa-file-encrypt-to '("BF2828095372F24D")
   password-cache nil
   password-cache-expiry nil
   epa-pinentry-mode 'ask)
  :custom
  (epa-file-select-keys 'silent))
#+end_src
** Shells
*** eshell
#+begin_src emacs-lisp
(use-package eshell
  :ensure nil
  :hook
  (eshell-mode . (lambda () (eshell/export "NODE_NO_READLINE=1")))
  (eshell-exit . (lambda () (setq esh-prompt-num 0)))

  :config
  ;; Don't use any pagers
  (setenv "PAGER" "cat")

  ;; Emulate terminal
  (setenv "TERM" "xterm-256color")

  ;; If I ever want my own eshell/foo commands overwrite real commands ...
  (setq eshell-prefer-lisp-functions t)
  (setq eshell-prefer-lisp-variables t)

  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 3600) ; for one hour (time in secs)

  ;; Increase eshell history size
  (setq eshell-history-size 8192)


  ;; Functions starting with `eshell/' can be called directly from eshell
  ;; with only the last part. E.g. (eshell/foo) will call `$ foo'

  (defun clipboard/set (astring)
    "Copy a string to clipboard"
    (with-temp-buffer
      (insert astring)
      (clipboard-kill-region (point-min) (point-max))))

  (defun eshell/copy-pwd ()
    "Copy current directory to clipboard "
    (clipboard/set (eshell/pwd)))

  (defun eshell/copy-fpath (fname)
    "Copy file name with full path to clipboard "
    (let ((fpath (concat (eshell/pwd) "/" fname)))
      (clipboard/set fpath)
      (concat "Copied path: " fpath)))

  (defun eshell/d (&rest args)
    "Open dired in current directory."
    (dired (pop args) "."))

  (defun eshell/ccat (file)
    "Like `cat' but output with Emacs syntax highlighting."
    (with-temp-buffer
      (insert-file-contents file)
      (let ((buffer-file-name file))
        (delay-mode-hooks
          (set-auto-mode)
          (if (fboundp 'font-lock-ensure)
              (font-lock-ensure)
            (with-no-warnings
              (font-lock-fontify-buffer)))))
      (buffer-string)))

  (defun eshell/find (&rest args)
    "Wrapper around the ‘find’ executable."
    (let ((cmd (concat "find " (string-join args))))
      (shell-command-to-string cmd)))

  ;; Don't print the welcome banner and
  ;; use native 'sudo', system sudo asks for password every time.
  (require 'em-tramp)
  (setq eshell-modules-list
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix))

  (require 'em-hist)
  ;; Some ideas from https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org
  (setq-default eshell-scroll-to-bottom-on-input 'all
                eshell-error-if-no-glob t
                eshell-hist-ignoredups t
                eshell-visual-commands '("ptpython" "ipython" "pshell" "tail" "vi" "vim" "watch"
                                         "nmtui" "dstat" "mycli" "pgcli" "vue" "ngrok"
                                         "castnow" "mitmproxy" "rmapi"
                                         "tmux" "screen" "top" "htop" "less" "more" "ncftp")
                eshell-prefer-lisp-functions nil)

  ;; Furthger hooks
  (add-hook 'eshell-mode-hook (lambda ()
                                ;; (local-set-key (kbd "M-P") 'eshell-previous-prompt)
                                ;; (local-set-key (kbd "M-N") 'eshell-next-prompt)
                                (local-set-key (kbd "M-R") 'eshell-list-history)
                                (local-set-key (kbd "C-.") 'consult-history)
                                ;; (local-set-key (kbd "DEL") 'eshell-delete-backward-char)
                                (local-set-key [remap eshell-pcomplete] 'completion-at-point)

                                ;; Support imenu
                                (setq-local imenu-generic-expression `(("Prompt" ,eshell-prompt-regexp 1)))
                                ;; Support outline (e.g. consult-outline)
                                (setq-local outline-regexp eshell-prompt-regexp)

                                ;; Disable overwriting the history on eshell exit
                                ;; See eshell-append-history above
                                (remove-hook 'eshell-exit-hook #'eshell-write-history t)

                                (setq xterm-color-preserve-properties t)

                                (setq-local company-backends '((company-eshell-history
                                                                company-shell
                                                                company-shell-env
                                                                company-files
                                                                company-dabbrev-code
                                                                company-capf
                                                                company-yasnippet))))))

#+end_src
**** company-eshell-history
Company eshell history completion backend.
From https://gist.github.com/gregsexton/dd2d6c304d06fc3e6833

Set as backend in =eshell-mode-hook= in eshell section above.
#+BEGIN_SRC emacs-lisp
(defun company-eshell-history (command &optional arg &rest ignored)
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-eshell-history))
    (prefix (and (eq major-mode 'eshell-mode)
                 (let ((word (company-grab-word)))
                   (save-excursion
                     (eshell-bol)
                     (and (looking-at-p (s-concat word "$")) word)))))
    (candidates (cl-remove-duplicates
                 (->> (ring-elements eshell-history-ring)
                   (cl-remove-if-not (lambda (item) (s-prefix-p arg item)))
                   (mapcar 's-trim))
                 :test 'string=))
    (sorted t)))
#+END_SRC

**** Prompt
#+BEGIN_SRC emacs-lisp
;; Show git info in prompt
(use-package eshell-prompt-extras
  :straight t
  :after eshell
  ;; :config
  ;; (require 'virtualenvwrapper)
 )
#+END_SRC

*** shell-pop
Shell-pop allows the user to easily call for a new shell in a pop-up
buffer.
#+begin_src emacs-lisp
(use-package shell-pop
  :defer t
  :straight (:build t)
  :custom
  (shell-pop-default-directory "/home/phundrak")
  (shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda () (eshell shell-pop-term-shell)))))
  (shell-pop-window-size 30)
  (shell-pop-full-span nil)
  (shell-pop-window-position "bottom")
  (shell-pop-autocd-to-working-dir t)
  (shell-pop-restore-window-configuration t)
  (shell-pop-cleanup-buffer-at-process-exit t))
#+end_src

*** VTerm
VTerm gives Emacs access to regular shells with an almost regular
emulator. Be aware you will most likely need to hit ~C-c~ twice to send
an interrupt signal.
#+begin_src emacs-lisp
(use-package vterm
  :defer t
  :straight t
  :config
  (setq vterm-shell "/usr/bin/zsh"))
#+end_src

One annoying think with vterm is it only can create one buffer, you
can’t have multiple vterm buffers by default. ~multi-vterm~ fixes this
issue.
#+begin_src emacs-lisp
(use-package multi-vterm
  :after vterm
  :defer t
  :straight (:build t)
  :general
  ;; (phundrak/major-leader-key
  ;;   :packages '(vterm multi-vterm)
  ;;   :keymap 'vterm-mode-map
  ;;   "c" #'multi-vterm
  ;;   "n" #'multi-vterm-next
  ;;   "p" #'multi-vterm-prev)
  )
#+end_src
*** COMMENT Eshell
[[file:../img/emacs-eshell.svg]]

Eshell is a built-in shell available from Emacs which I use almost as
often as fish. Some adjustments are necessary to make it fit my taste
though.
#+begin_src emacs-lisp
(use-package eshell
  :defer t
  :straight (:type built-in :build t)
  :config
  (setq eshell-prompt-function
        (lambda ()
          (concat (abbreviate-file-name (eshell/pwd))
                  (if (= (user-uid) 0) " # " " λ ")))
        eshell-prompt-regexp "^[^#λ\n]* [#λ] ")
  <<eshell-alias-file>>
  <<eshell-concat-shell-command>>
  <<eshell-alias-open>>
  <<eshell-alias-clear>>
  <<eshell-alias-buffers>>
  <<eshell-alias-emacs>>
  <<eshell-alias-mkcd>>
  :general
  (phundrak/evil
    :keymaps 'eshell-mode-map
    [remap evil-collection-eshell-evil-change] #'evil-backward-char
    "c" #'evil-backward-char
    "t" #'evil-next-visual-line
    "s" #'evil-previous-visual-line
    "r" #'evil-forward-char
    "h" #'evil-collection-eshell-evil-change)
  (general-define-key
   :keymaps 'eshell-mode-map
   :states 'insert
   "C-a" #'eshell-bol
   "C-e" #'end-of-line))
#+end_src

**** Aliases
First, let’s declare our list of “dumb” aliases we’ll use in
Eshell. You can find them here.
#+name: eshell-alias-file
#+begin_src emacs-lisp :tangle no
(setq eshell-aliases-file (expand-file-name "eshell-alias" user-emacs-directory))
#+end_src

A couple of other aliases will be defined through custom Elisp
functions, but first I’ll need a function for concatenating a shell
command into a single string:
#+name: eshell-concat-shell-command
#+begin_src emacs-lisp :tangle no
(defun phundrak/concatenate-shell-command (&rest command)
  "Concatenate an eshell COMMAND into a single string.
All elements of COMMAND will be joined in a single
space-separated string."
  (mapconcat #'identity command " "))
#+end_src

I’ll also declare some aliases here, such as ~open~ and ~openo~ that
respectively allow me to open a file in Emacs, and same but in another
window.
#+name: eshell-alias-open
#+begin_src emacs-lisp :tangle no
(defalias 'open #'find-file)
(defalias 'openo #'find-file-other-window)
#+end_src

The default behaviour of ~eshell/clear~ is not great at all, although it
clears the screen it also scrolls all the way down. Therefore, let’s
alias it to ~eshell/clear-scrollback~ which has the correct behaviour.
#+name: eshell-alias-clear
#+begin_src emacs-lisp :tangle no
(defalias 'eshell/clear #'eshell/clear-scrollback)
#+end_src

As you see, these were not declared in my dedicated aliases file but
rather were declared programmatically. This is because I like to keep
my aliases file for stuff that could work too with other shells were
the syntax a bit different, and aliases related to Elisp are kept
programmatically. I’ll also declare ~list-buffers~ an alias of ~ibuffer~
because naming it that way kind of makes more sense to me.
#+name: eshell-alias-buffers
#+begin_src emacs-lisp :tangle no
(defalias 'list-buffers 'ibuffer)
#+end_src

I still have some stupid muscle memory telling me to open ~emacs~, ~vim~
or ~nano~ in Eshell, which is stupid: I’m already inside Emacs and I
have all its power available instantly. So, let’s open each file
passed to these commands.
#+name: eshell-alias-emacs
#+begin_src emacs-lisp :tangle no
(defun eshell/emacs (&rest file)
  "Open each FILE and kill eshell.
Old habits die hard."
  (when file
    (dolist (f (reverse file))
      (find-file f t))))
#+end_src

Finally, I’ll declare ~mkcd~ which allows the simultaneous creation of a
directory and moving into this newly created directory. And of course,
it will also work if the directory also exists or if parent
directories don’t, similarly to the ~-p~ option passed to ~mkdir~.
#+name: eshell-alias-mkcd
#+begin_src emacs-lisp :tangle no
(defun eshell/mkcd (dir)
  "Create the directory DIR and move there.
If the directory DIR doesn’t exist, create it and its parents
if needed, then move there."
  (mkdir dir t)
  (cd dir))
#+end_src

**** Commands
When I’m in Eshell, sometimes I wish to open multiple files at once in
Emacs. For this, when I have several arguments for ~find-file~, I want
to be able to open them all at once. Let’s modify ~find-file~ like so:
#+BEGIN_SRC emacs-lisp
(defadvice find-file (around find-files activate)
  "Also find all files within a list of files. This even works recursively."
  (if (listp filename)
      (cl-loop for f in filename do (find-file f wildcards))
    ad-do-it))
#+END_SRC

I also want to be able to have multiple instances of Eshell opened at
once. For that, I declared the function ~eshell-new~ that does exactly
that.
#+begin_src emacs-lisp
(defun eshell-new ()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+end_src

A very useful command I often use in fish is ~z~, a port from bash’s and
zsh’s command that allows to jump around directories based on how
often we go in various directories.
#+begin_src emacs-lisp
(use-package eshell-z
  :defer t
  :after eshell
  :straight (:build t)
  :hook (eshell-mode . (lambda () (require 'eshell-z))))
#+end_src

**** Environment Variables
Some environment variables need to be correctly set so Eshell can
correctly work. I would like to set two environment variables related
to Dart development: the ~DART_SDK~ and ~ANDROID_HOME~ variables.
#+BEGIN_SRC emacs-lisp
(setenv "DART_SDK" "/opt/dart-sdk/bin")
(setenv "ANDROID_HOME" (concat (getenv "HOME") "/Android/Sdk/"))
#+END_SRC

The ~EDITOR~ variable also needs to be set for git commands, especially the
~yadm~ commands.
#+BEGIN_SRC emacs-lisp
(setenv "EDITOR" "emacsclient -c -a emacs")
#+END_SRC

Finally, for some specific situations I need ~SHELL~ to be set to
something more standard than fish:
#+begin_src emacs-lisp
(setenv "SHELL" "/bin/sh")
#+end_src

**** Visual configuration
I like to have at quick glance some information about my machine when
I fire up a terminal. I haven’t found anything that does that the way
I like it, so [[https://github.com/Phundrak/eshell-info-banner.el][I’ve written a package]]! It’s actually available on
Melpa, but since I’m the main dev of this package, I’ll keep track of
the git repository.
#+begin_src emacs-lisp
(use-package eshell-info-banner
  :after (eshell)
  :defer t
  :straight (eshell-info-banner :build t
                                :type git
                                :host github
                                :protocol ssh
                                :repo "phundrak/eshell-info-banner.el")
  :hook (eshell-banner-load . eshell-info-banner-update-banner)
  :custom-face
  (eshell-info-banner-normal-face ((t :foreground "#A3BE8C")))
  (eshell-info-banner-background-face ((t :foreground "#E5E9F0")))
  (eshell-info-banner-warning-face ((t :foreround "#D08770")))
  (eshell-info-banner-critical-face ((t :foreground "#BF616A")))
  :custom
  (eshell-info-banner-partition-prefixes (list "/dev" "zroot" "tank")))
#+end_src

Another feature I like is fish-like syntax highlight, which brings
some more colours to Eshell.
#+begin_src emacs-lisp
(use-package eshell-syntax-highlighting
  :after (esh-mode eshell)
  :defer t
  :straight (:build t)
  :config
  (eshell-syntax-highlighting-global-mode +1))
#+end_src

Powerline prompts are nice, git-aware prompts are even better!
~eshell-git-prompt~ is nice, but I prefer to write my own package for
that.
#+begin_src emacs-lisp
(use-package powerline-eshell
  :if (string= (string-trim (shell-command-to-string "uname -n")) "leon")
  :load-path "~/fromGIT/emacs-packages/powerline-eshell.el/"
  :after eshell)
#+end_src

** To be tested
Some packages I would like to test first
*** engine-mode

#+begin_src emacs-lisp
(use-package engine-mode
  :straight
  :config
  (defengine google "https://www.google.com/search?q=%s"
             :keybinding "/")
  (engine-mode 1))
#+end_src
*** google-this

#+begin_src emacs-lisp
(use-package google-this
  :straight t
  :bind-keymap ("C-c /" . google-this-mode-submap)
  :bind* ("M-SPC" . google-this-search)
  :bind (:map google-this-mode-map
              ("/" . google-this-search)))
#+end_src
*** isearch

Mostly from https://github.com/alexpeits/emacs.d

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :bind (("C-M-r" . isearch-backward-other-window)
         ("C-M-s" . isearch-forward-other-window))
  :bind (:map isearch-mode-map
              ("C-l" . recenter)
              ("C-SPC" . my/isearch-mark-and-exit)
              ("<C-return>" . my/isearch-other-end)
              ("<M-backspace>" . my/isearch-abort-dwim)
              ("<C-backspace>" . my/isearch-abort-dwim))
  :init
  (setq search-whitespace-regexp ".*?"  ;; spaces match anything
        isearch-lax-whitespace t  ;; the default
        isearch-regex-lax-whitespace nil
        isearch-yank-on-move 'shift
        isearch-allow-scroll 'unlimited
        isearch-lazy-count t  ;; show match count and current match index
        lazy-count-prefix-format nil
        lazy-count-suffix-format " (%s/%s)")
  :config
  ;; prot
  (defun my/isearch-mark-and-exit ()
    (interactive)
    (push-mark isearch-other-end t 'activate)
    (setq deactivate-mark nil)
    (isearch-done))

  (defun my/isearch-other-end ()
    (interactive)
    (isearch-done)
    (when isearch-other-end
      (goto-char isearch-other-end)))

  (defun my/isearch-abort-dwim ()
    "Delete failed `isearch' input, single char, or cancel search.

This is a modified variant of `isearch-abort' that allows us to
perform the following, based on the specifics of the case: (i)
delete the entirety of a non-matching part, when present; (ii)
delete a single character, when possible; (iii) exit current
search if no character is present and go back to point where the
search started."
    (interactive)
    (if (eq (length isearch-string) 0)
        (isearch-cancel)
      (isearch-del-char)
      (while (or (not isearch-success) isearch-error)
        (isearch-pop-state)))
    (isearch-update))

  ;; https://www.reddit.com/r/emacs/comments/b7yjje/isearch_region_search/
  (defun my/isearch-region (&optional not-regexp no-recursive-edit)
    "If a region is active, make this the isearch default search pattern."
    (interactive "P\np")
    (when (use-region-p)
      (let ((search (buffer-substring-no-properties
                     (region-beginning)
                     (region-end))))
        (deactivate-mark)
        (isearch-yank-string search))))

  (advice-add 'isearch-forward :after 'my/isearch-region)
  (advice-add 'isearch-forward-regexp :after 'my/isearch-region)
  (advice-add 'isearch-backward :after 'my/isearch-region)
  (advice-add 'isearch-backward-regexp :after 'my/isearch-region)

  (with-eval-after-load 'evil
    (dolist (st '(normal visual))
      (evil-global-set-key st (kbd "gs") 'isearch-forward)
      (evil-global-set-key st (kbd "gr") 'isearch-backward))))
#+end_src

*** multi-term

#+begin_src emacs-lisp
(use-package multi-term
  :straight t
  :bind (("C-c t" . multi-term-next)
         ("C-c T" . multi-term))
  :custom
  (multi-term-program "tmux")
  (multi-term-program-switches "-CC")
  (multi-term-scroll-show-maximum-output t)
  (term-bind-key-alist
   '(("C-c C-c" . term-interrupt-subjob)
     ("C-b"     . my-term-send-raw-at-prompt)
     ("C-f"     . my-term-send-raw-at-prompt)
     ("C-a"     . my-term-send-raw-at-prompt)
     ("C-e"     . my-term-send-raw-at-prompt)
     ("C-p"     . previous-line)
     ("C-n"     . next-line)
     ("C-s"     . isearch-forward)
     ("C-r"     . isearch-backward)
     ("C-m"     . term-send-raw)
     ("M-f"     . term-send-forward-word)
     ("M-b"     . term-send-backward-word)
     ("M->"     . my-term-end-of-buffer)
     ("M-o"     . term-send-backspace)
     ("M-p"     . term-send-up)
     ("M-n"     . term-send-down)
     ("M-d"     . term-send-forward-kill-word)
     ("M-DEL"   . term-send-backward-kill-word)
     ("M-r"     . term-send-reverse-search-history)
     ("M-,"     . term-send-input)
     ("M-/"     . comint-dynamic-complete)
     ("C-y"     . term-paste)))
  :init
  (defun screen ()
    (interactive)
    (let ((term-buffer
           (let ((multi-term-program (executable-find "screen"))
                 (multi-term-program-switches "-DR"))
             (multi-term-get-buffer))))
      (set-buffer term-buffer)
      (multi-term-internal)
      (switch-to-buffer term-buffer)))

  :config
  (require 'term)

  (defalias 'my-term-send-raw-at-prompt 'term-send-raw)

  (defun my-term-end-of-buffer ()
    (interactive)
    (call-interactively #'end-of-buffer)
    (if (and (eobp) (bolp))
        (delete-char -1)))

  (defadvice term-process-pager (after term-process-rebind-keys activate)
    (define-key term-pager-break-map  "\177" 'term-pager-back-page)))
#+end_src

*** zoom

#+begin_src emacs-lisp
(use-package zoom
  :straight t
  :bind ("C-x +" . zoom)
  :custom
  (zoom-size 'size-callback)
  :preface
  (defun size-callback ()
    (cond ((> (frame-pixel-width) 1280) '(90 . 0.75))
          (t '(0.5 . 0.5)))))
#+end_src
*** COMMENT el-draw
#+begin_src emacs-lisp
(use-package el-easydraw
  :straight (el-easydraw :build t
                         :type git
                         :host github
                         :repo "misohena/el-easydraw"))
#+end_src

#+RESULTS:
: t
*** gif-screencast
#+begin_src emacs-lisp
(use-package gif-screencast
  :commands gif-screencast-mode
  :bind (:map gif-screencast-mode-map
              ("<f11>" . gif-screencast-toggle-pause)
              ("<f12>" . gif-screencast-stop))
  :config
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))))
#+end_src
*** TODO COMMENT kele                                                       :k8s:
Spritzy Kubernetes cluster management for Emacs
#+begin_src emacs-lisp
(use-package kele
  :straight t
  :config
  (kele-mode 1))
#+end_src
** Web
*** link-hint
#+begin_src emacs-lisp
(use-package link-hint
  :straight
  :bind (("M-o" . link-hint-open-link)
         ("C-c l o" . link-hint-open-link)
         ("C-c l c" . link-hint-copy-link)))
#+end_src

** Z - Disabled
*** COMMENT Email                                                    :ARCHIVE:
**** Basic configuration
As seen below, I use ~org-msg~ to compose my emails, which includes by
default my signature. Therefore, there is no need for Emacs itself to
know about it since I don’t want it to include it a second time after
~org-msg~ already did.
#+begin_src emacs-lisp
(setq message-signature nil
      mail-signature    nil)
#+end_src
**** Gnus
#+begin_src emacs-lisp
(use-package gnus
  :straight (:type built-in)
  :defer t
  :config
  (require 'gnus-topic)
  (setq gnus-select-method '(nnnil))
  (setq gnus-secondary-select-methods '((nntp "news.gwene.org")))

  (setq gnus-asynchronous t ;; async
        gnus-use-article-prefetch 15
        ;; article
        gnus-visible-headers (mapcar (lambda (str) (concat "^" str ":"))
                                     '("From" "To" "Cc" "Subject" "Newsgroup"
                                       "Date" "Followup-To" "Reply-To"
                                       "Organization" "X-Newsreader" "X-Mailer"))
        gnus-sorted-header-list gnus-visible-headers
        gnus-thread-sort-functions '(gnus-thread-sort-by-number
                                     gnus-thread-sort-by-subject
                                     (not gnus-thread-sort-by-date))
        ;; group
        gnus-level-subscribed 6
        gnus-level-unsubscribed 7
        gnus-level-zombie 8
        gnus-group-sort-function '((gnus-group-sort-by-unread)
                                   (gnus-group-sort-by-alphabet)
                                   (gnus-group-sort-by-rank))
        gnus-group-line-format "%M%p%P%5y:%B%(%g%)\n"
        gnus-group-mode-line-format "%%b"
        gnus-topic-display-empty-topics nil
        ;; summary
        gnus-auto-select-first nil
        gnus-summary-ignore-duplicates t
        gnus-suppress-duplicates t
        gnus-summary-to-prefix "To:"
        gnus-summary-line-format "%U%R %-18,18&user-date; %4L:%-25,25f %B%s\n"
        gnus-summary-mode-line-format "[%U] %p"
        gnus-sum-thread-tree-false-root ""
        gnus-sum-thread-tree-indent " "
        gnus-sum-thread-tree-single-indent ""
        gnus-sum-thread-tree-leaf-with-other "+->"
        gnus-sum-thread-tree-root ""
        gnus-sum-thread-tree-single-leaf "\\->"
        gnus-sum-thread-tree-vertical "|")

  (add-hook 'dired-mode-hook #'gnus-dired-mode)
  (add-hook 'gnus-group-mode-hook #'gnus-topic-mode)
  (add-hook 'gnus-select-group-hook #'gnus-group-set-timestamp)

  (dolist (mode '(gnus-group-mode-hook gnus-summary-mode-hook gnus-browse-mode-hook))
    (add-hook mode #'hl-line-mode))

  :general
  (phundrak/evil
    :keymaps 'gnus-summary-mode-map
    :packages 'gnus
    "«" #'gnus-summary-prev-article
    "»" #'gnus-summary-next-article)
  (phundrak/major-leader-key
    :keymaps 'gnus-summary-mode-map
    :packages 'gnus
    "d"  #'gnus-summary-delete-article
    "f"  #'gnus-summary-mail-forward
    "r"  '(:ignore t :wk "reply")
    "rr" #'gnus-summary-reply-with-original
    "rl" #'gnus-summary-reply-to-list-with-original
    "rw" #'gnus-summary-wide-reply-with-original
    "rW" #'gnus-summary-very-wide-reply-with-original)
  (phundrak/evil
    :keymaps 'gnus-group-mode-map
    :packages 'gnus
    "«" #'gnus-group-prev-group
    "»" #'gnus-group-next-group)
  (phundrak/major-leader-key
    :keymaps '(gnus-group-mode-map)
    :packages 'gnus
    "SPC" #'gnus-topic-read-group
    "c"  '(gnus-topic-catchup-articles :which-key "catchup")
    "f"  '(gnus-fetch-group :which-key "fetch")
    "j"  '(:ignore t :which-key "jump")
    "jg" #'gnus-group-jump-to-group
    "jt" #'gnus-topic-jump-to-topic
    "L"  #'gnus-group-list-all-groups
    "n"  #'gnus-group-news
    "t"  '(gnus-group-topic-map :which-key "topics")
    "u"  #'gnus-group-unsubscribe))
#+end_src

**** Mu4e
Mu4e is a very eye-pleasing email client for Emacs, built around ~mu~
and which works well with ~mbsync~ (found in Arch’s ~isync~ package). For
me, the main advantage of mu4e is it has a modern interface for
emailing, and quite straightforward. I tried a couple of other email
clients for Emacs, and I even was for some time a Gnus user, but in
the end, mu4e really works best for me. Below you’ll find my
configuration for the ~mu4e~ package itself.
#+begin_src emacs-lisp
(use-package mu4e
  :after all-the-icons
  :straight (:build t)
  :commands mu4e mu4e-compose-new
  :init
  (defun mu4e--main-action-str (name func)
    "This seems to be needed until evil-collection supports the latest
  version of mu4e."
    "mu4e-main-action")

  (require 'mu4e)
  (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)

  <<mu4e-ical-setup>>
  <<mu4e-ical-init-config>>

  (csetq mu4e-completing-read-function 'completing-read
         mu4e-use-fancy-chars          t
         message-kill-buffer-on-exit   t
         mu4e-org-support              nil)
  (let ((dir (concat (getenv "HOME") "/Downloads/mu4e")))
    (when (file-directory-p dir)
      (csetq mu4e-attachment-dir dir)))
  (defmacro mu4e-view-mode--prepare ()
    `(lambda () (visual-line-mode 1)))
  :gfhook ('mu4e-view-mode-hook (mu4e-view-mode--prepare))
  :general
  (phundrak/evil
    :keymaps 'mu4e-main-mode-map
    :packages 'mu4e
    "U" #'mu4e-update-index)
  :config
  (require 'mu4e-view)
  (with-eval-after-load 'mm-decode
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text-richtext"))

  (add-hook 'mu4e-view-mode-hook (lambda () (setq truncate-lines nil)))
  (add-hook 'mu4e-headers-mode-hook (lambda () (setq truncate-lines t)))

  <<mu4e-ical-config>>
  <<mu4e-keybindings-undef>>
  <<mu4e-keybindings-view>>
  <<mu4e-keybindings-view-no-prefix>>
  <<mu4e-keybindings-header>>
  <<mu4e-keybindings-header-no-leader>>
  <<mu4e-keybindings-message>>

  <<mu4e-mail-service>>
  <<mu4e-mail-on-machine>>
  <<mu4e-no-signature>>
  <<mu4e-bookmarks>>
  <<mu4e-maildirs>>

  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (require 'gnus-dired)
  (setq gnus-dired-mail-mode 'mu4e-user-agent)

  (add-hook 'mu4e-compose-mode-hook (lambda () (use-hard-newlines t 'guess)))
  (add-hook 'mu4e-compose-mode-hook 'mml-secure-message-sign-pgpmime)

  (setq mu4e-change-filenames-when-moving t
        mu4e-update-interval              60
        mu4e-compose-format-flowed        t
        mu4e-view-show-addresses          t
        mu4e-sent-messages-behaviour      'sent
        mu4e-hide-index-messages          t
        mu4e-view-show-images             t                     ; try to show images
        mu4e-view-image-max-width         600
        message-send-mail-function        #'smtpmail-send-it    ; how to send an email
        smtpmail-stream-type              'starttls
        message-kill-buffer-on-exit       t                     ; close after sending
        mu4e-context-policy               'pick-first           ; start with first (default) context
        mu4e-compose-context-policy       'ask-if-none          ; compose with current context, or ask
        mu4e-completing-read-function     #'ivy-completing-read ; use ivy
        mu4e-confirm-quit                 t                     ; no need to ask
        mu4e-header-fields                '((:account    . 12)
                                            (:human-date . 12)
                                            (:flags      . 4)
                                            (:from       . 25)
                                            (:subject)))

  ;; set mail user agent
  (setq mail-user-agent 'mu4e-user-agent)

  <<mu4e-fancy-marks>>
  <<mu4e-vertical-split>>
  <<mu4e-headers-mode>>

  (defun mu4e-action-open-as-pdf (msg)
    "Export and open MSG as pdf."
    (let* ((date    (mu4e-message-field msg :date))
           (infile  (mu4e~write-body-to-html msg))
           (outfile (format-time-string "/tmp/%Y-%m-%d-%H-%M-%S.pdf" date)))
      (with-temp-buffer
        (shell-command
         (format "wkhtmltopdf %s %s" infile outfile) t))
      (find-file outfile))))
#+end_src

Quick sidenote: on Arch Linux, you’ll need to install either ~mu~ or
~mu-git~ from the AUR in order to use mu4e. I also have a ~.desktop~ file
to make it possible to open mu4e directly from my program picker. It
uses the shell script ~emacsmail~ I’ve written [[file:bin.org::#Emacsmail-afffb7cd][here]].
#+header: :mkdirp yes
#+begin_src conf-desktop :tangle ~/.local/share/applications/mu4e.desktop
[Desktop Entry]
Name=Mu4e
GenericName=Mu4e
Comment=Maildir Utils for Emacs
MimeType=x-scheme-handler/mailto;
Exec=/home/phundrak/.local/bin/emacsmail %U
Icon=emacs
Type=Application
Terminal=false
Categories=Network;Email;TextEditor
StartupWMClass=Gnus
Keywords=Text;Editor;
#+end_src

***** Basic configuration
First, let’s inform Emacs how it can send emails, using which service
and how. In my case, I use my own mail server.
#+name: mu4e-mail-service
#+begin_src emacs-lisp :tangle no
(setq smtpmail-smtp-server       "mail.phundrak.com"
      smtpmail-smtp-service      587
      smtpmail-stream-type       'starttls
      message-send-mail-function 'smtpmail-send-it)
#+end_src

We also need to inform it on where my emails are stored on my machine,
and how to retrieve them.
#+name: mu4e-mail-on-machine
#+begin_src emacs-lisp :tangle no
(setq mu4e-get-mail-command "mbsync -a"
      mu4e-root-maildir     "~/Mail"
      mu4e-trash-folder     "/Trash"
      mu4e-refile-folder    "/Archive"
      mu4e-sent-folder      "/Sent"
      mu4e-drafts-folder    "/Drafts")
#+end_src

In the same vein of [[*Basic configuration][this bit of configuration]], I do not want mu4e to
insert my mail signature, ~org-msg~ already does that.
#+name: mu4e-no-signature
#+begin_src emacs-lisp :tangle no
(setq mu4e-compose-signature nil)
#+end_src

***** Bookmarks
In mu4e, the main focus isn’t really mail directories such as your
inbox, your sent messages and such, but instead you manipulate
bookmarks which will show you emails depending on tags. This mean you
can create some pretty customized bookmarks that go way beyound your
simple inbox, outbox and all. Actually, four of my bookmarks have a
couple of filtering:
- anything in my inbox linked to my university
- the [[https://emacs-doctor.com/lists/listinfo][emacs-doctor mailing list]] (French Emacs mailing list)
- emails related to my internship
- and my inbox for any mail not caught by any of these filters
And all of them will have the requirement not to display any trashed
email. Actually, all of my bookmarks will have this requirement,
except for the bookmark dedicated to them as well as my sent emails.
I’ll add these latter requirements later.

Here are the requirements for my university bookmark. The regex
matches any email address which contains either ~up8.edu~ or
~univ-paris8~, which can be found in email addresses from the University
Paris 8 (my university).

#+name: mu4e-bookmarks-from-copy-to-gen
#+begin_src emacs-lisp :tangle no :exports none :var regex="test"
(mapconcat (lambda (x) (concat x ":" regex))
           '("f" "c" "t")
           " OR ")
#+end_src

#+name: mu4e-bookmarks-mailing-lists
#+header: :tangle no :exports none
#+begin_src emacs-lisp :var lists=mu4e-emacs-mailing-lists
(mapconcat (lambda (list)
             (let ((address (string-replace (regexp-quote "~")
                                            ""
                                            (if (stringp list) list (car list)))))
               (mapconcat (lambda (flag)
                            (concat flag ":" address))
                          '("list" "t" "f" "contact")
                          " OR ")))
           lists
           " OR ")
#+end_src

#+name: mu4e-bookmarks-filter-uni
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*up8\\.edu|.*univ-paris8.*/"))
  (concat
   <<mu4e-bookmarks-from-copy-to-gen>>
   " OR maildir:/Univ/Inbox OR maildir:/Univ/Junk"))
#+end_src

#+RESULTS[083992a66ea6339d3a55773108e520a6024102c5]: mu4e-bookmarks-filter-uni
: f:/.*up8\.edu|.*univ-paris8.*/ OR c:/.*up8\.edu|.*univ-paris8.*/ OR t:/.*up8\.edu|.*univ-paris8.*/ OR maildir:/Univ/Inbox OR maildir:/Univ/Junk

Next I need an inbox dedicated to the association I’m part of.
#+name: mu4e-bookmarks-filter-asso
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*supran\\.fr/"))
  <<mu4e-bookmarks-from-copy-to-gen>>)
#+end_src

#+RESULTS[e04566a9d56624e063b3dd4e2c639e87cf9683aa]: mu4e-bookmarks-filter-asso
: f:/.*supran\.fr/ OR c:/.*supran\.fr/ OR t:/.*supran\.fr/

As for the Emacs-doctor list, I need to match both the current, modern
mailing list address but also its old address. The same applies for
the emacs-devel mailing list as well as GitHub emails related to my
package ~eshell-info-banner.el~. Here are the addresses to
match:

# Insert #Packages-Configuration-Emacs-built-ins-Eshell-Visual-configuratione7c2fl6184j0 equivalent in *see here*

#+name: mu4e-emacs-mailing-lists
- ~/ateliers.*emacs.*/~
- ~/emacs-.*@gnu.org/~
- ~/.*eshell-info-banner.*/~
- ~/.*emacsfr.*/~

#+name: mu4e-bookmarks-filter-emacs-list
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
"<<mu4e-bookmarks-mailing-lists(lists=mu4e-emacs-mailing-lists)>>"
#+end_src

#+RESULTS[88c964fba64459a050055bc5614bbd65f8740bfb]: mu4e-bookmarks-filter-emacs-list
: list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/

Another bookmark I wish to have is one dedicated to emails related to
more general development topics, including issues and PRs from GitHub.
#+name: mu4e-github-mailing-lists
- ~/.*\\.github\\.com/~
- ~/.*\\.gitlab\\.com/~
- ~stumpwm-devel@nongnu.org~
- ~/.*sr\\.ht/~

#+name: mu4e-bookmarks-filter-github-list
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
;; "<<mu4e-bookmarks-mailing-lists(lists=mu4e-github-mailing-lists)>> AND NOT ()"
(string-join '("<<mu4e-bookmarks-mailing-lists(lists=mu4e-github-mailing-lists)>>"
               "AND NOT ("
               <<mu4e-bookmarks-filter-emacs-list>>
               ")")
             " ")
#+end_src

#+RESULTS[673f76e7a682ed64f98dbe6d4a06810436ba6799]: mu4e-bookmarks-filter-github-list
: list:/.*\.github\.com/ OR t:/.*\.github\.com/ OR f:/.*\.github\.com/ OR contact:/.*\.github\.com/ OR list:/.*\.gitlab\.com/ OR t:/.*\.gitlab\.com/ OR f:/.*\.gitlab\.com/ OR contact:/.*\.gitlab\.com/ OR list:stumpwm-devel@nongnu.org OR t:stumpwm-devel@nongnu.org OR f:stumpwm-devel@nongnu.org OR contact:stumpwm-devel@nongnu.org OR list:/.*sr\.ht/ OR t:/.*sr\.ht/ OR f:/.*sr\.ht/ OR contact:/.*sr\.ht/ AND NOT ( list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/ )

When it comes to my internship, all emails will contain an address containing ~aubay.com~ (that’s where my internship takes place).
- ~/.*aubay.com/~

#+name: mu4e-bookmarks-filter-aubay
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*aubay\\.com/"))
  <<mu4e-bookmarks-from-copy-to-gen>>)
#+end_src

#+RESULTS[06105e10cf2addb8e11360ff2629023fad946ddf]: mu4e-bookmarks-filter-aubay
: f:/.*aubay\.com/ OR c:/.*aubay\.com/ OR t:/.*aubay\.com/

As I said earlier, something that will often come back in my bookmarks
is the emails must not be trashed to appear. I want also to display
junk emails, so I end up with the following rule:
#+name: mu4e-bookmarks-default-filter
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(mapconcat #'identity
           `("NOT flag:trashed"
             ,(format "(%s)" (mapconcat (lambda (maildir) (concat "maildir:" maildir))
                                        '("/Inbox" "/Junk")
                                        " OR ")))
            " AND ")
#+end_src

#+RESULTS[f3f96c07b8341c1b7b3d02688aa6faa2ceeca16f]: mu4e-bookmarks-default-filter
: NOT flag:trashed AND (maildir:/Inbox OR maildir:/Junk)

And for the last string-generating code, let’s describe my main inbox:
#+name: mu4e-bookmarks-inbox-filters
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(mapconcat #'identity
           (cons "<<mu4e-bookmarks-default-filter()>>"
                 `(,(format "(%s)"
                            <<mu4e-bookmarks-filter-aubay>>)
                   ,(format "(%s)" "<<mu4e-bookmarks-filter-asso()>>")
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-emacs-list>>)
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-github-list>>)
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-uni>>)))
           " AND NOT ")
#+end_src

#+RESULTS[94290b02a0da24cffeba43e1d47395e801bc0158]: mu4e-bookmarks-inbox-filters
: NOT flag:trashed AND (maildir:/Inbox OR maildir:/Junk) AND NOT (f:/.*aubay\.com/ OR c:/.*aubay\.com/ OR t:/.*aubay\.com/) AND NOT (f:/.*supran.fr/ OR c:/.*supran.fr/ OR t:/.*supran.fr/) AND NOT (list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/) AND NOT (list:/.*\.github\.com/ OR t:/.*\.github\.com/ OR f:/.*\.github\.com/ OR contact:/.*\.github\.com/ OR list:/.*\.gitlab\.com/ OR t:/.*\.gitlab\.com/ OR f:/.*\.gitlab\.com/ OR contact:/.*\.gitlab\.com/ OR list:stumpwm-devel@nongnu.org OR t:stumpwm-devel@nongnu.org OR f:stumpwm-devel@nongnu.org OR contact:stumpwm-devel@nongnu.org OR list:/.*sr\.ht/ OR t:/.*sr\.ht/ OR f:/.*sr\.ht/ OR contact:/.*sr\.ht/ AND NOT ( list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/ )) AND NOT (f:/.*up8\.edu|.*univ-paris8.*/ OR c:/.*up8\.edu|.*univ-paris8.*/ OR t:/.*up8\.edu|.*univ-paris8.*/ OR maildir:/Univ/Inbox OR maildir:/Univ/Junk)

We can finally define our bookmarks! The code reads as follows:
#+name: mu4e-bookmarks
#+begin_src emacs-lisp :tangle no :cache yes :results none
(setq mu4e-bookmarks
      `((:name "Inbox"
         :key ?i
         :query ,(format "%s"
                         <<mu4e-bookmarks-inbox-filters>>))
        (:name "Internship"
         :key ?a
         :query ,(format "(%s) AND (%s)"
                     "<<mu4e-bookmarks-default-filter()>>"
                     <<mu4e-bookmarks-filter-aubay>>))
        (:name "University"
         :key ?u
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-uni()>>"))
        (:name "Dev"
         :key ?d
         :query ,(format "%s AND (%s)"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-github-list()>>"))
        (:name "Emacs"
         :key ?e
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         <<mu4e-bookmarks-filter-emacs-list>>))
        (:name "Supran"
         :key ?s
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-asso()>>"))
        (:name "Sent"       :key ?S :query "maildir:/Sent OR maildir:/Univ/Sent")
        (:name "All Unread" :key ?U :query "flag:unread AND NOT flag:trashed")
        (:name "Today"      :key ?t :query "date:today..now AND NOT flag:trashed")
        (:name "This Week"  :key ?w :query "date:7d..now    AND NOT flag:trashed")
        (:name "This Month" :key ?m :query "date:1m..now    AND NOT flag:trashed")
        (:name "This Year"  :key ?y :query "date:1y..now    AND NOT flag:trashed")))
#+end_src

***** Maildirs
Sometimes, bookmarks are a bit too restrictive when I want to search
for stuff. Simply jumping to a mail directory, or maildir, is more
than enough. In mu4e, with my current setup, I can jump to any maildir
with the shortcut ~Jo~ in normal-mode, and I just need to choose in a
list the maildir I want to jump to. But it can be faster.

With this piece of code, I can simply jump to my inbox maildir with
~Ji~, to my sent messages with ~Js~, and so on.
#+name: mu4e-maildirs
#+begin_src emacs-lisp :tangle no
(setq mu4e-maildir-shortcuts
      '((:maildir "/Inbox" :key ?i)
        (:maildir "/Sent" :key ?s)
        (:maildir "/Junk" :key ?j)
        (:maildir "/Trash" :key ?t)))
#+end_src

***** Dealing with spammers
I’m sure you have received at least one email recently from a sketchy
email address asking you something that might be completely unrelated
to what you do, or at least somewhat related. Fortunately, [[https://twitter.com/Boris/status/1360208504544444417][we have a
hero]]! Now, let me write a function that will insert their
pre-written text at point to avoid me going back to their Twitter
thread each time I want to shut spammers up.
#+begin_src emacs-lisp
(defun reply-to-bill ()
  (interactive)
  (insert "Please forward this email to bill@noprocurement.com,
and delete my email, as I’ll be changing jobs soon, and this
email address will no longer be active.

Bill Whiskoney is a senior partner at Nordic Procurement
Services, and he handles our budget and will help you further or
introduce you to someone who can."))
#+end_src

If you want the full story, make sure to read the whole thread, I
guarantee it, it’s worth your time! And in case the Twitter thread
disappear in the future, [[https://threader.app/thread/1360208504544444417][here is a backup]].

***** Getting Fancy
I’m not a huge fan of mu4e’s default icons marking my emails, so I’ll
redefine them as follows. Be aware the name of these icons are from
/faicon/ in the package ~all-the-icons~.
#+name: mu4e-fancy-marks-tbl
| Mark      | Flag | Icon        |
|-----------+------+-------------|
| draft     | D    | pencil      |
| flagged   | F    | flag        |
| new       | N    | rss         |
| passed    | P    | check       |
| replied   | R    | reply       |
| seen      | S    | eye         |
| unread    | u    | eye-slash   |
| trashed   | T    | trash       |
| attach    | a    | paperclip   |
| encrypted | x    | lock        |
| signed    | s    | certificate |

#+name: mu4e-fancy-marks-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=mu4e-fancy-marks-tbl
(mapconcat (lambda (line)
             (let ((mark (car line))
                   (flag (cadr line))
                   (icon (caddr line)))
               (format "mu4e-headers-%s-mark `(\"%s\" . ,(all-the-icons-faicon \"%s\" :height 0.8))"
                       mark
                       flag
                       icon)))
           table
           "\n")
#+end_src

#+RESULTS[c6ed5d4bec4c10339a7de52a70822af74d782e62]: mu4e-fancy-marks-gen
#+begin_example
mu4e-headers-draft-mark `("D" . ,(all-the-icons-faicon "pencil" :height 0.8))
mu4e-headers-flagged-mark `("F" . ,(all-the-icons-faicon "flag" :height 0.8))
mu4e-headers-new-mark `("N" . ,(all-the-icons-faicon "rss" :height 0.8))
mu4e-headers-passed-mark `("P" . ,(all-the-icons-faicon "check" :height 0.8))
mu4e-headers-replied-mark `("R" . ,(all-the-icons-faicon "reply" :height 0.8))
mu4e-headers-seen-mark `("S" . ,(all-the-icons-faicon "eye" :height 0.8))
mu4e-headers-unread-mark `("u" . ,(all-the-icons-faicon "eye-slash" :height 0.8))
mu4e-headers-trashed-mark `("T" . ,(all-the-icons-faicon "trash" :height 0.8))
mu4e-headers-attach-mark `("a" . ,(all-the-icons-faicon "paperclip" :height 0.8))
mu4e-headers-encrypted-mark `("x" . ,(all-the-icons-faicon "lock" :height 0.8))
mu4e-headers-signed-mark `("s" . ,(all-the-icons-faicon "certificate" :height 0.8))
#+end_example

Let’s enable them and set them:
#+name: mu4e-fancy-marks
#+begin_src emacs-lisp :tangle no
(setq mu4e-use-fancy-chars t
      <<mu4e-fancy-marks-gen()>>)
#+end_src

#+name: mu4e-vertical-split
#+begin_src emacs-lisp :tangle no
(defun my/set-mu4e-headers-width ()
  (let ((width    (window-body-width))
        (threshold (+ 120 80)))
    (setq mu4e-split-view (if (> width threshold)
                              'vertical
                            'horizontal))))

(setq mu4e-headers-visible-columns 120
      mu4e-headers-visible-lines   15)
(add-hook 'mu4e-headers-mode-hook #'my/set-mu4e-headers-width)
#+end_src

***** Headers mode
#+name: mu4e-headers-mode
#+begin_src emacs-lisp :tangle no
(add-hook 'mu4e-headers-mode-hook (lambda () (visual-line-mode -1)))
(add-hook 'mu4e-headers-mode-hook (lambda () (toggle-truncate-lines -1)))
#+end_src

***** Keybindings
By default, Evil has some pretty annoying keybindings for users of the
bépo layout: ~hjkl~ becomes ~ctsr~ for us. Let’s undefine some of these:
#+name: mu4e-keybindings-undef
#+begin_src emacs-lisp :tangle no
(phundrak/undefine
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  "S"   nil
  "r"   nil
  "c"   nil
  "gu"  nil)

(phundrak/undefine
  :keymaps '(mu4e-view-mode-map mu4e-headers-mode-map)
  :packages 'mu4e
  "s"   nil)
#+end_src

Now, let’s define some keybindings for mu4e’s view mode, that is when
we are viewing an email. All these keybindings will reside between the
major-mode specific leader key ~,~ and most of these keybindings can be
described with a simple function:
#+name: mu4e-keybindings-view-tbl
| Keybinding | Function                             | Description        |
|------------+--------------------------------------+--------------------|
| &          | mu4e-view-pipe                       |                    |
| .          | mu4e-headers-split-adjust-width/body | mu4e-headers width |
| a          | nil                                  | attachments        |
| a&         | mu4e-view-pipe-attachment            |                    |
| aa         | mu4e-view-attachment-action          |                    |
| ao         | mu4e-view-open-attachment            |                    |
| aO         | mu4e-view-open-attachment-with       |                    |
| c          | nil                                  | compose            |
| cc         | mu4e-compose-new                     |                    |
| ce         | mu4e-compose-edit                    |                    |
| cf         | mu4e-compose-forward                 |                    |
| cr         | mu4e-compose-reply                   |                    |
| cR         | mu4e-compose-resend                  |                    |
| l          | mu4e-show-log                        |                    |
| m          | nil                                  | mark               |
| md         | mu4e-view-mark-for-trash             |                    |
| mD         | mu4e-view-mark-for-delete            |                    |
| mm         | mu4e-view-mark-for-move              |                    |
| mr         | mu4e-view-mark-for-refile            |                    |
| mR         | mu4e-view-mark-for-read              |                    |
| mu         | mu4e-view-mark-for-unread            |                    |
| mU         | mu4e-view-mark-for-unmark            |                    |
| t          | mu4e-view-mark-thread                | mark thread        |
| T          | nil                                  | toggle             |
| Tc         | mu4e-view-toggle-hide-cited          |                    |
| Th         | mu4e-view-toggle-html                |                    |
| n          | mu4e-view-headers-next               |                    |
| N          | mu4e-view-headers-next-unread        |                    |
| p          | mu4e-view-headers-prev               |                    |
| P          | mu4e-view-headers-prev-unread        |                    |
| u          | nil                                  | url                |
| uf         | mu4e-view-go-to-url                  |                    |
| uF         | mu4e-view-fetch-url                  |                    |

#+name: mu4e-keybindings-view
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-view-tbl)>>)
#+end_src

Two other keybinds are added without a prefix, just for the sake of
convenience.
#+name: mu4e-keybindings-view-no-prefix
#+begin_src emacs-lisp
(phundrak/evil
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  "«" #'mu4e-view-headers-prev
  "»" #'mu4e-view-headers-next)
#+end_src

I’ll also declare two keybinds for mu4e’s headers mode.
#+name: mu4e-keybindings-header
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'mu4e-headers-mode-map
  :packages 'mu4e
  "t" '(mu4e-view-mark-thread :which-key "mark thread")
  "s" 'swiper)
#+end_src

I will also redefine without a leader key ~ctsr~ in order to be able to
move freely (remember, bépo layout for me).
#+name: mu4e-keybindings-header-no-leader-table
| Key | Function                  | Comment |
|-----+---------------------------+---------|
| c   | evil-backward-char        |         |
| t   | evil-next-visual-line     |         |
| s   | evil-previous-visual-line |         |
| r   | evil-forward-char         |         |

#+name: mu4e-keybindings-header-no-leader
#+begin_src emacs-lisp :tangle no
(phundrak/evil
  :keymaps 'mu4e-headers-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-header-no-leader-table)>>)
#+end_src

Finally, let’s declare a couple of keybindings for when we are
composing a message. This time, all my keybindings are prefixed with
the major-mode leader and call a simple function.
#+name: mu4e-keybindings-message-tbl
| Key | Function              | Description |
|-----+-----------------------+-------------|
| ,   | message-send-and-exit |             |
| c   | message-send-and-exit |             |
| a   | message-kill-buffer   |             |
| k   | message-kill-buffer   |             |
| s   | message-dont-send     |             |
| f   | mml-attach-file       |             |

#+name: mu4e-keybindings-message
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'message-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-message-tbl)>>)
#+end_src

**** Composing messages
Org mime is cool and all, you can write some org-mode and then export
it to either a plain-text or an HTML email. BUT, have you considered
skipping the export part and write your emails directly in org-mode?
#+begin_src emacs-lisp
(use-package org-msg
  :after (mu4e)
  :straight (:build t)
  :hook ((mu4e-compose-pre . org-msg-mode))
  :custom-face
  (mu4e-replied-face ((t (:weight normal :foreground "#b48ead"))))
  :config
  (defun my/org-msg-signature-convert (orig-fun &rest args)
    "Tweak my signature when replying as plain/text only."
    (let ((res (apply orig-fun args)))
      (when (equal (cadr args) '(text))
        (setf (alist-get 'signature res)
              (replace-regexp-in-string "\n+" "\n" org-msg-signature)))
      res))
  (advice-add 'org-msg-composition-parameters
              :around 'my/org-msg-signature-convert)
  (add-hook 'mu4e-headers-mode (lambda () (toggle-truncate-lines -1)))
  (setq org-msg-startup              "inlineimages"
        org-msg-default-alternatives '((new           . (text))
                                       (reply-to-html . (text))
                                       (reply-to-text . (text)))
        org-msg-greeting-name-limit  3
        org-msg-signature            (format "\n--\n#+begin_signature\n%s\n#+end_signature"
                                             (with-temp-buffer
                                               (insert-file-contents mail-signature-file)
                                               (while (re-search-forward "\n" nil t)
                                                 (replace-match "\n\n"))
                                               (buffer-string))))
  :general
  (phundrak/major-leader-key
    :keymaps 'org-msg-edit-mode-map
    :packages 'org-msg
    <<general-keybindings-gen(table=org-msg-edit-mode-keybinds)>>))
#+end_src

The keybinds are relatively simple ~org-msg-edit-mode~:
#+name: org-msg-edit-mode-keybinds
| Key | Function              | Description |
|-----+-----------------------+-------------|
| ,   | message-send-and-exit |             |
| c   | message-send-and-exit |             |
| a   | message-kill-buffer   |             |
| k   | message-kill-buffer   |             |
| s   | message-dont-send     |             |
| f   | org-msg-attach        |             |

**** Email alerts
There is also a package for mu4e which generates desktop notifications
when new emails are received. By default, I want to be notified by all
messages in my inbox and junk folder. Also, I’ll use Emacs’ default
notification system, and I’ll activate the modeline notification.
#+begin_src emacs-lisp
(use-package mu4e-alert
  :straight (:build t)
  :after mu4e
  :defer t
  :init
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
  (mu4e-alert-set-default-style 'notifications)
  :config
  (setq mu4e-alert-interesting-mail-query "flag:unread"))
#+end_src
*** COMMENT Wttr.in
#+begin_src emacs-lisp
(use-package wttrin
  :defer t
  :straight (wttrin :build t
                    :local-repo "~/fromGIT/emacs-packages/emacs-wttrin"
                    :type git)
                    ;; :host github
                    ;; :repo "Phundrak/emacs-wttrin"
  :config
  (setq wttrin-default-cities '("Aubervilliers" "Paris" "Lyon" "Nonières" "Saint Agrève")
        wttrin-use-metric t))
#+end_src

**** TODO Derive a major mode for wttrin                           :noexport:
To handle keybindings correctly, a major mode for wttrin could be
derived from ~fundamental-mode~ and get an associated keymap.
*** COMMENT Screenshot
~screenshot.el~ is a nice utility package made by TEC. It allows the
user to take a screenshot of a specific area of a buffer and make it
look nice.
#+begin_src emacs-lisp
(use-package screenshot
  :defer t
  :straight (screenshot :build t
                        :type git
                        :host github
                        :repo "tecosaur/screenshot")
  :config (load-file (locate-library "screenshot.el"))
  :general
  (phundrak/leader-key
    :infix "a"
    :packages '(screenshot)
    "S" #'screenshot))
#+end_src
*** COMMENT LaTeX
#+begin_src emacs-lisp :noweb yes
(use-package auctex
  :defer t
  :straight (:build t)
  :hook (tex-mode . lsp-deferred)
  :hook (latex-mode . lsp-deferred)
  :init
  (setq TeX-command-default   (if (executable-find "latexmk") "LatexMk" "LaTeX")
        TeX-engine            (if (executable-find "xetex")   'xetex    'default)
        TeX-auto-save                     t
        TeX-parse-self                    t
        TeX-syntactic-comment             t
        TeX-auto-local                    ".auctex-auto"
        TeX-style-local                   ".auctex-style"
        TeX-source-correlate-mode         t
        TeX-source-correlate-method       'synctex
        TeX-source-correlate-start-server nil
        TeX-electric-sub-and-superscript  t
        TeX-fill-break-at-separators      nil
        TeX-save-query                    t)
  :config
  <<latex-fontification>>
  (setq TeX-master t)
  (setcar (cdr (assoc "Check" TeX-command-list)) "chktex -v6 -H %s")
  (add-hook 'TeX-mode-hook (lambda ()
                             (setq ispell-parser          'tex
                                   fill-nobreak-predicate (cons #'texmathp fill-nobreak-predicate))))
  (add-hook 'TeX-mode-hook #'visual-line-mode)
  (add-hook 'TeX-update-style-hook #'rainbow-delimiters-mode)
  :general
  (phundrak/major-leader-key
    :packages 'lsp-mode
    :keymaps  '(latex-mode-map LaTeX-mode-map)
   "l"  '(:keymap lsp-command-map :which-key "lsp"))
  (phundrak/major-leader-key
    :packages 'auctex
    :keymaps  '(latex-mode-map LaTeX-mode-map)
    "v" '(TeX-view            :which-key "View")
    "c" '(TeX-command-run-all :which-key "Compile")
    "m" '(TeX-command-master  :which-key "Run a command")))
#+end_src

From Doom Emacs’ configuration:
#+name: latex-fontification
#+begin_src emacs-lisp :tangle no
(setq font-latex-match-reference-keywords
      '(;; BibLaTeX.
        ("printbibliography" "[{") ("addbibresource" "[{")
        ;; Standard commands.
        ("cite" "[{")       ("citep" "[{")
        ("citet" "[{")      ("Cite" "[{")
        ("parencite" "[{")  ("Parencite" "[{")
        ("footcite" "[{")   ("footcitetext" "[{")
        ;; Style-specific commands.
        ("textcite" "[{")   ("Textcite" "[{")
        ("smartcite" "[{")  ("Smartcite" "[{")
        ("cite*" "[{")      ("parencite*" "[{")
        ("supercite" "[{")
        ;; Qualified citation lists.
        ("cites" "[{")      ("Cites" "[{")
        ("parencites" "[{") ("Parencites" "[{")
        ("footcites" "[{")  ("footcitetexts" "[{")
        ("smartcites" "[{") ("Smartcites" "[{")
        ("textcites" "[{")  ("Textcites" "[{")
        ("supercites" "[{")
        ;; Style-independent commands.
        ("autocite" "[{")   ("Autocite" "[{")
        ("autocite*" "[{")  ("Autocite*" "[{")
        ("autocites" "[{")  ("Autocites" "[{")
        ;; Text commands.
        ("citeauthor" "[{") ("Citeauthor" "[{")
        ("citetitle" "[{")  ("citetitle*" "[{")
        ("citeyear" "[{")   ("citedate" "[{")
        ("citeurl" "[{")
        ;; Special commands.
        ("fullcite" "[{")
        ;; Cleveref.
        ("cref" "{")          ("Cref" "{")
        ("cpageref" "{")      ("Cpageref" "{")
        ("cpagerefrange" "{") ("Cpagerefrange" "{")
        ("crefrange" "{")     ("Crefrange" "{")
        ("labelcref" "{")))

(setq font-latex-match-textual-keywords
      '(;; BibLaTeX brackets.
        ("parentext" "{") ("brackettext" "{")
        ("hybridblockquote" "[{")
        ;; Auxiliary commands.
        ("textelp" "{")   ("textelp*" "{")
        ("textins" "{")   ("textins*" "{")
        ;; Subcaption.
        ("subcaption" "[{")))

(setq font-latex-match-variable-keywords
      '(;; Amsmath.
        ("numberwithin" "{")
        ;; Enumitem.
        ("setlist" "[{")     ("setlist*" "[{")
        ("newlist" "{")      ("renewlist" "{")
        ("setlistdepth" "{") ("restartlist" "{")
        ("crefname" "{")))
#+end_src

#+begin_src emacs-lisp
(use-package tex-mode
  :defer t
  :straight (:type built-in)
  :config
  (setq LaTeX-section-hook '(LaTeX-section-heading
                             LaTeX-section-title
                             LaTeX-section-toc
                             LaTeX-section-section
                             LaTeX-section-label)
        LaTeX-fill-break-at-separators nil
        LaTeX-item-indent              0))
#+end_src

#+begin_src emacs-lisp
(use-package preview
  :defer t
  :straight (:type built-in)
  :config
  (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
  (setq-default preview-scale 1.4
                preview-scale-function
                (lambda () (* (/ 10.0 (preview-document-pt)) preview-scale)))
  (setq preview-auto-cache-preamble nil)
  (phundrak/major-leader-key
    :packages 'auctex
    :keymaps '(latex-mode-map LaTeX-mode-map)
    "p" #'preview-at-point
    "P" #'preview-clearout-at-point))
#+end_src

#+begin_src emacs-lisp
(use-package cdlatex
  :defer t
  :after auctex
  :straight (:build t)
  :hook (LaTeX-mode . cdlatex-mode)
  :hook (org-mode   . org-cdlatex-mode)
  :config
  (setq cdlatex-use-dollar-to-ensure-math nil)
  :general
  (phundrak/major-leader-key
    :packages 'cdlatex
    :keymaps 'cdlatex-mode-map
    "$" nil
    "(" nil
    "{" nil
    "[" nil
    "|" nil
    "<" nil
    "^" nil
    "_" nil
    [(control return)] nil))
#+end_src

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :defer t
  :after auctex
  :straight (:build t)
  :hook (LaTeX-mode . adaptative-wrap-prefix-mode)
  :init (setq-default adaptative-wrap-extra-indent 0))
#+end_src

#+begin_src emacs-lisp
(use-package auctex-latexmk
  :after auctex
  :defer t
  :straight (:build t)
  :init
  (setq auctex-latexmk-inherit-TeX-PDF-mode t)
  (add-hook 'LaTeX-mode (lambda () (setq TeX-command-default "LatexMk")))
  :config
  (auctex-latexmk-setup))
#+end_src

#+begin_src emacs-lisp
(use-package company-auctex
  :defer t
  :after (company auctex)
  :straight (:build t)
  :config
  (company-auctex-init))
#+end_src

#+begin_src emacs-lisp
(use-package company-math
  :defer t
  :straight (:build t)
  :after (company auctex)
  :config
  (defun my-latex-mode-setup ()
    (setq-local company-backends
                (append '((company-math-symbols-latex company-latex-commands))
                        company-backends)))
  (add-hook 'TeX-mode-hook #'my-latex-mode-setup))
#+end_src
*** COMMENT Docker
Docker is an awesome tool for reproducible development environments.
Due to this, I absolutely need a mode for editing Dockerfiles.
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer t
  :straight (:build t)
  :hook (dockerfile-mode . lsp-deferred)
  :init
  (put 'docker-image-name 'safe-local-variable #'stringp)
  :mode "Dockerfile\\'"
  :general
  (phundrak/major-leader-key
   :keymaps 'general-mode-map
   :packages 'lsp-mode
   "l"  '(:keymap lsp-command-map :which-key "lsp")))
#+end_src

The ~docker~ package also provides interactivity with Docker and
docker-compose from Emacs.
#+begin_src emacs-lisp
(use-package docker
  :defer t
  :straight (:build t))
#+end_src
*** COMMENT Nov
Nov is a major-mode for reading EPUB files within Emacs. Since I have
it, I don’t need any other Epub reader on my computer! Plus this one
is customizable and programmable, why would I use any other EPUB
reader?
#+begin_src emacs-lisp
(use-package nov
  :straight (:build t)
  :defer t
  :mode ("\\.epub\\'" . nov-mode)
  :general
  (phundrak/evil
    :keymaps 'nov-mode-map
    :packages 'nov
    "c"   #'nov-previous-document
    "t"   #'nov-scroll-up
    "C-d" #'nov-scroll-up
    "s"   #'nov-scroll-down
    "C-u" #'nov-scroll-down
    "r"   #'nov-next-document
    "gm"  #'nov-display-metadata
    "gn"  #'nov-next-document
    "gp"  #'nov-previous-document
    "gr"  #'nov-render-document
    "gt"  #'nov-goto-toc
    "gv"  #'nov-view-source
    "gV"  #'nov-view-content-source)
  :config
  (setq nov-text-width 95))
#+end_src
