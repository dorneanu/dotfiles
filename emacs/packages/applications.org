#+title: Emacs — Packages — Applications
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/applications.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Applications

#+name: general-keybindings-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=elfeed-keybinds-show-mode prefix=""
(mapconcat (lambda (line)
             (let* ((key      (nth 0 line))
                    (function (nth 1 line))
                    (comment  (or (nth 2 line) ""))
                    (package  (or (nth 3 line) "")))
               (format "\"%s%s\" %s"
                       prefix
                       key
                       (if (string= "" comment)
                           (if (member function '("" "nil")) "nil" (concat "#'" function))
                         (format "'(%s :wk %s%s)"
                                 (if (member function '("" "nil")) ":ignore t" function)
                                 (if (member function '("none" "nil")) "t" (concat "\"" comment "\""))
                                 (if (string-blank-p package) "" (concat ":package " package)))))))
           table
           "\n")
#+end_src

#+begin_src emacs-lisp
(use-package transient
  :straight (:build t)
  :defer t)
#+end_src

** COMMENT Bitwarden
This package is still a very much work in progress one I’m developing
in order to interact with Bitwarden in Emacs with the help of the
[[https://github.com/bitwarden/cli][Bitwarden CLI]]. Use at your own risks.
#+begin_src emacs-lisp
(use-package bitwarden
  :defer t
  :straight (bitwarden :build t
                       :type git
                       :host nil
                       :repo "https://labs.phundrak.com/phundrak/bitwarden.el"))
#+end_src

** Calendar
I am using the built-in calendar of Emacs, but as I use Evil and the
bépo layout, many keybindings available by default or through
=evil-collection= don’t fit my needs perfectly.
#+begin_src emacs-lisp
(use-package calendar
  :straight (:type built-in)
  :defer t
  :general
  (:keymaps 'calendar-mode-map
   "»"     #'calendar-scroll-left
   "«"     #'calendar-scroll-right
   "M-»"   #'calendar-scroll-left-three-months
   "M-«"   #'calendar-scroll-right-three-months
   "M-r"   #'calendar-scroll-left
   "M-c"   #'calendar-scroll-right
   "M-S-r" #'calendar-scroll-left-three-months
   "M-S-c" #'calendar-scroll-right-three-months
   "q"     #'calendar-exit)
  (phundrak/major-leader-key
    :keymaps 'calendar-mode-map
    "="   #'calendar-count-days-region
    "^"   '(:ignore t :wk "beginning")
    "^ w" #'calendar-beginning-of-week
    "^ m" #'calendar-beginning-of-month
    "^ y" #'calendar-beginning-of-year
    "$"   '(:ignore t :wk "end")
    "$w"  #'calendar-end-of-week
    "$m"  #'calendar-end-of-month
    "$y"  #'calendar-end-of-year
    "a"   '(:ignore t :wk "appointment")
    "aa"  #'appt-add
    "ad"  #'appt-delete
    "A"   #'org-calendar-goto-agenda
    "b"   '(:ignore t :wk "go back")
    "bd"  '(calendar-backward-day :wk "a day")
    "bw"  '(calendar-backward-week :wk "a week")
    "bm"  '(calendar-backward-month :wk "a month")
    "by"  '(calendar-backward-year :wk "a year")
    "d"   '(:ignore t :wk "diary")
    "da"  '(diary-show-all-entries :wk "all entries")
    "dd"  '(diary-view-entries :wk "entries")
    "dm"  #'diary-mark-entries
    "do"  #'diary-view-other-diary-entries
    "di"  '(:ignore t :wk "insert")
    "die" '(diary-insert-entry :wk "entry")
    "die" '(diary-insert-block-entry :wk "block entry")
    "diw" '(diary-insert-weekly-entry :wk "weekly")
    "dim" '(diary-insert-monthly-entry :wk "monthly")
    "diy" '(diary-insert-yearly-entry :wk "yearly")
    "F"   '(:ignore t :wk "files")
    "Fa"  #'org-calendar-goto-agenda
    "f"   '(:ignore t :wk "go forward")
    "fd"  '(calendar-forward-day :wk "a day")
    "fw"  '(calendar-forward-week :wk "a week")
    "fm"  '(calendar-forward-month :wk "a month")
    "fy"  '(calendar-forward-year :wk "a year")
    "g"   '(:ignore t :wk "goto")
    "gd"  #'calendar-goto-date
    "gm"  #'calendar-other-month
    "gt"  #'calendar-goto-today
    "h"   '(:ignore t :wk "holidays")
    "hl"  #'calendar-list-holidays
    "hm"  #'calendar-mark-holidays
    "H"   '(:ignore t :wk "HTML export")
    "Hm"  #'cal-html-cursor-month
    "Hy"  #'cal-html-cursor-year
    "M"   #'calendar-other-month))
#+end_src

** AI
*** chatgpt-shell
#+begin_src emacs-lisp
(use-package chatgpt-shell
  :straight t
  :after (password-store)
  :commands (chatgpt-shell)
  :bind (("C-c a p" . chatgpt-shell-prompt)
         ("C-c a s" . chatgpt-shell)
         ("C-c a r" . chatgpt-shell-proofread-region))
  :config
  (setq chatgpt-shell-openai-key (password-store-get "emacs/chatgpt"))
  :custom
  ;; From https://github.com/jwiegley/dot-emacs/blob/master/init.org
  ;; I might need to change these
  (chatgpt-shell-system-prompts
   '(("English" .
      "I want you to act as an English translator, spelling corrector and improver. I will speak to you in any language and you will detect the language, translate it and answer in the corrected and improved version of my text, in English. I want you to replace my simplified A0-level words and sentences with more beautiful and elegant, upper level English words and sentences. Keep the meaning same, but make them more literary. I want you to only reply the correction, the improvements and nothing else, do not write explanations.")
     ("Spanish" .
      "I want you to act as an Latin-American Spanish translator, spelling corrector and improver. I will speak to you in English, and you will translate it and answer in the corrected and improved version of my text, in Latin-American Spanish. I want you to replace my simplified A0-level words and sentences with more beautiful and elegant, upper level Latin-American  Spanish words and sentences. Keep the meaning same, but make them more literary and clear. I want you to only reply the correction, the improvements and nothing else, do not write explanations.")
     ("Persian" .
      "I want you to act as an Farsi translator, spelling corrector and improver. I will speak to you in English, and you will translate it and answer in the corrected and improved version of my text, in Farsi. I want you to replace my simplified A0-level words and sentences with more beautiful and elegant, upper level Farsi words and sentences. Keep the meaning same, but make them more literary and clear. I want you to only reply the correction, the improvements and nothing else, do not write explanations.")
     ("General" .
      "You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels.")
     ("Programming" .
      "The user is a programmer with very limited time. You treat their time as precious. You do not repeat obvious things, including their query. You are as concise as possible in responses. You never apologize for confusions because it would waste their time. You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels. Don't explain code snippets. Whenever you output updated code for the user, only show diffs, instead of entire snippets.")
     ("Positive Programming" .
      "Your goal is to help the user become an amazing computer programmer. You are positive and encouraging. You love see them learn. You do not repeat obvious things, including their query. You are as concise in responses. You always guide the user go one level deeper and help them see patterns. You never apologize for confusions because it would waste their time. You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels. Don't explain code snippets. Whenever you output updated code for the user, only show diffs, instead of entire snippets.")
     ("Travel Guide" .
      "I want you to act as a travel guide. I will write you my location and you will suggest a place to visit near my location. In some cases, I will also give you the type of places I will visit. You will also suggest me places of similar type that are close to my first location."))))
#+end_src

** COMMENT Docker
Docker is an awesome tool for reproducible development environments.
Due to this, I absolutely need a mode for editing Dockerfiles.
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer t
  :straight (:build t)
  :hook (dockerfile-mode . lsp-deferred)
  :init
  (put 'docker-image-name 'safe-local-variable #'stringp)
  :mode "Dockerfile\\'"
  :general
  (phundrak/major-leader-key
   :keymaps 'general-mode-map
   :packages 'lsp-mode
   "l"  '(:keymap lsp-command-map :which-key "lsp")))
#+end_src

The ~docker~ package also provides interactivity with Docker and
docker-compose from Emacs.
#+begin_src emacs-lisp
(use-package docker
  :defer t
  :straight (:build t))
#+end_src
** Debugging
*** COMMENT esup
Debug emacs init startup time
Run ~M-x esup~ to see where the time is spend during emacs startup.

#+BEGIN_SRC emacs-lisp
(use-package esup
  :straight t
  :defer t)
#+END_SRC

** rg.el
#+begin_src emacs-lisp
(use-package rg
  :straight t
  :config
  (rg-enable-default-bindings)
  ;; Not sure if I really need this
  (rg-define-toggle "--multiline --multiline-dotall" "u")
  (rg-define-toggle "--word-regexp" "w")
  (rg-define-toggle "--files-with-matches" "L")
  ;; Highlight longer
  (setq next-error-highlight-no-select t)
  (add-hook 'next-error-hook #'recenter)
  (add-hook 'next-error-hook #'focus-mode)
)
#+end_src

Configure custom searches
#+begin_src emacs-lisp
;; search in org roam folder
(rg-define-search my/rg-org-roam-directory
  :query ask
  :format regexp
  :files "everything"
  :dir org-roam-directory
  :confirm prefix)

;; search in org roam folder where I have transcripts from the Huberman Lab
(rg-define-search my/rg-org-roam-directory-huberman
  :query ask
  :format regexp
  :files "everything"
  :dir (concat org-roam-directory "/rez/huberman-lab")
  :confirm prefix)
#+end_src

** elfeed

Elfeed is a nice Atom and RSS reader for Emacs. The only thing I want
to change for now is the default search filter: I want to see not only
unread news but read news as well, a bit like my emails; and where the
database is to be stored.
#+begin_src emacs-lisp
(use-package elfeed
  :defer t
  :straight (:build t)
  :config
  <<elfeed-open-youtube-with-mpv>>
  :custom
  ((elfeed-search-filter "@1-week-ago +unread")
   (elfeed-db-directory "~/.elfeed")
   (elfeed-goodies/wide-threshold 0.2)
   (elfeed-set-timeout 36000)))
#+end_src

Custom functions:

#+begin_src emacs-lisp
(defun hp/elfeed-entry-line-draw (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (concat "[" (mapconcat 'identity tags ",") "]"))
         (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                         elfeed-goodies/tag-column-width 4))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               title-width)
                        :left))
         (tag-column (elfeed-format-column
                      tags-str (elfeed-clamp (length tags-str)
                                             elfeed-goodies/tag-column-width
                                             elfeed-goodies/tag-column-width)
                      :left))
         (feed-column (elfeed-format-column
                       feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width)
                       :left))
         ;; (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 6 :left))
         ;; (entry-authors (concatenate-authors
         ;;                 (elfeed-meta entry :authors)))
         ;; (authors-column (elfeed-format-column entry-authors elfeed-goodies/tag-column-width :left))
         )
    (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
        (progn
          ;; (insert (propertize entry-score 'face 'elfeed-search-feed-face) " ")
          (insert (propertize date 'face 'elfeed-search-date-face) " ")
          (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
          (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
          ;; (insert (propertize authors-column 'face 'elfeed-search-tag-face) " ")
          (insert (propertize title 'face title-faces 'kbd-help title))
          )
      (insert (propertize title 'face title-faces 'kbd-help title))))
  )

#+end_src

I don’t want YouTube videos to be open with my web browser when I
invoke ~elfeed-show-visit~, so I’ll advise this function to make it
possible to modify the behaviour of said function. Oh, and I already
made [[file:../../scripts.md#ytplay][a neat package]] for playing YouTube videos and friends through
[[https://ytdl-org.github.io/youtube-dl/][youtube-dl]] or its superior fork [[https://github.com/yt-dlp/yt-dlp][yt-dlp]] in mpv.

#+name: elfeed-open-youtube-with-mpv
#+begin_src emacs-lisp
(defun my/elfeed-filter-youtube-videos (orig-fun &rest args)
  "Open with mpv the video leading to PATH"
  (let ((link (elfeed-entry-link elfeed-show-entry)))
    (when link
      (if (string-match-p ".*youtube\.com.*watch.*" link)
          ;; This is a YouTube video, open it with mpv
          (progn
            (require 'ytplay)
            (ytplay link))
        (apply orig-fun args)))))

(advice-add 'elfeed-show-visit :around #'my/elfeed-filter-youtube-videos)
#+end_src

A future improvement to be made is to let the user chose the
resolution of the video before it is launched. I may not always have
the best internet connection, and viewing 4K videos on a 1080p display
is not something very useful.
*** elfeed-goodies
Elfeed-goodies is a package which enhances the Elfeed experience.
Aside from running its setup command as soon as possible, I also set
in this code block all my keybinds for Elfeed here.
#+begin_src emacs-lisp
(use-package elfeed-goodies
  :defer t
  :after elfeed
  :commands elfeed-goodies/setup
  :straight (:build t)
  :init
  (elfeed-goodies/setup)
  :custom
  (elfeed-goodies/feed-source-column-width 28)
  (elfeed-goodies/tag-column-width 28)
  :config
  (setq elfeed-search-print-entry-function 'hp/elfeed-entry-line-draw)
  :general
  (phundrak/undefine
    :keymaps '(elfeed-show-mode-map elfeed-search-mode-map)
    :packages 'elfeed
    "DEL" nil
    "s"   nil)
  (phundrak/evil
    :keymaps 'elfeed-show-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-show-mode)>>)
  (phundrak/evil
    :keymaps 'elfeed-search-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-search-mode)>>)
  (phundrak/major-leader-key
    :keymaps 'elfeed-search-mode-map
    :packages 'elfeed
    <<general-keybindings-gen(table=elfeed-keybinds-search-mode-prefixed)>>))
#+end_src

*** elfeed-org
Last but not least, my Elfeed configuration is stored in an org file
thanks to ~elfeed-org~.
#+begin_src emacs-lisp
(use-package elfeed-org
  :defer nil
  :after elfeed
  :straight (:build t)
  :init
  (elfeed-org)
  :config
  (setq rmh-elfeed-org-files '("~/work/repos/org/elfeed.org.gpg")))
#+end_src
*** reddigg
Use reddigg to show reddit threads.
#+begin_src emacs-lisp
(use-package reddigg
  :straight t
  :after elfeed
  :config
  (defun my/elfeed-reddit-show-commments (&optional link)
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (if link link (elfeed-entry-link entry))))
      (reddigg-view-comments link))))
#+end_src
*** hnreader
#+begin_src emacs-lisp
(use-package hnreader
  :straight t
  :after (elfeed))
#+end_src
Open in same window
#+begin_src emacs-lisp
(setq hnreader-view-comments-in-same-window nil)
#+end_src

Use hnreader to show HN threads
#+begin_src emacs-lisp
(defun my/elfeed-hn-show-commments (&optional link)
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (if link link (elfeed-entry-link entry))))
    (setq-local hnreader-view-comments-in-same-window nil)
    (hnreader-promise-comment (format "%s" link))))
#+end_src

Use hnread to show HN threads for a URL at point
#+begin_src emacs-lisp
(defun my/elfeed-hn-show-comments-at-point ()
  "Kill the url at point."
  (interactive)
  (setq-local hnreader-view-comments-in-same-window t)
  (hnreader-comment (format "%s" (url-get-url-at-point))))
#+end_src

*** Keybindings
First, here are the keybinds for Elfeed’s ~elfeed-show-mode~. They
aren’t prefixed by ~SPC~ like most of my keybinds, a direct keypress
will directly launch the function.
#+name: elfeed-keybinds-show-mode
| Key | Function                      | Comment |
|-----+-------------------------------+---------|
| +   | elfeed-show-tag               |         |
| -   | elfeed-show-untag             |         |
| «   | elfeed-show-prev              |         |
| »   | elfeed-show-next              |         |
| b   | elfeed-show-visit             |         |
| C   | elfeed-kill-link-url-at-point |         |
| d   | elfeed-show-save-enclosure    |         |
| l   | elfeed-show-next-link         |         |
| o   | elfeed-goodies/show-ace-link  |         |
| q   | elfeed-kill-buffer            |         |
| S   | elfeed-show-new-live-search   |         |
| u   | elfeed-show-tag--unread       |         |
| y   | elfeed-show-yank              |         |

Same thing, different mode, here are my keybinds for
~elfeed-search-mode~.
#+name: elfeed-keybinds-search-mode
| Key | Function                       | Comment |
|-----+--------------------------------+---------|
| «   | elfeed-search-first-entry      |         |
| »   | elfeed-search-last-entry       |         |
| b   | elfeed-search-browse-url       |         |
| f   |                                | filter  |
| fc  | elfeed-search-clear-filter     |         |
| fl  | elfeed-search-live-filter      |         |
| fs  | elfeed-search-set-filter       |         |
| u   |                                | update  |
| us  | elfeed-search-fetch            |         |
| uS  | elfeed-search-update           |         |
| uu  | elfeed-update                  |         |
| uU  | elfeed-search-update--force    |         |
| y   | elfeed-search-yank             |         |
| x   | elfeed-search-untag-all-unread |         |
| TAB | elfeed-search-show-entry       |         |

I have some additional keybinds for ~elfeed-search-mode~, but these one
are prefixed with ~,~ (and ~M-m~).
#+name: elfeed-keybinds-search-mode-prefixed
| Key | Function                            | Comment |
|-----+-------------------------------------+---------|
| c   | elfeed-db-compact                   |         |
| t   |                                     | tag     |
| gr  | my/elfeed-reddit-show-commments     |         |
| gh  | my/elfeed-hn-show-comments-at-point |         |
| tt  | elfeed-search-tag-all-unread        |         |
| tu  | elfeed-search-untag-all-unread      |         |
| tT  | elfeed-search-tag-all               |         |
| tU  | elfeed-search-untag-all             |         |

** COMMENT Email
*** Basic configuration
As seen below, I use ~org-msg~ to compose my emails, which includes by
default my signature. Therefore, there is no need for Emacs itself to
know about it since I don’t want it to include it a second time after
~org-msg~ already did.
#+begin_src emacs-lisp
(setq message-signature nil
      mail-signature    nil)
#+end_src
*** Gnus
#+begin_src emacs-lisp
(use-package gnus
  :straight (:type built-in)
  :defer t
  :config
  (require 'gnus-topic)
  (setq gnus-select-method '(nnnil))
  (setq gnus-secondary-select-methods '((nntp "news.gwene.org")))

  (setq gnus-asynchronous t ;; async
        gnus-use-article-prefetch 15
        ;; article
        gnus-visible-headers (mapcar (lambda (str) (concat "^" str ":"))
                                     '("From" "To" "Cc" "Subject" "Newsgroup"
                                       "Date" "Followup-To" "Reply-To"
                                       "Organization" "X-Newsreader" "X-Mailer"))
        gnus-sorted-header-list gnus-visible-headers
        gnus-thread-sort-functions '(gnus-thread-sort-by-number
                                     gnus-thread-sort-by-subject
                                     (not gnus-thread-sort-by-date))
        ;; group
        gnus-level-subscribed 6
        gnus-level-unsubscribed 7
        gnus-level-zombie 8
        gnus-group-sort-function '((gnus-group-sort-by-unread)
                                   (gnus-group-sort-by-alphabet)
                                   (gnus-group-sort-by-rank))
        gnus-group-line-format "%M%p%P%5y:%B%(%g%)\n"
        gnus-group-mode-line-format "%%b"
        gnus-topic-display-empty-topics nil
        ;; summary
        gnus-auto-select-first nil
        gnus-summary-ignore-duplicates t
        gnus-suppress-duplicates t
        gnus-summary-to-prefix "To:"
        gnus-summary-line-format "%U%R %-18,18&user-date; %4L:%-25,25f %B%s\n"
        gnus-summary-mode-line-format "[%U] %p"
        gnus-sum-thread-tree-false-root ""
        gnus-sum-thread-tree-indent " "
        gnus-sum-thread-tree-single-indent ""
        gnus-sum-thread-tree-leaf-with-other "+->"
        gnus-sum-thread-tree-root ""
        gnus-sum-thread-tree-single-leaf "\\->"
        gnus-sum-thread-tree-vertical "|")

  (add-hook 'dired-mode-hook #'gnus-dired-mode)
  (add-hook 'gnus-group-mode-hook #'gnus-topic-mode)
  (add-hook 'gnus-select-group-hook #'gnus-group-set-timestamp)

  (dolist (mode '(gnus-group-mode-hook gnus-summary-mode-hook gnus-browse-mode-hook))
    (add-hook mode #'hl-line-mode))

  :general
  (phundrak/evil
    :keymaps 'gnus-summary-mode-map
    :packages 'gnus
    "«" #'gnus-summary-prev-article
    "»" #'gnus-summary-next-article)
  (phundrak/major-leader-key
    :keymaps 'gnus-summary-mode-map
    :packages 'gnus
    "d"  #'gnus-summary-delete-article
    "f"  #'gnus-summary-mail-forward
    "r"  '(:ignore t :wk "reply")
    "rr" #'gnus-summary-reply-with-original
    "rl" #'gnus-summary-reply-to-list-with-original
    "rw" #'gnus-summary-wide-reply-with-original
    "rW" #'gnus-summary-very-wide-reply-with-original)
  (phundrak/evil
    :keymaps 'gnus-group-mode-map
    :packages 'gnus
    "«" #'gnus-group-prev-group
    "»" #'gnus-group-next-group)
  (phundrak/major-leader-key
    :keymaps '(gnus-group-mode-map)
    :packages 'gnus
    "SPC" #'gnus-topic-read-group
    "c"  '(gnus-topic-catchup-articles :which-key "catchup")
    "f"  '(gnus-fetch-group :which-key "fetch")
    "j"  '(:ignore t :which-key "jump")
    "jg" #'gnus-group-jump-to-group
    "jt" #'gnus-topic-jump-to-topic
    "L"  #'gnus-group-list-all-groups
    "n"  #'gnus-group-news
    "t"  '(gnus-group-topic-map :which-key "topics")
    "u"  #'gnus-group-unsubscribe))
#+end_src

*** Mu4e
Mu4e is a very eye-pleasing email client for Emacs, built around ~mu~
and which works well with ~mbsync~ (found in Arch’s ~isync~ package). For
me, the main advantage of mu4e is it has a modern interface for
emailing, and quite straightforward. I tried a couple of other email
clients for Emacs, and I even was for some time a Gnus user, but in
the end, mu4e really works best for me. Below you’ll find my
configuration for the ~mu4e~ package itself.
#+begin_src emacs-lisp
(use-package mu4e
  :after all-the-icons
  :straight (:build t)
  :commands mu4e mu4e-compose-new
  :init
  (defun mu4e--main-action-str (name func)
    "This seems to be needed until evil-collection supports the latest
  version of mu4e."
    "mu4e-main-action")

  (require 'mu4e)
  (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)

  <<mu4e-ical-setup>>
  <<mu4e-ical-init-config>>

  (csetq mu4e-completing-read-function 'completing-read
         mu4e-use-fancy-chars          t
         message-kill-buffer-on-exit   t
         mu4e-org-support              nil)
  (let ((dir (concat (getenv "HOME") "/Downloads/mu4e")))
    (when (file-directory-p dir)
      (csetq mu4e-attachment-dir dir)))
  (defmacro mu4e-view-mode--prepare ()
    `(lambda () (visual-line-mode 1)))
  :gfhook ('mu4e-view-mode-hook (mu4e-view-mode--prepare))
  :general
  (phundrak/evil
    :keymaps 'mu4e-main-mode-map
    :packages 'mu4e
    "U" #'mu4e-update-index)
  :config
  (require 'mu4e-view)
  (with-eval-after-load 'mm-decode
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text-richtext"))

  (add-hook 'mu4e-view-mode-hook (lambda () (setq truncate-lines nil)))
  (add-hook 'mu4e-headers-mode-hook (lambda () (setq truncate-lines t)))

  <<mu4e-ical-config>>
  <<mu4e-keybindings-undef>>
  <<mu4e-keybindings-view>>
  <<mu4e-keybindings-view-no-prefix>>
  <<mu4e-keybindings-header>>
  <<mu4e-keybindings-header-no-leader>>
  <<mu4e-keybindings-message>>

  <<mu4e-mail-service>>
  <<mu4e-mail-on-machine>>
  <<mu4e-no-signature>>
  <<mu4e-bookmarks>>
  <<mu4e-maildirs>>

  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (require 'gnus-dired)
  (setq gnus-dired-mail-mode 'mu4e-user-agent)

  (add-hook 'mu4e-compose-mode-hook (lambda () (use-hard-newlines t 'guess)))
  (add-hook 'mu4e-compose-mode-hook 'mml-secure-message-sign-pgpmime)

  (setq mu4e-change-filenames-when-moving t
        mu4e-update-interval              60
        mu4e-compose-format-flowed        t
        mu4e-view-show-addresses          t
        mu4e-sent-messages-behaviour      'sent
        mu4e-hide-index-messages          t
        mu4e-view-show-images             t                     ; try to show images
        mu4e-view-image-max-width         600
        message-send-mail-function        #'smtpmail-send-it    ; how to send an email
        smtpmail-stream-type              'starttls
        message-kill-buffer-on-exit       t                     ; close after sending
        mu4e-context-policy               'pick-first           ; start with first (default) context
        mu4e-compose-context-policy       'ask-if-none          ; compose with current context, or ask
        mu4e-completing-read-function     #'ivy-completing-read ; use ivy
        mu4e-confirm-quit                 t                     ; no need to ask
        mu4e-header-fields                '((:account    . 12)
                                            (:human-date . 12)
                                            (:flags      . 4)
                                            (:from       . 25)
                                            (:subject)))

  ;; set mail user agent
  (setq mail-user-agent 'mu4e-user-agent)

  <<mu4e-fancy-marks>>
  <<mu4e-vertical-split>>
  <<mu4e-headers-mode>>

  (defun mu4e-action-open-as-pdf (msg)
    "Export and open MSG as pdf."
    (let* ((date    (mu4e-message-field msg :date))
           (infile  (mu4e~write-body-to-html msg))
           (outfile (format-time-string "/tmp/%Y-%m-%d-%H-%M-%S.pdf" date)))
      (with-temp-buffer
        (shell-command
         (format "wkhtmltopdf %s %s" infile outfile) t))
      (find-file outfile))))
#+end_src

Quick sidenote: on Arch Linux, you’ll need to install either ~mu~ or
~mu-git~ from the AUR in order to use mu4e. I also have a ~.desktop~ file
to make it possible to open mu4e directly from my program picker. It
uses the shell script ~emacsmail~ I’ve written [[file:bin.org::#Emacsmail-afffb7cd][here]].
#+header: :mkdirp yes
#+begin_src conf-desktop :tangle ~/.local/share/applications/mu4e.desktop
[Desktop Entry]
Name=Mu4e
GenericName=Mu4e
Comment=Maildir Utils for Emacs
MimeType=x-scheme-handler/mailto;
Exec=/home/phundrak/.local/bin/emacsmail %U
Icon=emacs
Type=Application
Terminal=false
Categories=Network;Email;TextEditor
StartupWMClass=Gnus
Keywords=Text;Editor;
#+end_src

**** Basic configuration
First, let’s inform Emacs how it can send emails, using which service
and how. In my case, I use my own mail server.
#+name: mu4e-mail-service
#+begin_src emacs-lisp :tangle no
(setq smtpmail-smtp-server       "mail.phundrak.com"
      smtpmail-smtp-service      587
      smtpmail-stream-type       'starttls
      message-send-mail-function 'smtpmail-send-it)
#+end_src

We also need to inform it on where my emails are stored on my machine,
and how to retrieve them.
#+name: mu4e-mail-on-machine
#+begin_src emacs-lisp :tangle no
(setq mu4e-get-mail-command "mbsync -a"
      mu4e-root-maildir     "~/Mail"
      mu4e-trash-folder     "/Trash"
      mu4e-refile-folder    "/Archive"
      mu4e-sent-folder      "/Sent"
      mu4e-drafts-folder    "/Drafts")
#+end_src

In the same vein of [[*Basic configuration][this bit of configuration]], I do not want mu4e to
insert my mail signature, ~org-msg~ already does that.
#+name: mu4e-no-signature
#+begin_src emacs-lisp :tangle no
(setq mu4e-compose-signature nil)
#+end_src

**** Bookmarks
In mu4e, the main focus isn’t really mail directories such as your
inbox, your sent messages and such, but instead you manipulate
bookmarks which will show you emails depending on tags. This mean you
can create some pretty customized bookmarks that go way beyound your
simple inbox, outbox and all. Actually, four of my bookmarks have a
couple of filtering:
- anything in my inbox linked to my university
- the [[https://emacs-doctor.com/lists/listinfo][emacs-doctor mailing list]] (French Emacs mailing list)
- emails related to my internship
- and my inbox for any mail not caught by any of these filters
And all of them will have the requirement not to display any trashed
email. Actually, all of my bookmarks will have this requirement,
except for the bookmark dedicated to them as well as my sent emails.
I’ll add these latter requirements later.

Here are the requirements for my university bookmark. The regex
matches any email address which contains either ~up8.edu~ or
~univ-paris8~, which can be found in email addresses from the University
Paris 8 (my university).

#+name: mu4e-bookmarks-from-copy-to-gen
#+begin_src emacs-lisp :tangle no :exports none :var regex="test"
(mapconcat (lambda (x) (concat x ":" regex))
           '("f" "c" "t")
           " OR ")
#+end_src

#+name: mu4e-bookmarks-mailing-lists
#+header: :tangle no :exports none
#+begin_src emacs-lisp :var lists=mu4e-emacs-mailing-lists
(mapconcat (lambda (list)
             (let ((address (string-replace (regexp-quote "~")
                                            ""
                                            (if (stringp list) list (car list)))))
               (mapconcat (lambda (flag)
                            (concat flag ":" address))
                          '("list" "t" "f" "contact")
                          " OR ")))
           lists
           " OR ")
#+end_src

#+name: mu4e-bookmarks-filter-uni
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*up8\\.edu|.*univ-paris8.*/"))
  (concat
   <<mu4e-bookmarks-from-copy-to-gen>>
   " OR maildir:/Univ/Inbox OR maildir:/Univ/Junk"))
#+end_src

#+RESULTS[083992a66ea6339d3a55773108e520a6024102c5]: mu4e-bookmarks-filter-uni
: f:/.*up8\.edu|.*univ-paris8.*/ OR c:/.*up8\.edu|.*univ-paris8.*/ OR t:/.*up8\.edu|.*univ-paris8.*/ OR maildir:/Univ/Inbox OR maildir:/Univ/Junk

Next I need an inbox dedicated to the association I’m part of.
#+name: mu4e-bookmarks-filter-asso
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*supran\\.fr/"))
  <<mu4e-bookmarks-from-copy-to-gen>>)
#+end_src

#+RESULTS[e04566a9d56624e063b3dd4e2c639e87cf9683aa]: mu4e-bookmarks-filter-asso
: f:/.*supran\.fr/ OR c:/.*supran\.fr/ OR t:/.*supran\.fr/

As for the Emacs-doctor list, I need to match both the current, modern
mailing list address but also its old address. The same applies for
the emacs-devel mailing list as well as GitHub emails related to my
package ~eshell-info-banner.el~. Here are the addresses to
match:

# Insert #Packages-Configuration-Emacs-built-ins-Eshell-Visual-configuratione7c2fl6184j0 equivalent in *see here*

#+name: mu4e-emacs-mailing-lists
- ~/ateliers.*emacs.*/~
- ~/emacs-.*@gnu.org/~
- ~/.*eshell-info-banner.*/~
- ~/.*emacsfr.*/~

#+name: mu4e-bookmarks-filter-emacs-list
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
"<<mu4e-bookmarks-mailing-lists(lists=mu4e-emacs-mailing-lists)>>"
#+end_src

#+RESULTS[88c964fba64459a050055bc5614bbd65f8740bfb]: mu4e-bookmarks-filter-emacs-list
: list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/

Another bookmark I wish to have is one dedicated to emails related to
more general development topics, including issues and PRs from GitHub.
#+name: mu4e-github-mailing-lists
- ~/.*\\.github\\.com/~
- ~/.*\\.gitlab\\.com/~
- ~stumpwm-devel@nongnu.org~
- ~/.*sr\\.ht/~

#+name: mu4e-bookmarks-filter-github-list
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
;; "<<mu4e-bookmarks-mailing-lists(lists=mu4e-github-mailing-lists)>> AND NOT ()"
(string-join '("<<mu4e-bookmarks-mailing-lists(lists=mu4e-github-mailing-lists)>>"
               "AND NOT ("
               <<mu4e-bookmarks-filter-emacs-list>>
               ")")
             " ")
#+end_src

#+RESULTS[673f76e7a682ed64f98dbe6d4a06810436ba6799]: mu4e-bookmarks-filter-github-list
: list:/.*\.github\.com/ OR t:/.*\.github\.com/ OR f:/.*\.github\.com/ OR contact:/.*\.github\.com/ OR list:/.*\.gitlab\.com/ OR t:/.*\.gitlab\.com/ OR f:/.*\.gitlab\.com/ OR contact:/.*\.gitlab\.com/ OR list:stumpwm-devel@nongnu.org OR t:stumpwm-devel@nongnu.org OR f:stumpwm-devel@nongnu.org OR contact:stumpwm-devel@nongnu.org OR list:/.*sr\.ht/ OR t:/.*sr\.ht/ OR f:/.*sr\.ht/ OR contact:/.*sr\.ht/ AND NOT ( list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/ )

When it comes to my internship, all emails will contain an address containing ~aubay.com~ (that’s where my internship takes place).
- ~/.*aubay.com/~

#+name: mu4e-bookmarks-filter-aubay
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(let ((regex "/.*aubay\\.com/"))
  <<mu4e-bookmarks-from-copy-to-gen>>)
#+end_src

#+RESULTS[06105e10cf2addb8e11360ff2629023fad946ddf]: mu4e-bookmarks-filter-aubay
: f:/.*aubay\.com/ OR c:/.*aubay\.com/ OR t:/.*aubay\.com/

As I said earlier, something that will often come back in my bookmarks
is the emails must not be trashed to appear. I want also to display
junk emails, so I end up with the following rule:
#+name: mu4e-bookmarks-default-filter
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(mapconcat #'identity
           `("NOT flag:trashed"
             ,(format "(%s)" (mapconcat (lambda (maildir) (concat "maildir:" maildir))
                                        '("/Inbox" "/Junk")
                                        " OR ")))
            " AND ")
#+end_src

#+RESULTS[f3f96c07b8341c1b7b3d02688aa6faa2ceeca16f]: mu4e-bookmarks-default-filter
: NOT flag:trashed AND (maildir:/Inbox OR maildir:/Junk)

And for the last string-generating code, let’s describe my main inbox:
#+name: mu4e-bookmarks-inbox-filters
#+header: :tangle no :cache yes
#+begin_src emacs-lisp
(mapconcat #'identity
           (cons "<<mu4e-bookmarks-default-filter()>>"
                 `(,(format "(%s)"
                            <<mu4e-bookmarks-filter-aubay>>)
                   ,(format "(%s)" "<<mu4e-bookmarks-filter-asso()>>")
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-emacs-list>>)
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-github-list>>)
                   ,(format "(%s)"
                            <<mu4e-bookmarks-filter-uni>>)))
           " AND NOT ")
#+end_src

#+RESULTS[94290b02a0da24cffeba43e1d47395e801bc0158]: mu4e-bookmarks-inbox-filters
: NOT flag:trashed AND (maildir:/Inbox OR maildir:/Junk) AND NOT (f:/.*aubay\.com/ OR c:/.*aubay\.com/ OR t:/.*aubay\.com/) AND NOT (f:/.*supran.fr/ OR c:/.*supran.fr/ OR t:/.*supran.fr/) AND NOT (list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/) AND NOT (list:/.*\.github\.com/ OR t:/.*\.github\.com/ OR f:/.*\.github\.com/ OR contact:/.*\.github\.com/ OR list:/.*\.gitlab\.com/ OR t:/.*\.gitlab\.com/ OR f:/.*\.gitlab\.com/ OR contact:/.*\.gitlab\.com/ OR list:stumpwm-devel@nongnu.org OR t:stumpwm-devel@nongnu.org OR f:stumpwm-devel@nongnu.org OR contact:stumpwm-devel@nongnu.org OR list:/.*sr\.ht/ OR t:/.*sr\.ht/ OR f:/.*sr\.ht/ OR contact:/.*sr\.ht/ AND NOT ( list:/ateliers.*emacs.*/ OR t:/ateliers.*emacs.*/ OR f:/ateliers.*emacs.*/ OR contact:/ateliers.*emacs.*/ OR list:/emacs-.*@gnu.org/ OR t:/emacs-.*@gnu.org/ OR f:/emacs-.*@gnu.org/ OR contact:/emacs-.*@gnu.org/ OR list:/.*eshell-info-banner.*/ OR t:/.*eshell-info-banner.*/ OR f:/.*eshell-info-banner.*/ OR contact:/.*eshell-info-banner.*/ OR list:/.*emacsfr.*/ OR t:/.*emacsfr.*/ OR f:/.*emacsfr.*/ OR contact:/.*emacsfr.*/ )) AND NOT (f:/.*up8\.edu|.*univ-paris8.*/ OR c:/.*up8\.edu|.*univ-paris8.*/ OR t:/.*up8\.edu|.*univ-paris8.*/ OR maildir:/Univ/Inbox OR maildir:/Univ/Junk)

We can finally define our bookmarks! The code reads as follows:
#+name: mu4e-bookmarks
#+begin_src emacs-lisp :tangle no :cache yes :results none
(setq mu4e-bookmarks
      `((:name "Inbox"
         :key ?i
         :query ,(format "%s"
                         <<mu4e-bookmarks-inbox-filters>>))
        (:name "Internship"
         :key ?a
         :query ,(format "(%s) AND (%s)"
                     "<<mu4e-bookmarks-default-filter()>>"
                     <<mu4e-bookmarks-filter-aubay>>))
        (:name "University"
         :key ?u
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-uni()>>"))
        (:name "Dev"
         :key ?d
         :query ,(format "%s AND (%s)"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-github-list()>>"))
        (:name "Emacs"
         :key ?e
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         <<mu4e-bookmarks-filter-emacs-list>>))
        (:name "Supran"
         :key ?s
         :query ,(format "%s AND %s"
                         "<<mu4e-bookmarks-default-filter()>>"
                         "<<mu4e-bookmarks-filter-asso()>>"))
        (:name "Sent"       :key ?S :query "maildir:/Sent OR maildir:/Univ/Sent")
        (:name "All Unread" :key ?U :query "flag:unread AND NOT flag:trashed")
        (:name "Today"      :key ?t :query "date:today..now AND NOT flag:trashed")
        (:name "This Week"  :key ?w :query "date:7d..now    AND NOT flag:trashed")
        (:name "This Month" :key ?m :query "date:1m..now    AND NOT flag:trashed")
        (:name "This Year"  :key ?y :query "date:1y..now    AND NOT flag:trashed")))
#+end_src

**** Maildirs
Sometimes, bookmarks are a bit too restrictive when I want to search
for stuff. Simply jumping to a mail directory, or maildir, is more
than enough. In mu4e, with my current setup, I can jump to any maildir
with the shortcut ~Jo~ in normal-mode, and I just need to choose in a
list the maildir I want to jump to. But it can be faster.

With this piece of code, I can simply jump to my inbox maildir with
~Ji~, to my sent messages with ~Js~, and so on.
#+name: mu4e-maildirs
#+begin_src emacs-lisp :tangle no
(setq mu4e-maildir-shortcuts
      '((:maildir "/Inbox" :key ?i)
        (:maildir "/Sent" :key ?s)
        (:maildir "/Junk" :key ?j)
        (:maildir "/Trash" :key ?t)))
#+end_src

**** Dealing with spammers
I’m sure you have received at least one email recently from a sketchy
email address asking you something that might be completely unrelated
to what you do, or at least somewhat related. Fortunately, [[https://twitter.com/Boris/status/1360208504544444417][we have a
hero]]! Now, let me write a function that will insert their
pre-written text at point to avoid me going back to their Twitter
thread each time I want to shut spammers up.
#+begin_src emacs-lisp
(defun reply-to-bill ()
  (interactive)
  (insert "Please forward this email to bill@noprocurement.com,
and delete my email, as I’ll be changing jobs soon, and this
email address will no longer be active.

Bill Whiskoney is a senior partner at Nordic Procurement
Services, and he handles our budget and will help you further or
introduce you to someone who can."))
#+end_src

If you want the full story, make sure to read the whole thread, I
guarantee it, it’s worth your time! And in case the Twitter thread
disappear in the future, [[https://threader.app/thread/1360208504544444417][here is a backup]].

**** Getting Fancy
I’m not a huge fan of mu4e’s default icons marking my emails, so I’ll
redefine them as follows. Be aware the name of these icons are from
/faicon/ in the package ~all-the-icons~.
#+name: mu4e-fancy-marks-tbl
| Mark      | Flag | Icon        |
|-----------+------+-------------|
| draft     | D    | pencil      |
| flagged   | F    | flag        |
| new       | N    | rss         |
| passed    | P    | check       |
| replied   | R    | reply       |
| seen      | S    | eye         |
| unread    | u    | eye-slash   |
| trashed   | T    | trash       |
| attach    | a    | paperclip   |
| encrypted | x    | lock        |
| signed    | s    | certificate |

#+name: mu4e-fancy-marks-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=mu4e-fancy-marks-tbl
(mapconcat (lambda (line)
             (let ((mark (car line))
                   (flag (cadr line))
                   (icon (caddr line)))
               (format "mu4e-headers-%s-mark `(\"%s\" . ,(all-the-icons-faicon \"%s\" :height 0.8))"
                       mark
                       flag
                       icon)))
           table
           "\n")
#+end_src

#+RESULTS[c6ed5d4bec4c10339a7de52a70822af74d782e62]: mu4e-fancy-marks-gen
#+begin_example
mu4e-headers-draft-mark `("D" . ,(all-the-icons-faicon "pencil" :height 0.8))
mu4e-headers-flagged-mark `("F" . ,(all-the-icons-faicon "flag" :height 0.8))
mu4e-headers-new-mark `("N" . ,(all-the-icons-faicon "rss" :height 0.8))
mu4e-headers-passed-mark `("P" . ,(all-the-icons-faicon "check" :height 0.8))
mu4e-headers-replied-mark `("R" . ,(all-the-icons-faicon "reply" :height 0.8))
mu4e-headers-seen-mark `("S" . ,(all-the-icons-faicon "eye" :height 0.8))
mu4e-headers-unread-mark `("u" . ,(all-the-icons-faicon "eye-slash" :height 0.8))
mu4e-headers-trashed-mark `("T" . ,(all-the-icons-faicon "trash" :height 0.8))
mu4e-headers-attach-mark `("a" . ,(all-the-icons-faicon "paperclip" :height 0.8))
mu4e-headers-encrypted-mark `("x" . ,(all-the-icons-faicon "lock" :height 0.8))
mu4e-headers-signed-mark `("s" . ,(all-the-icons-faicon "certificate" :height 0.8))
#+end_example

Let’s enable them and set them:
#+name: mu4e-fancy-marks
#+begin_src emacs-lisp :tangle no
(setq mu4e-use-fancy-chars t
      <<mu4e-fancy-marks-gen()>>)
#+end_src

#+name: mu4e-vertical-split
#+begin_src emacs-lisp :tangle no
(defun my/set-mu4e-headers-width ()
  (let ((width    (window-body-width))
        (threshold (+ 120 80)))
    (setq mu4e-split-view (if (> width threshold)
                              'vertical
                            'horizontal))))

(setq mu4e-headers-visible-columns 120
      mu4e-headers-visible-lines   15)
(add-hook 'mu4e-headers-mode-hook #'my/set-mu4e-headers-width)
#+end_src

**** Headers mode
#+name: mu4e-headers-mode
#+begin_src emacs-lisp :tangle no
(add-hook 'mu4e-headers-mode-hook (lambda () (visual-line-mode -1)))
(add-hook 'mu4e-headers-mode-hook (lambda () (toggle-truncate-lines -1)))
#+end_src

**** Keybindings
By default, Evil has some pretty annoying keybindings for users of the
bépo layout: ~hjkl~ becomes ~ctsr~ for us. Let’s undefine some of these:
#+name: mu4e-keybindings-undef
#+begin_src emacs-lisp :tangle no
(phundrak/undefine
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  "S"   nil
  "r"   nil
  "c"   nil
  "gu"  nil)

(phundrak/undefine
  :keymaps '(mu4e-view-mode-map mu4e-headers-mode-map)
  :packages 'mu4e
  "s"   nil)
#+end_src

Now, let’s define some keybindings for mu4e’s view mode, that is when
we are viewing an email. All these keybindings will reside between the
major-mode specific leader key ~,~ and most of these keybindings can be
described with a simple function:
#+name: mu4e-keybindings-view-tbl
| Keybinding | Function                             | Description        |
|------------+--------------------------------------+--------------------|
| &          | mu4e-view-pipe                       |                    |
| .          | mu4e-headers-split-adjust-width/body | mu4e-headers width |
| a          | nil                                  | attachments        |
| a&         | mu4e-view-pipe-attachment            |                    |
| aa         | mu4e-view-attachment-action          |                    |
| ao         | mu4e-view-open-attachment            |                    |
| aO         | mu4e-view-open-attachment-with       |                    |
| c          | nil                                  | compose            |
| cc         | mu4e-compose-new                     |                    |
| ce         | mu4e-compose-edit                    |                    |
| cf         | mu4e-compose-forward                 |                    |
| cr         | mu4e-compose-reply                   |                    |
| cR         | mu4e-compose-resend                  |                    |
| l          | mu4e-show-log                        |                    |
| m          | nil                                  | mark               |
| md         | mu4e-view-mark-for-trash             |                    |
| mD         | mu4e-view-mark-for-delete            |                    |
| mm         | mu4e-view-mark-for-move              |                    |
| mr         | mu4e-view-mark-for-refile            |                    |
| mR         | mu4e-view-mark-for-read              |                    |
| mu         | mu4e-view-mark-for-unread            |                    |
| mU         | mu4e-view-mark-for-unmark            |                    |
| t          | mu4e-view-mark-thread                | mark thread        |
| T          | nil                                  | toggle             |
| Tc         | mu4e-view-toggle-hide-cited          |                    |
| Th         | mu4e-view-toggle-html                |                    |
| n          | mu4e-view-headers-next               |                    |
| N          | mu4e-view-headers-next-unread        |                    |
| p          | mu4e-view-headers-prev               |                    |
| P          | mu4e-view-headers-prev-unread        |                    |
| u          | nil                                  | url                |
| uf         | mu4e-view-go-to-url                  |                    |
| uF         | mu4e-view-fetch-url                  |                    |

#+name: mu4e-keybindings-view
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-view-tbl)>>)
#+end_src

Two other keybinds are added without a prefix, just for the sake of
convenience.
#+name: mu4e-keybindings-view-no-prefix
#+begin_src emacs-lisp
(phundrak/evil
  :keymaps 'mu4e-view-mode-map
  :packages 'mu4e
  "«" #'mu4e-view-headers-prev
  "»" #'mu4e-view-headers-next)
#+end_src

I’ll also declare two keybinds for mu4e’s headers mode.
#+name: mu4e-keybindings-header
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'mu4e-headers-mode-map
  :packages 'mu4e
  "t" '(mu4e-view-mark-thread :which-key "mark thread")
  "s" 'swiper)
#+end_src

I will also redefine without a leader key ~ctsr~ in order to be able to
move freely (remember, bépo layout for me).
#+name: mu4e-keybindings-header-no-leader-table
| Key | Function                  | Comment |
|-----+---------------------------+---------|
| c   | evil-backward-char        |         |
| t   | evil-next-visual-line     |         |
| s   | evil-previous-visual-line |         |
| r   | evil-forward-char         |         |

#+name: mu4e-keybindings-header-no-leader
#+begin_src emacs-lisp :tangle no
(phundrak/evil
  :keymaps 'mu4e-headers-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-header-no-leader-table)>>)
#+end_src

Finally, let’s declare a couple of keybindings for when we are
composing a message. This time, all my keybindings are prefixed with
the major-mode leader and call a simple function.
#+name: mu4e-keybindings-message-tbl
| Key | Function              | Description |
|-----+-----------------------+-------------|
| ,   | message-send-and-exit |             |
| c   | message-send-and-exit |             |
| a   | message-kill-buffer   |             |
| k   | message-kill-buffer   |             |
| s   | message-dont-send     |             |
| f   | mml-attach-file       |             |

#+name: mu4e-keybindings-message
#+begin_src emacs-lisp :tangle no
(phundrak/major-leader-key
  :keymaps 'message-mode-map
  :packages 'mu4e
  <<general-keybindings-gen(table=mu4e-keybindings-message-tbl)>>)
#+end_src

*** Composing messages
Org mime is cool and all, you can write some org-mode and then export
it to either a plain-text or an HTML email. BUT, have you considered
skipping the export part and write your emails directly in org-mode?
#+begin_src emacs-lisp
(use-package org-msg
  :after (mu4e)
  :straight (:build t)
  :hook ((mu4e-compose-pre . org-msg-mode))
  :custom-face
  (mu4e-replied-face ((t (:weight normal :foreground "#b48ead"))))
  :config
  (defun my/org-msg-signature-convert (orig-fun &rest args)
    "Tweak my signature when replying as plain/text only."
    (let ((res (apply orig-fun args)))
      (when (equal (cadr args) '(text))
        (setf (alist-get 'signature res)
              (replace-regexp-in-string "\n+" "\n" org-msg-signature)))
      res))
  (advice-add 'org-msg-composition-parameters
              :around 'my/org-msg-signature-convert)
  (add-hook 'mu4e-headers-mode (lambda () (toggle-truncate-lines -1)))
  (setq org-msg-startup              "inlineimages"
        org-msg-default-alternatives '((new           . (text))
                                       (reply-to-html . (text))
                                       (reply-to-text . (text)))
        org-msg-greeting-name-limit  3
        org-msg-signature            (format "\n--\n#+begin_signature\n%s\n#+end_signature"
                                             (with-temp-buffer
                                               (insert-file-contents mail-signature-file)
                                               (while (re-search-forward "\n" nil t)
                                                 (replace-match "\n\n"))
                                               (buffer-string))))
  :general
  (phundrak/major-leader-key
    :keymaps 'org-msg-edit-mode-map
    :packages 'org-msg
    <<general-keybindings-gen(table=org-msg-edit-mode-keybinds)>>))
#+end_src

The keybinds are relatively simple ~org-msg-edit-mode~:
#+name: org-msg-edit-mode-keybinds
| Key | Function              | Description |
|-----+-----------------------+-------------|
| ,   | message-send-and-exit |             |
| c   | message-send-and-exit |             |
| a   | message-kill-buffer   |             |
| k   | message-kill-buffer   |             |
| s   | message-dont-send     |             |
| f   | org-msg-attach        |             |

*** Email alerts
There is also a package for mu4e which generates desktop notifications
when new emails are received. By default, I want to be notified by all
messages in my inbox and junk folder. Also, I’ll use Emacs’ default
notification system, and I’ll activate the modeline notification.
#+begin_src emacs-lisp
(use-package mu4e-alert
  :straight (:build t)
  :after mu4e
  :defer t
  :init
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
  (mu4e-alert-set-default-style 'notifications)
  :config
  (setq mu4e-alert-interesting-mail-query "flag:unread"))
#+end_src
** Email
*** mu4e
**** General config
#+begin_src emacs-lisp
;; Make sure we find the mu4e package
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")

(use-package mu4e
  :ensure nil
  :commands (mu4e)
  :bind (("C-c a m" . mu4e)
         :map mu4e-main-mode-map
         ("U" . mu4e-update-mail-and-index-background)
         :map mu4e-headers-mode-map
         ("TAB" . mu4e-headers-next-unread)
         ("j" . mu4e-view-headers-next)
         ("k" . mu4e-view-headers-prev)
         ("J" . mu4e-search-maildir)
         ;; ("j" . mu4e-move-to-junk)
         ;; ("M" . mu4e-headers-mark-all-unread-read) ; Mark all as read
         :map mu4e-view-mode-map
         ("A" . mu4e-view-attachment-action)
         ("M-o" . ace-link-mu4e)
         ("o" . ace-link-mu4e)
         ("n" . mu4e-scroll-up)
         ("p" . mu4e-scroll-down)
         ("J" . mu4e-view-headers-next)
         ("K" . mu4e-view-headers-prev)
         ;; ("j" . mu4e-move-to-junk)
         )
  :init
  ;; From https://github.com/Phundrak/dotfiles/blob/master/org/config/emacs.org
  ;; (defun mu4e--main-action-str (name func)
  ;;   "This seems to be needed until evil-collection supports the latest version of mu4e."
  ;;   "mu4e-main-action")
  ;; (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)

  ;; Prefer text over html/ritchtext
  (setq mm-discouraged-alternatives '("text/html" "text/richtext"))

  ;; Use completing-read (which is ivy) instead of ido
  (setq mu4e-completing-read-function 'completing-read)

  ;; set mu4e as default mail client
  (setq mail-user-agent 'mu4e-user-agent)

  :config

  ;; Set mu binary
  (setq mu4e-mu-binary "/usr/bin/mu")

  ;; Choose which fields to show
  (setq mu4e-headers-fields
        '(
          (:maildir    . 13)
          (:human-date . 12)
          (:flags      . 6)
          (:from       . 22)
          (:subject    . nil)))

  ;; Refresh mail using isync every 10 minutes
  (setq mu4e-update-interval (* 10 60))

  ;; Command used to retrieve new mails
  (setq mu4e-get-mail-command "mbsync -a")

  ;; Defaults
  (setq mu4e-maildir (getenv "MU4E_MAILDIR"))
  (setq-default mu4e-drafts-folder "/private/Drafts")
  (setq-default mu4e-sent-folder   "/private/Sent")
  (setq-default mu4e-trash-folder  "/private/Trash")

  ;; Set citation settings
  (setq message-citation-line-format "\nOn %a, %b %d, %Y at %r %z, %N wrote:\n")
  (setq message-citation-line-function 'message-insert-formatted-citation-line)

  ;; Fancy stuff
  <<mu4e-fancy-marks>>

  ;; And change default threading characters to some "nicer" looking chars
  (setq mu4e-headers-thread-child-prefix '("├>" . "├→ "))
  (setq mu4e-headers-thread-last-child-prefix '("└>" . "└→ "))
  (setq mu4e-headers-thread-connection-prefix '("│" . "│ "))
  (setq mu4e-headers-thread-orphan-prefix '("┬>" . "┬→ "))
  (setq mu4e-headers-thread-single-orphan-prefix '("─>" . "─→ "))

  ;; Also change to some nicer characters for marks
  ;; (setq mu4e-headers-new-mark    '("N" . "📨"))
  (setq mu4e-headers-passed-mark  '("P" . "›"))
  (setq mu4e-headers-replied-mark '("R" . "‹"))
  (setq mu4e-headers-seen-mark   '("S" . ""))
  ;; (setq mu4e-headers-attach-mark '("a" . "📎"))
  (setq mu4e-headers-personal-mark '("p" . ""))
  ;; (setq mu4e-headers-unread-mark '("u" . "📫"))


  ;; Set date format (header view)
  (setq mu4e-headers-date-format "%F")

  ;; How should html context be converted
  ;; (setq mu4e-html2text-command "/usr/bin/w3m -T text/html")
  (setq mu4e-html2text-command "iconv -c -t utf-8 | pandoc -f html -t plain")

  ;; Improve rendering of rich-text messages (html)
  (setq shr-color-visible-luminance-min 80)

  ;; Show email address as well and not only the name
  (setq-default mu4e-view-show-addresses t)

  ;; Don't reply to self
  (setq mu4e-compose-dont-reply-to-self t)

  ;; Setup some handy shortcuts
  ;; you can quickly switch to your Inbox -- press ``ji''
  ;; then, when you want archive some messages, move them to
  ;; the 'All Mail' folder by pressing ``ma''.

  ;; View mail in browser with "a V"
  (add-to-list 'mu4e-view-actions
               '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  (add-to-list 'mu4e-view-actions
               '("fViewInChrome" . mu4e-action-view-in-chrome) t)
  (add-to-list 'mu4e-view-actions
               '("xViewXWidget" . mu4e-action-view-with-xwidget) t)

  (setq mu4e-maildir-shortcuts
        '(
          ("/variomedia/inbox"   . ?v)
          ("/gmail/inbox"    . ?g)
          ("/cashlink/inbox"   . ?c)
          ("/private/Trash"   . ?t)
          ("/private/Drafts"  . ?d)
          ("/private/Junk"    . ?j)
          ("/private/Archive" . ?a)))

  ;; Set contexts
  (dorneanu/set-mu4e-contexts)
  )

<<mu4e-view-mode>>

#+end_src
**** Bookmarks
#+BEGIN_SRC emacs-lisp
(setq mu4e-bookmarks
      `(
        ("maildir:/Sent" "Sent messages" ?s)
        ("flag:unread AND NOT flag:trashed" "Unread messages" ?U)
        ("date:today..now AND NOT flag:trashed" "Today's messages" ?t)
        ("date:7d..now AND NOT flag:trashed" "Last 7 days" ?w)
        ("date:1m..now AND NOT flag:trashed" "Last month" ?m)
        ("date:1y..now AND NOT flag:trashed" "Last year" ?y)
        ("flag:trashed AND NOT flag:trashed" "Trash" ?T)
        ("from:yo@dev.to AND NOT flag:trashed" "dev.to" ?d)
        ("from:jira@*" "Jira" ?j)
        ;; (,(s-join " "
        ;;           '("OR noreply@tagesspiegel.de"
        ;;             "OR support@lagedernation.org"
        ;;             "OR hello@blinkist.com"
        ;;             "OR info@smarticular.net"
        ;;             "OR newsletter@*"
        ;;             "OR support@xeroshoes.com"))
        ;;  "Newletter" ?n)
        ("mime:image/* AND NOT flag:trashed" "Messages with images" ?p)))
#+END_SRC

**** Fancy stuff
From https://github.com/Phundrak/dotfiles

#+name: mu4e-fancy-marks-tbl
| Mark      | Flag | Icon        |
|-----------+------+-------------|
| draft     | D    | pencil      |
| flagged   | F    | flag        |
| new       | N    | rss         |
| passed    | P    | check       |
| replied   | R    | reply       |
| seen      | S    | eye         |
| unread    | u    | eye-slash   |
| trashed   | T    | trash       |
| attach    | a    | paperclip   |
| encrypted | x    | lock        |
| signed    | s    | certificate |

#+name: mu4e-fancy-marks-gen
#+header: :tangle no :exports none :results value :cache yes
#+begin_src emacs-lisp :var table=mu4e-fancy-marks-tbl
(mapconcat (lambda (line)
             (let ((mark (car line))
                   (flag (cadr line))
                   (icon (caddr line)))
               (format "mu4e-headers-%s-mark `(\"%s\" . ,(all-the-icons-faicon \"%s\" :height 0.8))"
                       mark
                       flag
                       icon)))
           table
           "\n")
#+end_src

#+RESULTS[c6ed5d4bec4c10339a7de52a70822af74d782e62]: mu4e-fancy-marks-gen
#+begin_example
mu4e-headers-draft-mark `("D" . ,(all-the-icons-faicon "pencil" :height 0.8))
mu4e-headers-flagged-mark `("F" . ,(all-the-icons-faicon "flag" :height 0.8))
mu4e-headers-new-mark `("N" . ,(all-the-icons-faicon "rss" :height 0.8))
mu4e-headers-passed-mark `("P" . ,(all-the-icons-faicon "check" :height 0.8))
mu4e-headers-replied-mark `("R" . ,(all-the-icons-faicon "reply" :height 0.8))
mu4e-headers-seen-mark `("S" . ,(all-the-icons-faicon "eye" :height 0.8))
mu4e-headers-unread-mark `("u" . ,(all-the-icons-faicon "eye-slash" :height 0.8))
mu4e-headers-trashed-mark `("T" . ,(all-the-icons-faicon "trash" :height 0.8))
mu4e-headers-attach-mark `("a" . ,(all-the-icons-faicon "paperclip" :height 0.8))
mu4e-headers-encrypted-mark `("x" . ,(all-the-icons-faicon "lock" :height 0.8))
mu4e-headers-signed-mark `("s" . ,(all-the-icons-faicon "certificate" :height 0.8))
#+end_example

Let’s enable them and set them:
#+name: mu4e-fancy-marks
#+begin_src emacs-lisp :tangle no
(setq mu4e-use-fancy-chars t
      <<mu4e-fancy-marks-gen()>>)
#+end_src

**** View mode
#+name: mu4e-view-mode
#+begin_src emacs-lisp :tangle no
(add-hook 'mu4e-view-mode-hook (lambda () (visual-fill-column-mode)))
#+end_src

**** Contexts
Set contexts
#+begin_src emacs-lisp
(defun dorneanu/set-mu4e-contexts ()
  "Set mail contexts for mu4e"
  (interactive)
  (setq mu4e-contexts
        `( ,(make-mu4e-context
             :name "gmail"
             :enter-func (lambda () (mu4e-message "Entering gmail context"))
             :leave-func (lambda () (mu4e-message "Leaving gmail context"))
             ;; we match based on the contact-fields of the message
             :match-func
             (lambda (msg)
               (when msg
                 (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/gmail/personal/username"))
                     (user-full-name    . "Cyneox")
                     (smtpmail-smtp-user . ,(password-store-get "mail/gmail/personal/username"))
                     (smtpmail-smtp-server  . "smtp.gmail.com")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-compose-signature . "Cyneox via Gmail")
                     (mu4e-drafts-folder  . "/[Gmail]/drafts")
                     (mu4e-sent-folder  . "/[Gmail]/sent")
                     (mu4e-refile-folder  . "/[Gmail]/All Mail")
                     (mu4e-trash-folder  . "/[Gmail]/bin")))
           ,(make-mu4e-context
             :name "variomedia"
             :enter-func (lambda () (mu4e-message "Switch to the variomedia context"))
             :match-func
            (lambda (msg)
               (when msg
                 (string-prefix-p "/variomedia" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/personal/username"))
                     (user-full-name    . "Victor Dorneanu")
                     (smtpmail-smtp-user . ,(password-store-get "mail/personal/username")) (smtpmail-smtp-server  . "smtp.variomedia.de")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-compose-signature . "Victor via Emacs")
                     (mu4e-drafts-folder  . "/variomedia/drafts")
                     (mu4e-sent-folder  . "/variomedia/sent")
                     (mu4e-trash-folder  . "/variomedia/bin")))
           ,(make-mu4e-context
             :name "cashlink"
             :enter-func (lambda () (mu4e-message "Switch to the cashlink context"))
             :match-func
             (lambda (msg)
               (when msg
                 (string-prefix-p "/cashlink" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . ,(password-store-get "mail/gmail/work/username"))
                     (user-full-name    . "Victor Dorneanu")
                     (smtpmail-smtp-user . ,(password-store-get "mail/gmail/work/username"))
                     (smtpmail-smtp-server  . "smtp.gmail.com")
                     (smtpmail-smtp-service . 465)
                     (smtpmail-stream-type  . ssl)
                     (mu4e-drafts-folder  . "/cashlink/drafts")
                     (mu4e-sent-folder  . "/cashlink/sent")
                     (mu4e-trash-folder  . "/cashlink/bin")
                     (mu4e-compose-signature . ,(concat "Victor Dorneanu\n" "Security Architect @ Cashlink\n"))
                     ))))
  )

#+end_src

#+RESULTS:
: dorneanu/set-mu4e-contexts
**** Reply
I often want to reply without the original message:
#+begin_src emacs-lisp
;; From https://github.com/djcb/mu/issues/2345
;; (after! mu4e
;;   (defun dorneanu/mu4e-delete-citation ()
;;     (delete-region (point) (point-max)))

;;   (defun dorneanu/mu4e-reply (prefix)
;;     (interactive "P")
;;     (setq mu4e-compose-cite-function (if prefix
;;                                          #'dorneanu/mu4e-delete-citation
;;                                        #'message-cite-original-without-signature))
;;     (mu4e-compose-reply))

;;   (define-key mu4e-view-mode-map "R" #'dorneanu/mu4e-reply)
;;   (define-key mu4e-headers-mode-map "R" #'dorneanu/mu4e-reply)
;;   )
#+end_src
** Hydra
Some inspirations from https://github.com/rememberYou/.emacs.d/blob/master/config.org

#+begin_src emacs-lisp
(use-package hydra
  :straight t)

(use-package hydra-examples
  :ensure nil)


(use-package major-mode-hydra
  :straight t
  :after hydra
  :preface
  (defun with-alltheicon (icon str &optional height v-adjust face)
    "Display an icon from all-the-icon."
    (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-faicon (icon str &optional height v-adjust face)
    "Display an icon from Font Awesome icon."
    (s-concat (all-the-icons-faicon icon ':v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-fileicon (icon str &optional height v-adjust face)
    "Display an icon from the Atom File Icons package."
    (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

  (defun with-octicon (icon str &optional height v-adjust face)
    "Display an icon from the GitHub Octicons."
    (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str)))
#+end_src

*** Hydra / Windows

Group window-related commands.

#+begin_src emacs-lisp
  (pretty-hydra-define hydra-windows
    (:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "windows" "Windows" 1 -0.05))
    ("Window"
     (("b" balance-windows "balance")
      ("c" centered-window-mode "center")
      ("i" enlarge-window "heighten")
      ("j" shrink-window-horizontally "narrow")
      ("k" shrink-window "lower")
      ("u" winner-undo "undo")
      ("r" winner-redo "redo")
      ("l" enlarge-window-horizontally "widen")
      ("s" switch-window-then-swap-buffer "swap" :color teal))
     "Zoom"
     (("-" text-scale-decrease "out")
      ("+" text-scale-increase "in")
      ("=" (text-scale-increase 0) "reset"))))
#+end_src
*** Hydra / Window Nav
From https://github.com/doomemacs/doomemacs/blob/master/modules/ui/hydra/autoload/windows.el

#+begin_src emacs-lisp
(defhydra +hydra/window-nav (:hint nil)
  "
          Split: _v_ert  _s_:horz
         Delete: _c_lose  _o_nly
  Switch Window: _h_:left  _j_:down  _k_:up  _l_:right  _u_:undo  _r_:redo
        Buffers: _p_revious  _n_ext  _b_:select  _f_ind-file
         Resize: _H_:splitter left  _J_:splitter down  _K_:splitter up  _L_:splitter right
           Move: _a_:up  _z_:down  _i_menu
"
  ("z" scroll-up-line)
  ("a" scroll-down-line)
  ("i" idomenu)

  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("u" winner-undo)
  ("r" winner-redo)

  ("p" previous-buffer)
  ("n" next-buffer)
  ("b" switch-to-buffer)
  ("f" find-file)

  ("s" split-window-below)
  ("v" split-window-right)

  ("c" delete-window)
  ("o" delete-other-windows)

  ("H" hydra-move-splitter-left)
  ("J" hydra-move-splitter-down)
  ("K" hydra-move-splitter-up)
  ("L" hydra-move-splitter-right)

  ("+" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("=" (text-scale-increase 0) "reset")

  ("q" nil))
#+end_src
*** Hydra / Flyspell
#+begin_src emacs-lisp
(defhydra flyspell-hydra ()
  "
Spell Commands^^           Add To Dictionary^^              Other
--------------^^---------- -----------------^^------------- -----^^---------------------------
[_b_] check whole buffer   [_B_] add word to dict (buffer)  [_t_] toggle spell check
[_r_] check region         [_G_] add word to dict (global)  [_q_] exit
[_d_] change dictionary    [_S_] add word to dict (session) [_Q_] exit and disable spell check
[_n_] next error
[_c_] correct before point
[_s_] correct at point
"
  ("B" nil)
  ("b" flyspell-buffer)
  ("r" flyspell-region)
  ("d" ispell-change-dictionary)
  ("G" nil)
  ("n" flyspell-goto-next-error)
  ("c" flyspell-correct-wrapper)
  ("Q" flyspell-mode :exit t)
  ("q" nil :exit t)
  ("S" nil)
  ("s" flyspell-correct-at-point)
  ("t" nil))
#+end_src
*** Hydra / ORG
**** hydra-org-jump
From [[https://sriramkswamy.github.io/dotemacs/]]

#+begin_src emacs-lisp
(defhydra sk/hydra-org-jump (:color pink :hint nil)
  "
 ^Outline^          ^Item^   ^Table^   ^Block^   ^Link^
 ^^^^^^^^^^^-------------------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _u_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _p_ ^ ^   ^ ^ _P_ ^ ^    _q_ quit
 _h_ ^+^ _l_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^   _b_ ^+^ _f_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _d_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _n_ ^ ^   ^ ^ _N_ ^ ^
"
  ("j" outline-next-visible-heading)
  ("k" outline-previous-visible-heading)
  ("l" org-down-element)
  ("h" org-up-element)
  ("J" org-forward-heading-same-level)
  ("K" org-backward-heading-same-level)
  ("u" org-next-item)
  ("d" org-previous-item)
  ("f" org-table-next-field)
  ("b" org-table-previous-field)
  ("n" org-next-block)
  ("p" org-previous-block)
  ("N" org-next-link)
  ("P" org-previous-link)
  ("q" nil :color blue))
#+end_src
**** hydra-org-babel-transient
#+begin_src emacs-lisp :tangle no
(defhydra org-babel-transient ()
  "
^Navigate^                    ^Interact
^^^^^^^^^^^------------------------------------------
[_t_/_s_] navigate src blocs  [_x_] execute src block
[_g_]^^   goto named block    [_'_] edit src block
[_z_]^^   recenter screen     [_q_] quit
"
  ("q" nil :exit t)
  ("t" org-babel-next-src-block)
  ("s" org-babel-previous-src-block)
  ("g" org-babel-goto-named-src-block)
  ("z" recenter-top-bottom)
  ("x" org-babel-execute-maybe)
  ("'" org-edit-special :exit t))
#+end_src
*** Hydra / merge
Group Merge commands.

#+begin_src emacs-lisp
(pretty-hydra-define hydra-merge
  (:hint nil :color pink :quit-key "q" :title (with-octicon "mark-github" "Magit" 1 -0.05))
  ("Move"
   (("n" smerge-next "next")
    ("p" smerge-prev "previous"))
   "Keep"
   (("RET" smerge-keep-current "current")
    ("a" smerge-keep-all "all")
    ("b" smerge-keep-base "base")
    ("l" smerge-keep-lower "lower")
    ("u" smerge-keep-upper "upper"))
   "Diff"
   (("<" smerge-diff-base-upper "upper/base")
    ("=" smerge-diff-upper-lower "upper/lower")
    (">" smerge-diff-base-lower "base/lower")
    ("R" smerge-refine "redefine")
    ("E" smerge-ediff "ediff"))
   "Other"
   (("C" smerge-combine-with-next "combine")
    ("r" smerge-resolve "resolve")
    ("k" smerge-kill-current "kill current"))))
#+end_src
jk
*** Hydra / smerge
From https://github.com/dakra/dmacs/blob/nil/init.org

#+begin_src emacs-lisp
(use-package smerge-mode
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (hydra-smerge/body))))
  :config
  (require 'hydra)
  (defhydra hydra-smerge
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("q" nil "cancel" :color blue)))
#+end_src
*** Hydra / modeline                                                 :todo:
#+begin_src emacs-lisp
(pretty-hydra-define hydra-modeline
  (:title "Modeline" :color amaranth :quit-key ("q" "C-g"))
   ("Icon"
    (("i" (setq doom-modeline-icon (not doom-modeline-icon))
      "display icons" :toggle doom-modeline-icon)
     ("u" (setq doom-modeline-unicode-fallback (not doom-modeline-unicode-fallback))
      "unicode fallback" :toggle doom-modeline-unicode-fallback)
     ("m" (setq doom-modeline-major-mode-icon (not doom-modeline-major-mode-icon))
      "major mode" :toggle doom-modeline-major-mode-icon)
     ("c" (setq doom-modeline-major-mode-color-icon (not doom-modeline-major-mode-color-icon))
      "colorful major mode" :toggle doom-modeline-major-mode-color-icon)
     ("s" (setq doom-modeline-buffer-state-icon (not doom-modeline-buffer-state-icon))
      "buffer state" :toggle doom-modeline-buffer-state-icon)
     ("o" (setq doom-modeline-buffer-modification-icon (not doom-modeline-buffer-modification-icon))
      "modification" :toggle doom-modeline-buffer-modification-icon)
     ("x" (setq doom-modeline-time-icon (not doom-modeline-time-icon))
      "time" :toggle doom-modeline-time-icon)
     ("v" (setq doom-modeline-modal-icon (not doom-modeline-modal-icon))
      "modal" :toggle doom-modeline-modal-icon))
    "Segment"
    (("g h" (setq doom-modeline-hud (not doom-modeline-hud))
      "hud" :toggle doom-modeline-hud)
     ("g m" (setq doom-modeline-minor-modes (not doom-modeline-minor-modes))
      "minor modes" :toggle doom-modeline-minor-modes)
     ("g w" (setq doom-modeline-enable-word-count (not doom-modeline-enable-word-count))
      "word count" :toggle doom-modeline-enable-word-count)
     ("g e" (setq doom-modeline-buffer-encoding (not doom-modeline-buffer-encoding))
      "encoding" :toggle doom-modeline-buffer-encoding)
     ("g i" (setq doom-modeline-indent-info (not doom-modeline-indent-info))
      "indent" :toggle doom-modeline-indent-info)
     ("g c" (setq doom-modeline-display-misc-in-all-mode-lines (not doom-modeline-display-misc-in-all-mode-lines))
      "misc info" :toggle doom-modeline-display-misc-in-all-mode-lines)
     ("g l" (setq doom-modeline-lsp (not doom-modeline-lsp))
      "lsp" :toggle doom-modeline-lsp)
     ("g k" (setq doom-modeline-workspace-name (not doom-modeline-workspace-name))
      "workspace" :toggle doom-modeline-workspace-name)
     ("g g" (setq doom-modeline-github (not doom-modeline-github))
      "github" :toggle doom-modeline-github)
     ("g n" (setq doom-modeline-gnus (not doom-modeline-gnus))
      "gnus" :toggle doom-modeline-gnus)
     ("g u" (setq doom-modeline-mu4e (not doom-modeline-mu4e))
      "mu4e" :toggle doom-modeline-mu4e)
     ("g r" (setq doom-modeline-irc (not doom-modeline-irc))
      "irc" :toggle doom-modeline-irc)
     ("g f" (setq doom-modeline-irc-buffers (not doom-modeline-irc-buffers))
      "irc buffers" :toggle doom-modeline-irc-buffers)
     ("g s" (progn
              (setq doom-modeline-checker-simple-format (not doom-modeline-checker-simple-format))
              (and (bound-and-true-p flycheck-mode) (flycheck-buffer)))
      "simple checker" :toggle doom-modeline-checker-simple-format)
     ("g t" (setq doom-modeline-time (not doom-modeline-time))
      "time" :toggle doom-modeline-time)
     ("g v" (setq doom-modeline-env-version (not doom-modeline-env-version))
      "version" :toggle doom-modeline-env-version))
    "Style"
    (("a" (setq doom-modeline-buffer-file-name-style 'auto)
      "auto"
      :toggle (eq doom-modeline-buffer-file-name-style 'auto))
     ("b" (setq doom-modeline-buffer-file-name-style 'buffer-name)
      "buffer name"
      :toggle (eq doom-modeline-buffer-file-name-style 'buffer-name))
     ("f" (setq doom-modeline-buffer-file-name-style 'file-name)
      "file name"
      :toggle (eq doom-modeline-buffer-file-name-style 'file-name))
     ("t u" (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
      "truncate upto project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-upto-project))
     ("t f" (setq doom-modeline-buffer-file-name-style 'truncate-from-project)
      "truncate from project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-from-project))
     ("t w" (setq doom-modeline-buffer-file-name-style 'truncate-with-project)
      "truncate with project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-with-project))
     ("t e" (setq doom-modeline-buffer-file-name-style 'truncate-except-project)
      "truncate except project"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-except-project))
     ("t r" (setq doom-modeline-buffer-file-name-style 'truncate-upto-root)
      "truncate upto root"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-upto-root))
     ("t a" (setq doom-modeline-buffer-file-name-style 'truncate-all)
      "truncate all"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-all))
     ("t n" (setq doom-modeline-buffer-file-name-style 'truncate-nil)
      "truncate none"
      :toggle (eq doom-modeline-buffer-file-name-style 'truncate-nil))
     ("r f" (setq doom-modeline-buffer-file-name-style 'relative-from-project)
      "relative from project"
      :toggle (eq doom-modeline-buffer-file-name-style 'relative-from-project))
     ("r t" (setq doom-modeline-buffer-file-name-style 'relative-to-project)
      "relative to project"
      :toggle (eq doom-modeline-buffer-file-name-style 'relative-to-project)))
    "Project Detection"
    (("p a" (setq doom-modeline-project-detection 'auto)
      "auto"
      :toggle (eq doom-modeline-project-detection 'auto))
     ("p f" (setq doom-modeline-project-detection 'ffip)
      "ffip"
      :toggle (eq doom-modeline-project-detection 'ffip))
     ("p i" (setq doom-modeline-project-detection 'projectile)
      "projectile"
      :toggle (eq doom-modeline-project-detection 'projectile))
     ("p p" (setq doom-modeline-project-detection 'project)
      "project"
      :toggle (eq doom-modeline-project-detection 'project))
     ("p n" (setq doom-modeline-project-detection nil)
      "disable"
      :toggle (eq doom-modeline-project-detection nil)))
    "Misc"
    (("n" (progn
            (message "Fetching GitHub notifications...")
            (run-with-timer 300 nil #'doom-modeline--github-fetch-notifications)
            (browse-url "https://github.com/notifications"))
      "github notifications" :exit t)
     ("e" (cond ((bound-and-true-p flycheck-mode)
                 (flycheck-list-errors))
                ((bound-and-true-p flymake-mode)
                 (flymake-show-diagnostics-buffer)))
      "list errors" :exit t)
     ("w" (if (bound-and-true-p grip-mode)
              (grip-browse-preview)
            (message "Not in preview"))
      "browse preview" :exit t)
     ("z h" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-height
                     (symbol-value 'doom-modeline-height)))
      "set height" :exit t)
     ("z w" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-bar-width
                     (symbol-value 'doom-modeline-bar-width)))
      "set bar width" :exit t)
     ("z g" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-github-interval
                     (symbol-value 'doom-modeline-github-interval)))
      "set github interval" :exit t)
     ("z n" (read-from-minibuffer
             "Eval: "
             (format "(setq %s %s)"
                     'doom-modeline-gnus-timer
                     (symbol-value 'doom-modeline-gnus-timer)))
      "set gnus interval" :exit t))))

#+end_src
*** Hydra / unicode
From https://github.com/dakra/dmacs/blob/nil/init.org
Add here circled digits like: ②
#+begin_src emacs-lisp
(defun dakra/insert-unicode (unicode-name)
  "Same as C-x 8 enter UNICODE-NAME."
  (insert-char (gethash unicode-name (ucs-names))))

(defhydra dakra/hydra-unicode (:color blue :hint nil)
  "
     Unicode  _c_ €   _a_ ä   _A_ Ä
              _d_ °   _o_ ö   _O_ Ö
              _e_ €   _u_ Ü   _U_ Ü
              _p_ £   _s_ ß
              _m_ µ
              _r_ →
     "
  ("a" (dakra/insert-unicode "LATIN SMALL LETTER A WITH DIAERESIS"))
  ("A" (dakra/insert-unicode "LATIN CAPITAL LETTER A WITH DIAERESIS"))
  ("o" (dakra/insert-unicode "LATIN SMALL LETTER O WITH DIAERESIS")) ;;
  ("O" (dakra/insert-unicode "LATIN CAPITAL LETTER O WITH DIAERESIS"))
  ("u" (dakra/insert-unicode "LATIN SMALL LETTER U WITH DIAERESIS")) ;;
  ("U" (dakra/insert-unicode "LATIN CAPITAL LETTER U WITH DIAERESIS"))
  ("s" (dakra/insert-unicode "LATIN SMALL LETTER SHARP S"))
  ("c" (dakra/insert-unicode "COPYRIGHT SIGN"))
  ("d" (dakra/insert-unicode "DEGREE SIGN"))
  ("e" (dakra/insert-unicode "EURO SIGN"))
  ("p" (dakra/insert-unicode "POUND SIGN"))
  ("r" (dakra/insert-unicode "RIGHTWARDS ARROW"))
  ("m" (dakra/insert-unicode "MICRO SIGN")))
#+end_src
** Icons

** empv
Watch YouTube videos from Emacs using ~mpv~. I also learned you can save the
position and resume whenever the same video is played again (read [[https://unix.stackexchange.com/questions/414639/is-it-possible-to-continue-movies-from-where-one-leaves-in-mpv-as-can-be-done-in][here]]).

#+begin_src emacs-lisp
(use-package empv
  :straight t
  :after (embark browse-url)
  :config

  (setq empv-invidious-instance "https://yewtu.be/")
  (add-to-list 'empv-mpv-args "--ytdl-format=best")

  (defun dorneanu/empv-play-url (url &optional _)
    (interactive)
    (empv-toggle-video)
    (empv-play url)))

;; Handle youtube links using mpv
(with-eval-after-load 'browse-url
  (add-to-list 'browse-url-handlers (cons "^https://\\(www.\\)?youtube.com\\|https://youtu.be" #'dorneanu/empv-play-url)))

#+end_src

** COMMENT Nov
Nov is a major-mode for reading EPUB files within Emacs. Since I have
it, I don’t need any other Epub reader on my computer! Plus this one
is customizable and programmable, why would I use any other EPUB
reader?
#+begin_src emacs-lisp
(use-package nov
  :straight (:build t)
  :defer t
  :mode ("\\.epub\\'" . nov-mode)
  :general
  (phundrak/evil
    :keymaps 'nov-mode-map
    :packages 'nov
    "c"   #'nov-previous-document
    "t"   #'nov-scroll-up
    "C-d" #'nov-scroll-up
    "s"   #'nov-scroll-down
    "C-u" #'nov-scroll-down
    "r"   #'nov-next-document
    "gm"  #'nov-display-metadata
    "gn"  #'nov-next-document
    "gp"  #'nov-previous-document
    "gr"  #'nov-render-document
    "gt"  #'nov-goto-toc
    "gv"  #'nov-view-source
    "gV"  #'nov-view-content-source)
  :config
  (setq nov-text-width 95))
#+end_src

** PDF Tools
~pdf-tools~ enables PDF support for Emacs, much better than its built-in
support with DocView. Aside from the classical settings such as
keybinds, I also enable the midnight colours by default; think of it
as an equivalent of Zathura’s recolour feature which kind of enables a
dark mode for PDFs.
#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :magic ("%PDF" . pdf-view-mode)
  :straight (:build t)
  :hook (pdf-tools-enabled . pdf-view-midnight-minor-mode)
  :general
  (phundrak/evil
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "y"   #'pdf-view-kill-ring-save
    "t"   #'evil-collection-pdf-view-next-line-or-next-page
    "s"   #'evil-collection-pdf-view-previous-line-or-previous-page)
  (phundrak/major-leader-key
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "a"  '(:ignore t :which-key "annotations")
    "aD" #'pdf-annot-delete
    "at" #'pdf-annot-attachment-dired
    "ah" #'pdf-annot-add-highlight-markup-annotation
    "al" #'pdf-annot-list-annotations
    "am" #'pdf-annot-markup-annotation
    "ao" #'pdf-annot-add-strikeout-markup-annotation
    "as" #'pdf-annot-add-squiggly-markup-annotation
    "at" #'pdf-annot-add-text-annotation
    "au" #'pdf-annot-add-underline-markup-annotation

    "f"  '(:ignore t :which-key "fit")
    "fw" #'pdf-view-fit-width-to-window
    "fh" #'pdf-view-fit-height-to-window
    "fp" #'pdf-view-fit-page-to-window

    "s"  '(:ignore t :which-key "slice/search")
    "sb" #'pdf-view-set-slice-from-bounding-box
    "sm" #'pdf-view-set-slice-using-mouse
    "sr" #'pdf-view-reset-slice
    "ss" #'pdf-occur

    "o"  'pdf-outline
    "m"  'pdf-view-midnight-minor-mode)
  :config
  (with-eval-after-load 'pdf-view
    (csetq pdf-view-midnight-colors '("#d8dee9" . "#2e3440"))))
#+end_src

One thing ~pdf-tools~ doesn’t handle is restoring the PDF to the last
point it was visited --- in other words, open the PDF where I last
left it.
#+begin_src emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :defer t
  :straight (:build t)
  :hook (pdf-view-mode . pdf-view-restore-mode)
  :config
  (setq pdf-view-restore-filename (expand-file-name ".tmp/pdf-view-restore"
                                                    user-emacs-directory)))
#+end_src

** Project Management
*** Magit
Magit is an awesome wrapper around Git for Emacs! Very often, I go
from disliking to really hating Git GUI clients because they often
obfuscate which Git commands are used to make things happen. Such a
thing doesn’t happen with Magit, it’s pretty transparent, but it still
provides some awesome features and visualizations of what you are
doing and what Git is doing! In short, I absolutely love it!
#+begin_src emacs-lisp
(use-package magit
  :straight (:build t)
  :defer t
  :init
  (setq forge-add-default-bindings nil)
  :config
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source)
  <<magit-angular-keywords-highlight>>
  (csetq magit-clone-default-directory "~/fromGIT/"
         magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (with-eval-after-load 'evil-collection
    (phundrak/evil
      :packages '(evil-collection magit)
      :keymaps '(magit-mode-map magit-log-mode-map magit-status-mode-map)
      :states 'normal
      "t" #'magit-tag
      "s" #'magit-stage))
  :general
  (:keymaps '(git-rebase-mode-map)
   :packages 'magit
   "C-t" #'evil-next-line
   "C-s" #'evil-previous-line)
  (phundrak/major-leader-key
    :keymaps 'git-rebase-mode-map
    :packages 'magit
    "," #'with-editor-finish
    "k" #'with-editor-cancel
    "a" #'with-editor-cancel)
  (phundrak/leader-key
    :infix   "g"
    :packages 'magit
    ""   '(:ignore t :wk "git")
    "b"  #'magit-blame
    "c"  #'magit-clone
    "d"  #'magit-dispatch
    "i"  #'magit-init
    "s"  #'magit-status
    "l"  #'magit-log
    "y"  #'my/yadm
    "S"  #'magit-stage-file
    "U"  #'magit-unstage-file
    "f"  '(:ignore t :wk "file")
    "fd" #'magit-diff
    "fc" #'magit-file-checkout
    "fl" #'magit-file-dispatch
    "fF" #'magit-find-file))
#+end_src

There is currently a bug in Emacs TRAMP as described in issue [[https://github.com/magit/magit/issues/4720][#4720]] of
Magit and bug [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=62093][62093]] of Emacs. A workaround is to redefine the old
=tramp-send-command= function through an advice.
#+begin_src emacs-lisp
(defun my--tramp-send-command--workaround-stty-icanon-bug (conn-vec orig-command &rest args)
  "See: https://github.com/magit/magit/issues/4720"
  (let ((command
         (if (string= "stty -icrnl -icanon min 1 time 0" orig-command)
             "stty -icrnl"
           orig-command)))
    (append (list conn-vec command) args)))

(defun my--tramp-send-command--workaround-stty-icanon-bug--filter-args (args)
  (apply #'my--tramp-send-command--workaround-stty-icanon-bug args))

(advice-add 'tramp-send-command :filter-args
            #'my--tramp-send-command--workaround-stty-icanon-bug--filter-args)
#+end_src

I also want to highlight these angular-style keywords in commit messages.
#+name: magit-angular-keywords-highlight
#+begin_src emacs-lisp :tangle no
(defun my/magit-log-highlight-angular-keywords (_rev msg)
  "Highlight angular-style keywords in commit messages."
  (let ((boundary 0))
    (when (string-match (rx (seq (or "feat" "fix" "docs" "style" "refactor"
                                     "perf" "test" "chore")
                                 (* "(" (* (not ")")) ")")
                                 ":"))
                        msg
                        boundary)
        (setq boundary (match-end 0))
        (magit--put-face (match-beginning 0) boundary
                         'magit-keyword msg)))
  msg)

(advice-add #'magit-log-propertize-keywords
            :after
            #'my/magit-log-highlight-angular-keywords)
#+end_src

[[https://github.com/alphapapa][Alphapapa]] also created an awesome package for Magit: magit-todos which
display in the Magit buffer a list of TODOs found in the current
project to remind you of what to do next.

First, let’s setup our todo keywords with =hl-todo=. A good few todo
keywords are already defined in the =hl-todo-keyword-faces= variable.
Why not use them? =hl-todo-mode= enables fontlock highlight of these
keywords in a buffer. Let’s enable this mode globally.
#+begin_src emacs-lisp
;; (use-package hl-todo
;;   :defer t
;;   :straight (:build t)
;;   :init (global-hl-todo-mode 1)
;;   :general
;;   (phundrak/leader-key
;;     :packages '(hl-todo)
;;     :infix "c"
;;     ""  '(:ignore t :which-key "todos")
;;     "n" #'hl-todo-next
;;     "p" #'hl-todo-previous))
#+end_src

We can now configure properly =magit-todos=. Notice my custom function
hooked to =magit-mode-hook=. This is because this package tries to find
TODOs in all files in the current project, and my yadm repository’s
root is my =$HOME=. So, yeah, no =magit-todos= in yadm.
#+begin_src emacs-lisp
;; (use-package magit-todos
;;   :straight (:build t)
;;   :after (magit hl-todo)
;;   :init
;;   (with-eval-after-load 'magit
;;    (defun my/magit-todos-if-not-yadm ()
;;      "Deactivate magit-todos if in yadm Tramp connection.
;; If `magit--default-directory' points to a yadm Tramp directory,
;; deactivate `magit-todos-mode', otherwise enable it."
;;      (if (string-prefix-p "/yadm:" magit--default-directory)
;;          (magit-todos-mode -1)
;;        (magit-todos-mode +1)))
;;    (add-hook 'magit-mode-hook #'my/magit-todos-if-not-yadm))
;;   :config
;;   (csetq magit-todos-ignore-case t))
#+end_src
"*** Forge
Forge acts as an interface for GitHub, GitLab, and Bitbucket inside
Magit. A lot of possibilities are present, you can read issues and
pull requests, create them, and fork projects among other things.

*NOTE*: Make sure to configure a GitHub token before using this
 package!
- [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][Token Creation]]
- [[https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started][Getting started]]
#+begin_src emacs-lisp
;; (use-package forge
;;   :after magit
;;   :straight (:build t)
;;   :init
;;   (evil-collection-forge-setup)
;;   :general
;;   (phundrak/major-leader-key
;;     :keymaps 'forge-topic-mode-map
;;     "c"  #'forge-create-post
;;     "e"  '(:ignore t :which-key "edit")
;;     "ea" #'forge-edit-topic-assignees
;;     "ed" #'forge-edit-topic-draft
;;     "ek" #'forge-delete-comment
;;     "el" #'forge-edit-topic-labels
;;     "em" #'forge-edit-topic-marks
;;     "eM" #'forge-merge
;;     "en" #'forge-edit-topic-note
;;     "ep" #'forge-edit-post
;;     "er" #'forge-edit-topic-review-requests
;;     "es" #'forge-edit-topic-state
;;     "et" #'forge-edit-topic-title))
#+end_src
**** browse-at-remote
#+begin_src emacs-lisp
(use-package browse-at-remote
  :straight t
  :bind (("C-c G" . browse-at-remote))
  :general
  (phundrak/leader-key
    :infix   "g"
    :packages 'magit
    ""   '(:ignore t :wk "git")
    "y"  #'browse-at-remote-kill
    "o" #'browse-at-remote))
#+end_src
**** diff-hl-mode
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (prog-mode . diff-hl-mode)
   (org-mode . diff-hl-mode)
   (dired-mode . diff-hl-dired-mode)))
#+end_src
*** Projectile
First, I need to install ~ripgrep~, a faster reimplementation of ~grep~,
which will be very useful when managing projects.
#+begin_src emacs-lisp
(use-package ripgrep
  :if (executable-find "rg")
  :straight (:build t)
  :defer t)
#+end_src

Now, I can use projectile, which is sort of the /de facto/ standard
project manager in Emacs. I know there’s ~project.el~, but… Eh… I’m used
to projectile.
#+begin_src emacs-lisp
(use-package projectile
  :straight t
  :diminish projectile-mode
  ;; :custom ((projectile-completion-system 'default))
  :config
  (projectile-mode)
  ;; (setq projectile-completion-system 'default)
  ;; (setq projectile-switch-project-action #'projectile-dired)

  (add-to-list 'projectile-ignored-projects "~/")
  (add-to-list 'projectile-globally-ignored-files "node_modules")
  (add-to-list 'projectile-globally-ignored-files ".cache")
  (add-to-list 'projectile-globally-ignored-files "_cache")
  (add-to-list 'projectile-globally-ignored-files "~")
  (add-to-list 'projectile-globally-ignored-files "^#")
  (add-to-list 'projectile-globally-ignored-directories "^node_modules$")
  :general
  (phundrak/leader-key
    "p" '(:keymap projectile-command-map :which-key "projectile")))
#+end_src

And of course, there is a counsel package dedicated to projectile.
#+begin_src emacs-lisp
;; (use-package counsel-projectile
;;   :straight (:build t)
;;   :after (counsel projectile)
;;   :config (counsel-projectile-mode))
#+end_src

*** Recentf
The built-in package ~recentf~ keeps track of recently opened files. But
by default, it only follows the twenty most recent files, that not
nearly enough for me, so I raise it to two hundred. I also don’t want
recentf to follow the Elfeed database, so I add it to the list of
excluded files.
#+begin_src emacs-lisp
(use-package recentf
  :straight (:build t :type built-in)
  :custom ((recentf-max-saved-items 2000))
  :config
  (add-all-to-list 'recentf-exclude
                   `(,(rx (* any)
                          (or "elfeed-db"
                              "eln-cache"
                              "conlanging/content"
                              "org/config"
                              "/Mail/Sent"
                              ".cache/")
                          (* any)
                          (? (or "html" "pdf" "tex" "epub")))
                     ,(rx (* any)
                          ".elc"
                          eol)
                     ,(rx "/"
                          (or "rsync" "ssh" "tmp" "yadm" "sudoedit" "sudo")
                          (* any)))))
#+end_src

*** ejira
Still not convinced, but let's activate it:

#+begin_src emacs-lisp
(use-package jiralib2
  :straight t
  :commands (ejira-mode)
  :init
  (defun dorneanu/setup-jira ()
    (interactive)
    (setq jiralib2-url              (password-store-get "emacs/ejira-url")
          jiralib2-auth             'token
          jiralib2-token             (password-store-get "emacs/ejira-token")
          jiralib2-user-login-name  (password-store-get "emacs/ejira-user"))))



(use-package ejira
  :straight (ejira :build t
                      :type git
                      :host github
                      :repo "nyyManni/ejira")
  :after (jiralib2)
  :init
  (setq
   ;; NOTE, this directory needs to be in `org-agenda-files'`
   ejira-org-directory       "~/work/jira"
   ejira-projects            '("QDS" "INI")

   ejira-priorities-alist    '(("Highest" . ?A)
                               ("High"    . ?B)
                               ("Medium"  . ?C)
                               ("Low"     . ?D)
                               ("Lowest"  . ?E))
   ejira-todo-states-alist   '(("To Do"       . 1)
                               ("In Progress" . 2)
                               ("Done"        . 4)))
  ;; Update my jira projects
  (defun dorneanu/jira-update-projects ()
    (interactive)
    (let ((org-agenda-files nil))
      (ejira-update-my-projects)))


  :config
  ;; Tries to auto-set custom fields by looking into /editmeta
  ;; of an issue and an epic.
  (add-hook 'jiralib2-post-login-hook #'ejira-guess-epic-sprint-fields)

  ;; Make the issues visisble in your agenda by adding `ejira-org-directory'
  ;; into your `org-agenda-files'.
  (add-to-list 'org-agenda-files ejira-org-directory))

#+end_src
*** wakatime
#+begin_src emacs-lisp
(use-package wakatime-mode
  :straight t
  :config
  (setq
   ;; TODO: Need to change these to something more flexible/portable
   wakatime-python-bin "/home/victor/.pyenv/versions/emacs/bin/python"
   wakatime-cli-path "/home/victor/.pyenv/versions/emacs/bin/wakatime")
  (global-wakatime-mode))
#+end_src
*** WIP jira

** Screenshot
~screenshot.el~ is a nice utility package made by TEC. It allows the
user to take a screenshot of a specific area of a buffer and make it
look nice.
#+begin_src emacs-lisp
(use-package screenshot
  :defer t
  :straight (screenshot :build t
                        :type git
                        :host github
                        :repo "tecosaur/screenshot")
  :config (load-file (locate-library "screenshot.el"))
  :general
  (phundrak/leader-key
    :infix "a"
    :packages '(screenshot)
    "S" #'screenshot))
#+end_src

** Shells
*** Shell-pop
Shell-pop allows the user to easily call for a new shell in a pop-up
buffer.
#+begin_src emacs-lisp
(use-package shell-pop
  :defer t
  :straight (:build t)
  :custom
  (shell-pop-default-directory "/home/phundrak")
  (shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda () (eshell shell-pop-term-shell)))))
  (shell-pop-window-size 30)
  (shell-pop-full-span nil)
  (shell-pop-window-position "bottom")
  (shell-pop-autocd-to-working-dir t)
  (shell-pop-restore-window-configuration t)
  (shell-pop-cleanup-buffer-at-process-exit t))
#+end_src

*** COMMENT VTerm
VTerm gives Emacs access to regular shells with an almost regular
emulator. Be aware you will most likely need to hit ~C-c~ twice to send
an interrupt signal.
#+begin_src emacs-lisp
(use-package vterm
  :defer t
  :straight t
  :config
  (setq vterm-shell "/usr/bin/fish"))
#+end_src

One annoying think with vterm is it only can create one buffer, you
can’t have multiple vterm buffers by default. ~multi-vterm~ fixes this
issue.
#+begin_src emacs-lisp
(use-package multi-vterm
  :after vterm
  :defer t
  :straight (:build t)
  :general
  (phundrak/major-leader-key
    :packages '(vterm multi-vterm)
    :keymap 'vterm-mode-map
    "c" #'multi-vterm
    "n" #'multi-vterm-next
    "p" #'multi-vterm-prev))
#+end_src

** COMMENT XWidgets Webkit Browser
I used to use the xwidgets webkit browser in order to view or preview
HTML files from Emacs, but it seems the Cairo background transparency
patch breaks it. So while this isn’t patched, I will disable Xwidgets
in my Emacs build, and these keybinds *will not* be tangled.
#+begin_src emacs-lisp :tangle no
(phundrak/evil
 :keymaps 'xwidget-webkit-mode-map
 "<mouse-4>" #'xwidget-webkit-scroll-down-line
 "<mouse-5>" #'xwidget-webkit-scroll-up-line
 "c"         #'xwidget-webkit-scroll-backward
 "t"         #'xwidget-webkit-scroll-up-line
 "s"         #'xwidget-webkit-scroll-down-line
 "r"         #'xwidget-webkit-scroll-forward
 "h"         #'xwidget-webkit-goto-history
 "C"         #'xwidget-webkit-back
 "R"         #'xwidget-webkit-forward
 "C-r"       #'xwidget-webkit-reload
 "j"         nil
 "k"         nil
 "l"         nil
 "H"         nil
 "L"         nil
 "C-d"       #'xwidget-webkit-scroll-up
 "C-u"       #'xwidget-webkit-scroll-down)
#+end_src

** COMMENT Wttr.in
#+begin_src emacs-lisp
(use-package wttrin
  :defer t
  :straight (wttrin :build t
                    :local-repo "~/fromGIT/emacs-packages/emacs-wttrin"
                    :type git)
                    ;; :host github
                    ;; :repo "Phundrak/emacs-wttrin"
  :config
  (setq wttrin-default-cities '("Aubervilliers" "Paris" "Lyon" "Nonières" "Saint Agrève")
        wttrin-use-metric t))
#+end_src

*** TODO Derive a major mode for wttrin                            :noexport:
To handle keybindings correctly, a major mode for wttrin could be
derived from ~fundamental-mode~ and get an associated keymap.
