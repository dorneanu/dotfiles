#+title: Emacs — Packages — Editing
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/editing.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export


* Editing
First, I’ll define some keybindings for easily inserting pairs when
editing text.
#+begin_src emacs-lisp
(general-define-key
 :states 'visual
 "M-["  #'insert-pair
 "M-{"  #'insert-pair
 "M-<"  #'insert-pair
 "M-'"  #'insert-pair
 "M-`"  #'insert-pair
 "M-\"" #'insert-pair)
#+end_src

** Editorconfig
Editorconfig is a unified way of passing to your text editor settings
everyone working in a repo need to follow. ~.editorconfig~ files work
for VSCode users, vim users, Atom users, Sublime users, and of course
Emacs users.
#+begin_src emacs-lisp
(use-package editorconfig
  :defer t
  :straight (:build t)
  :diminish editorconfig-mode
  :init
  (editorconfig-mode t))
#+end_src

** Evil Nerd Commenter
Emacs’ default commenting system is nice, but I don’t find it smart
enough for me.
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :straight (:build t))
#+end_src
** evil-surround
#+begin_src emacs-lisp
(use-package evil-surround
  :straight t
  :config
  (global-evil-surround-mode 1))
#+end_src
** COMMENT evil-multiedit
#+begin_src emacs-lisp
(use-package evil-multiedit
  :straight t
  :config
  (evil-multiedit-default-keybinds))
#+end_src
** Iedit
Iedit is a powerful text editing tool that can be used to refactor
code through the edition of multiple regions at once, be it in a
region or in a whole buffer. Since I’m using evil, I’ll also use a
compatibility package that adds states for iedit.
#+begin_src emacs-lisp
(use-package evil-iedit-state
  :defer t
  :straight (:build t)
  :commands (evil-iedit-state evil-iedit-state/iedit-mode)
  :init
  (setq iedit-curent-symbol-default     t
        iedit-only-at-symbol-boundaries t
        iedit-toggle-key-default        nil)
  :general
  (phundrak/leader-key
    :infix "r"
    :packages '(iedit evil-iedit-state)
    "" '(:ignore t :which-key "refactor")
    "i" #'evil-iedit-state/iedit-mode)
  (general-define-key
   :keymaps 'evil-iedit-state-map
   "c" nil
   "s" nil
   "J" nil
   "S" #'iedit-expand-down-a-line
   "T" #'iedit-expand-up-a-line
   "h" #'evil-iedit-state/evil-change
   "k" #'evil-iedit-state/evil-substitute
   "K" #'evil-iedit-state/substitute
   "q" #'evil-iedit-state/quit-iedit-mode))
#+end_src

** Smartparens
~smartparens~ is a package similar to ~parinfer~, but while the latter is
more specialized for Lisp dialects, ~smartparens~ works better with
other programming languages that still uses parenthesis, but not as
much as Lisp dialects; think for example C, C++, Rust, JavaScript, and
so on.
#+begin_src emacs-lisp
(use-package smartparens
  :defer t
  :straight (smartparens :build t
                         :type git
                         :host github
                         :repo "Fuco1/smartparens")
  ;; Not sure about the bindings here.
  ;; From https://github.com/dakra/dmacs/blob/nil/init.org
  ;; :bind (:map smartparens-mode-map
  ;;             ;; This is the paredit mode map minus a few key bindings
  ;;             ;; that I use in other modes (e.g. M-?)
  ;;             ("C-M-f" . sp-forward-sexp) ;; navigation
  ;;             ("C-M-b" . sp-backward-sexp)
  ;;             ("C-M-u" . sp-backward-up-sexp)
  ;;             ("C-M-d" . sp-down-sexp)
  ;;             ("C-M-p" . sp-backward-down-sexp)
  ;;             ("C-M-n" . sp-up-sexp)
  ;;             ("C-w" . whole-line-or-region-sp-kill-region)
  ;;             ("M-s" . sp-splice-sexp) ;; depth-changing commands
  ;;             ("M-r" . sp-splice-sexp-killing-around)
  ;;             ("M-(" . sp-wrap-round)
  ;;             ("C-)" . sp-forward-slurp-sexp) ;; barf/slurp
  ;;             ("C-<right>" . sp-forward-slurp-sexp)
  ;;             ("C-}" . sp-forward-barf-sexp)
  ;;             ("C-<left>" . sp-forward-barf-sexp)
  ;;             ("C-(" . sp-backward-slurp-sexp)
  ;;             ("C-M-<left>" . sp-backward-slurp-sexp)
  ;;             ("C-{" . sp-backward-barf-sexp)
  ;;             ("C-M-<right>" . sp-backward-barf-sexp)
  ;;             ("M-S" . sp-split-sexp) ;; misc
  ;;             ("M-j" . sp-join-sexp))
  :hook
  (prog-mode . smartparens-mode)
  (org-mode . smartparens-mode)
  :config
  ;; Always highlight matching parens
  (show-smartparens-global-mode +1)
  (setq blink-matching-paren nil))

;; Some customizations for ORG mode
(with-eval-after-load 'smartparens
  (sp-local-pair 'org-mode "=" "=")
  (sp-local-pair 'org-mode "'" "'" :actions '(rem))
  (sp-local-pair 'org-mode "\"" "\"" :actions '(rem)))

;; Wrap regions/words
;; Create keybindings to wrap symbol/region in pairs
;; From https://github.com/dakra/dmacs/blob/nil/init.org
(defun prelude-wrap-with (s)
  "Create a wrapper function for smartparens using S."
  `(lambda (&optional arg)
     (interactive "P")
     (sp-wrap-with-pair ,s)))
(define-key prog-mode-map (kbd "M-(") (prelude-wrap-with "("))
(define-key prog-mode-map (kbd "M-[") (prelude-wrap-with "["))
(define-key prog-mode-map (kbd "M-{") (prelude-wrap-with "{"))
(define-key prog-mode-map (kbd "M-\"") (prelude-wrap-with "\""))
(define-key prog-mode-map (kbd "M-'") (prelude-wrap-with "'"))
(define-key prog-mode-map (kbd "M-`") (prelude-wrap-with "`"))
#+end_src
*** evil-smartparens
I still don't use it that often. Will stay here for a while till I decide to drop it.
#+begin_src emacs-lisp
(use-package evil-smartparens
  :straight t
  :config
  (add-hook 'smartparens-enabled-hook #'evil-smartparens-mode))
#+end_src
** ~string-edit~
~string-edit~ is a cool package that allows the user to write naturally
a string and get it automatically escaped for you. No more manually
escaping your strings!
#+begin_src emacs-lisp
(use-package string-edit-at-point
  :defer t
  :straight (:build t))
#+end_src
** writeroom
On the other hand, ~writeroom~ allows the user to enter a
distraction-free mode of Emacs, and I like that! But the default width
is a bit too small for me, and I prefer not to go full-screen.
#+begin_src emacs-lisp
(use-package writeroom-mode
  :defer t
  :straight (:build t)
  ;; :init (global-writeroom-mode 1)
  :config
  (setq writeroom-width             100
        writeroom-fullscreen-effect nil
        writeroom-maximize-window   nil
        writeroom-mode-line         t
        ;; writeroom-major-modes       '(text-mode org-mode markdown-mode nov-mode Info-mode)
        ))
#+end_src
** olivetti
I love /olivetti/ mode

#+begin_src emacs-lisp
(use-package olivetti
  :straight t
  :custom
  (olivetti-body-width 0.6))
#+end_src

** undo
#+begin_src emacs-lisp
(use-package undo-fu-session
  :straight t
  :hook (after-init . undo-fu-session-global-mode)
  :config
  (setq undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))

(use-package vundo
  :straight t
  :config
    ;; Better contrasting highlight.
  (custom-set-faces
   '(vundo-node ((t (:foreground "#808080"))))
   '(vundo-stem ((t (:foreground "#808080"))))
   '(vundo-highlight ((t (:foreground "#FFFF00")))))
  (setq vundo-compact-display t)
  (setq vundo-glyph-alist vundo-unicode-symbols))

(use-package undo-hl
  :straight (undo-hl :build t
                           :type git
                           :host github
                           :repo "casouri/undo-hl")
  :hook ((text-mode . undo-hl-mode)
         (prog-mode . undo-hl-mode))
  :custom-face
  (undo-hl-insert ((t (:background "#FFFF00"))))
  (undo-hl-delete ((t (:background "#FFFF00")))))
#+END_SRC

** expand-region
Use expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :straight t
  :bind
  (("M-g =" . er/expand-region)
   ("M-g - " . er/contract-region)
   :map mode-specific-map
   :prefix-map region-prefix-map
   :prefix "r"
   ("(" . er/mark-inside-pairs)
   (")" . er/mark-outside-pairs)
   ("'" . er/mark-inside-quotes)
   ([34] . er/mark-outside-quotes) ; it's just a quotation mark
   ("o" . er/mark-org-parent)
   ("u" . er/mark-url)
   ("b" . er/mark-org-code-block)
   ("." . er/mark-method-call)
   (">" . er/mark-next-accessor)
   ("w" . er/mark-word)
   ("d" . er/mark-defun)
   ("e" . er/mark-email)
   ("," . er/mark-symbol)
   ("<" . er/mark-symbol-with-prefix)
   (";" . er/mark-comment)
   ("s" . er/mark-sentence)
   ("S" . er/mark-text-sentence)
   ("p" . er/mark-paragraph)
   ("P" . er/mark-text-paragraph)))
#+end_src

** hippie-exp: Expand by fuzzy matching text in open buffers
#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :ensure nil
  :bind (("M-/" . hippie-expand))
  :config
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol)))
#+END_SRC
