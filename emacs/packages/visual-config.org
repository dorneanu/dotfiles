#+title: Emacs ‚Äî Packages ‚Äî Visual Configuration
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/visual-config.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Visual Configuration
** Dashboard
*** welcome-dashboard
Use a minimalistic dashboard:
#+begin_src emacs-lisp
(use-package welcome-dashboard
  :straight (welcome-dashboard :type git
                      :host github
                      :repo "konrad1977/welcome-dashboard"
                      :build t)
  :config
  (setq welcome-dashboard-latitude 52.520008
        welcome-dashboard-longitude 13.404954
        welcome-dashboard-path-max-length 75
        welcome-dashboard-min-left-padding 10
        ;; TODO: Fix the welcome image
        welcome-dashboard-image-file "/home/victor/.config/emacs/straight/repos/evil/doc/logo.png"
        welcome-dashboard-image-width 200
        welcome-dashboard-image-height 169
        welcome-dashboard-title "Welcome Victor. Have a great day!")
  (welcome-dashboard-create-welcome-hook))
#+end_src

** Fringe
It‚Äôs nice to know which lines were modified since the last commit in a
file.
#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :straight (:build t)
  :hook ((prog-mode     . git-gutter-mode)
         (org-mode      . git-gutter-mode)
         (markdown-mode . git-gutter-mode)
         (latex-mode    . git-gutter-mode)))
#+end_src

** Icons? Did someone say icons?
/*YES! ALL OF THEM!*/

Ahem‚Ä¶

The package ~all-the-icons~ allows us to use a wide variety of icons in
Emacs for various purposes, wherever we want, and /THAT/ is *GREAT*! I‚Äôll
(ab)use this feature in my config, be warned! *NOTE*: The first time a
configuration with ~all-the-icons~ loads on a machine, the needed fonts
might not be available, so you‚Äôll need to install them with the
command ~M-x all-the-icons-install-fonts~.
#+begin_src emacs-lisp
(use-package all-the-icons
  :defer t
  :straight t)

(when (display-graphic-p)
  (require 'all-the-icons))
;; or
(use-package all-the-icons
  :if (display-graphic-p))
#+end_src

~prettify-symbols-mode~ is also a nifty feature of Emacs, and it is
built-in! With that, I can replace strings of my choice by another
character of my choice! First, let‚Äôs declare the general symbols that
will be used everywhere.
#+begin_src emacs-lisp
(defun prog-mode-set-symbols-alist ()
  (setq prettify-symbols-alist '(("lambda"  . ?Œª)))
  (prettify-symbols-mode 1))

(add-hook 'prog-mode-hook #'prog-mode-set-symbols-alist)
#+end_src

We can now take care of the language-specific symbols. First, let‚Äôs
declare some symbols for the Lisp languages.
#+begin_src emacs-lisp
(setq-default lisp-prettify-symbols-alist '(("lambda"    . ?Œª)
                                            ("defun"     . ?ùëì)
                                            ("defvar"    . ?ùë£)
                                            ("defcustom" . ?ùëê)
                                            ("defconst"  . ?ùê∂)))

(defun lisp-mode-prettify ()
  (setq prettify-symbols-alist lisp-prettify-symbols-alist)
  (prettify-symbols-mode -1)
  (prettify-symbols-mode 1))

(dolist (lang '(emacs-lisp lisp common-lisp scheme))
  (add-hook (intern (format "%S-mode-hook" lang))
            #'lisp-mode-prettify))
#+end_src

Finally, similar to how ~org-appear~ behaves, let‚Äôs show the real string
of our symbols when the cursor is on it.
#+begin_src emacs-lisp
(setq prettify-symbols-unprettify-at-point t)
#+end_src
** Fonts
*** default-font-presets
#+begin_src emacs-lisp
(use-package default-font-presets
  :straight t
  :demand t
  :commands
  (default-font-presets-forward
   default-font-presets-backward
   default-font-presets-choose
   default-font-presets-scale-increase
   default-font-presets-scale-decrease
   default-font-presets-scale-fit
   default-font-presets-scale-reset)
  :config
  (setq default-font-presets-list
    (list
      "JetBrains Mono-12:spacing=100"
      "Source Code Pro 12"
      "Iosevka 12")))

;; Typical key bindings:

(global-set-key (kbd "C-=") 'default-font-presets-scale-increase)
(global-set-key (kbd "C--") 'default-font-presets-scale-decrease)
(global-set-key (kbd "C-0") 'default-font-presets-scale-reset)

(global-set-key (kbd "<C-mouse-4>") 'default-font-presets-scale-increase)
(global-set-key (kbd "<C-mouse-5>") 'default-font-presets-scale-decrease)

;; Alt-PageUp, Alt-PageDown.
(define-key global-map (kbd "<M-prior>") 'default-font-presets-forward)
(define-key global-map (kbd "<M-next>") 'default-font-presets-backward)
#+end_src
** Ligatures
The font I‚Äôm using supports ligatures, but Emacs in GUI mode does not.
And of course, there‚Äôs a package for that.

#+begin_src emacs-lisp
(use-package ligature
  :straight (ligature :type git
                      :host github
                      :repo "mickeynp/ligature.el"
                      :build t)
  :config
  (ligature-set-ligatures 't
                          '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures '(eww-mode org-mode elfeed-show-mode)
                          '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode
                          '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                            ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                            "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                            "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                            "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                            "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                            "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                            "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                            ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                            "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                            "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                            "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                            "\\\\" "://"))
  (global-ligature-mode t))
#+end_src

** Modeline
The DoomEmacs modeline looks nice in my opinion, let‚Äôs use it.
#+begin_src emacs-lisp
(use-package doom-modeline
  :straight (:build t)
  :defer t
  :init
  (doom-modeline-mode 1)
  (setq find-file-visit-truename t)
  :custom
  (doom-modeline-height 15)
  (doom-modeline-enable-word-count t)
  (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode))
  (doom-modeline-mu4e t)
  (doom-modeline-project-detection 'auto)
  (doom-modeline-env-version t)
  (doom-modeline-buffer-file-name-style 'truncate-upto-project))

#+end_src
*** COMMENT mini-modeline
#+begin_src emacs-lisp
(use-package mini-modeline
  :straight t
  :after smart-mode-line
  :config
  (mini-modeline-mode t))
#+end_src

*** COMMENT feebleline
#+begin_src emacs-lisp
;; (use-package feebleline
;;   :ensure t
;;   :config (setq feebleline-msg-functions
;;                 '((feebleline-line-number         :post "" :fmt "%5s")
;;                   (feebleline-column-number       :pre ":" :fmt "%-2s")
;;                   (feebleline-file-directory      :face feebleline-dir-face :post "")
;;                   (feebleline-file-or-buffer-name :face font-lock-keyword-face :post "")
;;                   (feebleline-file-modified-star  :face font-lock-warning-face :post "")
;;                   (feebleline-git-branch          :face feebleline-git-face :pre " : ")
;;                   (feebleline-project-name        :align right)))
;;   (feebleline-mode 1))
#+end_src
*** COMMENT moody modeline
#+begin_src emacs-lisp
(use-package moody
  :straight t
  ;; :disabled t
  :unless noninteractive
  ;; :defer 1
  ;;:init
  ;;(set-background-color "black")
  ;;(set-foreground-color "white")
  ;; If you use the default Emacs black theme (no external theme loaded) you have to specify
  ;; a different color for mode-line-buffer-id or it will be the same as the background
  ;;(set-face-attribute 'mode-line-buffer-id nil :foreground "light sky blue" :weight 'bold)
  ;;(let ((line (face-attribute 'mode-line :underline)))
  ;;  (set-face-attribute 'mode-line nil :overline line)
  ;;  (set-face-attribute 'mode-line-inactive nil :overline line)
  ;;  (set-face-attribute 'mode-line-inactive nil :underline line)
  ;;  (set-face-attribute 'mode-line nil :box nil)
  ;;  (set-face-attribute 'mode-line-inactive nil :box nil))
  :config
  (setq x-underline-at-descent-line t)
  (setq moody-mode-line-height nil)
  ;; moody buffer-identification doesn't work with modus themes and
  ;; the following line needs to be commented out first or emacs hangs!
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)
  (moody-replace-eldoc-minibuffer-message-function))

#+end_src
** COMMENT Pixel-perfect alignment of Markdown and org-mode tables
Usually, I have no issue with the alignment of the tables I write in
org-mode and (more rarely) Markdown. However, there are occurrences
where I‚Äôll use a character that does not exactly respect my monospace
font, which messes with the alignment of the table (often when I do
linguistics stuff). A solution to this is the package ~valign~. A little
caveat though, as its name implies ~valign~ helps with vertical
alignment. If some lines are too high, they won‚Äôt exactly fit. Unless?
Unless ~valign-fancy-bar~ is set to ~t~.

For now, I disabled the hook with org-mode and markdown-mode because
it slows down opening these files quite a lot. I‚Äôll re-enable the hook
once it is fixed.
#+begin_src emacs-lisp
(use-package valign
  :defer t
  :straight (:build t)
  :after (org markdown-mode)
  ;; :hook ((org-mode markdown-mode) . valign-mode)
  :custom ((valign-fancy-bar t)))
#+end_src

** Solaire: Incandescent Emacs
#+begin_src emacs-lisp
(use-package solaire-mode
  :straight t
  :defer 0.1
  :custom (solaire-mode-remap-fringe t)
  :config (solaire-global-mode))
#+end_src

** Theme

You may have noticed I use the Nord theme pretty much everywhere on my
computer, why not Emacs? In my opinion, its aurora variant is nicer
than the default Nord theme since it is richer in colours --- just a
personal preference.
#+begin_src emacs-lisp
(use-package doom-themes
  :straight (:build t)
  :defer t
  ;; :init (load-theme 'doom-nord-aurora t)
 )

;; Install kaolin themes
(use-package kaolin-themes
  :straight (:build t)
  :defer t)

;; Install moe-theme
(use-package moe-theme
  :straight t)

;; Install moe-theme
(use-package ef-themes
  :straight t)

;; Install sanityinc tomorrow
(use-package color-theme-sanityinc-tomorrow
  :straight t)

;; Load theme
(load-theme 'doom-monokai-octagon t)
#+end_src
** Tabs
*** tab-bar
Built-in tab bar navigation:

#+begin_src emacs-lisp
(use-package tab-bar
  :defer t
  :straight (:type built-in)
  :custom
  (tab-bar-close-button-show nil)
  (tab-bar-new-button-show nil)
  (tab-bar-new-tab-choice "*dashboard*")
  :custom-face
  (tab-bar ((t (:background "#272C36"
                :foreground "#272C36"
                :height 0.8
                :box (:line-width -1)))))
  :init
  (advice-add #'tab-new
              :after
              (lambda (&rest _) (when (y-or-n-p "Rename tab? ")
                                  (call-interactively #'tab-rename)))))
#+end_src

#+RESULTS:
*** COMMENT centaur-tabs
#+begin_src emacs-lisp
(use-package centaur-tabs
  :straight (:build t)
  :demand
  :config
  (centaur-tabs-mode t)
  :bind
  ("C-<prior>" . centaur-tabs-backward)
  ("C-<next>" . centaur-tabs-forward))
#+end_src
** Rainbow Delimiters
This makes Lisp especially more readable, but it‚Äôs also nice to have
for any language that has delimiters like brackets too.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :straight (:build t)
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** highlight lines
#+begin_src emacs-lisp
(global-hl-line-mode 1)
#+end_src
** COMMENT Y‚Äôall want some more /COLOURS/?
It is possible to make info buffers much more colourful (and, in my
opinion, easier to read) with this simple package:
#+begin_src emacs-lisp
(use-package info-colors
  :straight (:build t)
  :commands info-colors-fnontify-node
  :hook (Info-selection . info-colors-fontify-node)
  :hook (Info-mode      . mixed-pitch-mode))
#+end_src
** Perspective
I use ~perspective~:

#+begin_src emacs-lisp
(use-package perspective
  :ensure t
  :hook (after-init . persp-mode)
  :bind (("M-N" . persp-next)
         ("M-P" . persp-prev)
         ("M-O" . persp-switch))
  :init
  (setq persp-mode-prefix-key (kbd "M-g ."))
  :config
  (add-hook 'minibuffer-setup-hook
            '(lambda ()
               (dolist (k '("M-N" "M-P" "M-J"))
                 (local-set-key (kbd k) 'ignore))))
  (advice-add 'persp-switch
              :after
              #'(lambda (n &optional r)
                  (message (persp-name (persp-curr)))))
  ;; emacs window title
  (setq frame-title-format
        '("" invocation-name
          (:eval (when persp-mode (format "[%s]" (persp-name (persp-curr))))))))

(use-package persp-projectile
  :straight t
  :ensure t
  :after (perspective projectile))
#+end_src
** focus-mode
#+begin_src emacs-lisp
(use-package focus
  :straight t
  :config
  (add-to-list 'focus-mode-to-thing '((prog-mode . defun) (text-mode . sentence))))
#+end_src
** visual-fill-column
#+begin_src emacs-lisp
(use-package visual-fill-column
  :ensure nil
  :custom
  (visual-fill-column-width 90)
  (visual-fill-column-center-text t))
#+end_src

** Windows Management
*** winner
#+begin_src emacs-lisp
(use-package winner
  :ensure nil
  :custom
  (winner-boring-buffers
   '("*Completions*"
     "*Compile-Log*"
     "*inferior-lisp*"
     "*Fuzzy Completions*"
     "*Apropos*"
     "*Help*"
     "*cvs*"
     "*Buffer List*"
     "*Ibuffer*"
     "*esh command on file*"))
  :config
  (winner-mode 1))
#+end_src
*** Winum
Winum allows Emacs to associate windows with a specific number and
navigate through these windows by directly referring to their
associated number! This allows for faster window configuration than
just going to the frame above, then left, left, and up.
#+begin_src emacs-lisp
(use-package winum
  :straight (:build t)
  :init (winum-mode))
#+end_src
** Change from horizotanl split to vertical split
#+begin_src emacs-lisp
;; https://stackoverflow.com/questions/14881020/emacs-shortcut-to-switch-from-a-horizontal-split-to-a-vertical-split-in-one-move
(defun dorneanu/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "C-x |") 'dorneanu/toggle-window-split)
#+end_src
