#+title: Emacs — Packages — Autocompletion
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/autocompletion.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Autocompletion
** Code Autocompletion                                                :todo:
*** company
I still need to finish this:

#+begin_src emacs-lisp
(use-package company
  :straight (:build t)
  :defer t
  :hook (company-mode . evil-normalize-keymaps)
  :init (global-company-mode)
  :bind (:map company-search-map
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)
              :map company-active-map
              ("TAB" . company-select-next)
              ([tab] . company-select-next)
              ("C-l" . company-show-location)
              ("C-s" . company-filter-candidates)
              ("C-d" . company-show-doc-buffer)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous))
  :config
  (setq company-minimum-prefix-length     2
        company-toolsip-limit             14
        company-tooltip-align-annotations t
        company-require-match             'never
        company-global-modes              '(not erc-mode message-mode help-mode gud-mode)
        company-frontends
        '(company-pseudo-tooltip-frontend ; always show candidates in overlay tooltip
          company-echo-metadata-frontend) ; show selected candidate docs in echo area
        ;; Default backends
        company-backends '(company-capf company-dabbrev company-yasnippet)
        company-auto-commit         nil
        company-auto-complete-chars nil
        company-dabbrev-other-buffers t
        company-dabbrev-ignore-case t
        company-dabbrev-downcase    nil)
  )
#+end_src

*** company-dict
This package is a backend for company. It emulates
~ac-source-dictionary~ by proposing text related to the current
major-mode.
#+begin_src emacs-lisp
(use-package company-dict
  :after company
  :straight (:build t)
  :config
  (setq company-dict-dir (expand-file-name "dicts" user-emacs-directory)))
#+end_src

*** company-box
On the other hand, ~company-box~ is a Company front-end which offers
colours, icons, documentation and so on. Very nice.

Declaring all the icons for the variable
~company-box-icons-all-the-icons~ is quite verbose in Elisp, so I do it
with an org-table.
#+name: company-box-icons
| Type          | Icon                     | Color  |
|---------------+--------------------------+--------|
| Unknown       | find_in_page             | purple |
| Text          | text_fields              | green  |
| Method        | functions                | red    |
| Function      | functions                | red    |
| Constructor   | functions                | red    |
| Field         | functions                | red    |
| Variable      | adjust                   | blue   |
| Class         | class                    | red    |
| Interface     | settings_input_component | red    |
| Module        | view_module              | red    |
| Property      | settings                 | red    |
| Unit          | straighten               | red    |
| Value         | filter_1                 | red    |
| Enum          | plus_one                 | red    |
| Keyword       | filter_center_focus      | red    |
| Snippet       | short_text               | red    |
| Color         | color_lens               | red    |
| File          | insert_drive_file        | red    |
| Reference     | collections_bookmark     | red    |
| Folder        | folder                   | red    |
| EnumMember    | people                   | red    |
| Constant      | pause_circle_filled      | red    |
| Struct        | streetview               | red    |
| Event         | event                    | red    |
| Operator      | control_point            | red    |
| TypeParameter | class                    | red    |
| Template      | short_text               | green  |
| ElispFunction | functions                | red    |
| ElispVariable | check_circle             | blue   |
| ElispFeature  | stars                    | orange |
| ElispFace     | format_paint             | pink   |

#+name: gen-company-box-icons
#+headers: :tangle no :noweb yes :exports none :cache yes
#+header: :wrap "src emacs-lisp :exports none :tangle no"
#+begin_src emacs-lisp :var table=company-box-icons
(mapconcat (lambda (row)
             (format "(%s . ,(all-the-icons-material \"%s\" :face 'all-the-icons-%s))"
                     (car row)
                     (cadr row)
                     (caddr row)))
           table
           "\n")
#+end_src

#+RESULTS[8ebf4bb3f7f354571a5d42cf58f8b9ba847ba028]: gen-company-box-icons
#+begin_src emacs-lisp :exports none :tangle no
(Unknown . ,(all-the-icons-material "find_in_page" :face 'all-the-icons-purple))
(Text . ,(all-the-icons-material "text_fields" :face 'all-the-icons-green))
(Method . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Function . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Constructor . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Field . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Variable . ,(all-the-icons-material "adjust" :face 'all-the-icons-blue))
(Class . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Interface . ,(all-the-icons-material "settings_input_component" :face 'all-the-icons-red))
(Module . ,(all-the-icons-material "view_module" :face 'all-the-icons-red))
(Property . ,(all-the-icons-material "settings" :face 'all-the-icons-red))
(Unit . ,(all-the-icons-material "straighten" :face 'all-the-icons-red))
(Value . ,(all-the-icons-material "filter_1" :face 'all-the-icons-red))
(Enum . ,(all-the-icons-material "plus_one" :face 'all-the-icons-red))
(Keyword . ,(all-the-icons-material "filter_center_focus" :face 'all-the-icons-red))
(Snippet . ,(all-the-icons-material "short_text" :face 'all-the-icons-red))
(Color . ,(all-the-icons-material "color_lens" :face 'all-the-icons-red))
(File . ,(all-the-icons-material "insert_drive_file" :face 'all-the-icons-red))
(Reference . ,(all-the-icons-material "collections_bookmark" :face 'all-the-icons-red))
(Folder . ,(all-the-icons-material "folder" :face 'all-the-icons-red))
(EnumMember . ,(all-the-icons-material "people" :face 'all-the-icons-red))
(Constant . ,(all-the-icons-material "pause_circle_filled" :face 'all-the-icons-red))
(Struct . ,(all-the-icons-material "streetview" :face 'all-the-icons-red))
(Event . ,(all-the-icons-material "event" :face 'all-the-icons-red))
(Operator . ,(all-the-icons-material "control_point" :face 'all-the-icons-red))
(TypeParameter . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Template . ,(all-the-icons-material "short_text" :face 'all-the-icons-green))
(ElispFunction . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(ElispVariable . ,(all-the-icons-material "check_circle" :face 'all-the-icons-blue))
(ElispFeature . ,(all-the-icons-material "stars" :face 'all-the-icons-orange))
(ElispFace . ,(all-the-icons-material "format_paint" :face 'all-the-icons-pink))
#+end_src

#+begin_src emacs-lisp
(use-package company-box
  :straight (:build t)
  :after (company all-the-icons)
  :config
  (setq company-box-show-single-candidate t
        company-box-backends-colors       nil
        company-box-max-candidates        50
        company-box-icons-alist           'company-box-icons-all-the-icons
        company-box-icons-all-the-icons
        (let ((all-the-icons-scale-factor 0.8))
          `(
            <<gen-company-box-icons()>>))))
#+end_src

*** company-shell
#+begin_src emacs-lisp
(use-package company-shell
   :straight t)
#+end_src
*** COMMENT company-tabnine
A company-mode backend for TabNine, the all-language autocompleter:
#+begin_src emacs-lisp
(use-package company-tabnine
  :ensure t
  :config
  (add-to-list 'company-backends #'company-tabnine))
#+end_src
*** COMMENT codeium
#+begin_src emacs-lisp
;; we recommend using use-package to organize your init.el
(use-package codeium
    ;; if you use straight
    :straight '(:type git :host github :repo "Exafunction/codeium.el")
    ;; otherwise, make sure that the codeium.el file is on load-path

    :init
    ;; use globally
    (add-to-list 'completion-at-point-functions #'codeium-completion-at-point)
    ;; or on a hook
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local completion-at-point-functions '(codeium-completion-at-point))))

    ;; if you want multiple completion backends, use cape (https://github.com/minad/cape):
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local completion-at-point-functions
    ;;             (list (cape-super-capf #'codeium-completion-at-point #'lsp-completion-at-point)))))
    ;; an async company-backend is coming soon!

    ;; codeium-completion-at-point is autoloaded, but you can
    ;; optionally set a timer, which might speed up things as the
    ;; codeium local language server takes ~0.2s to start up
    ;; (add-hook 'emacs-startup-hook
    ;;  (lambda () (run-with-timer 0.1 nil #'codeium-init)))

    ;; :defer t ;; lazy loading, if you want
    :config
    (setq use-dialog-box nil) ;; do not use popup boxes

    ;; if you don't want to use customize to save the api-key
    ;; (setq codeium/metadata/api_key "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")

    ;; get codeium status in the modeline
    (setq codeium-mode-line-enable
        (lambda (api) (not (memq api '(CancelRequest Heartbeat AcceptCompletion)))))
    (add-to-list 'mode-line-format '(:eval (car-safe codeium-mode-line)) t)
    ;; alternatively for a more extensive mode-line
    ;; (add-to-list 'mode-line-format '(-50 "" codeium-mode-line) t)

    ;; use M-x codeium-diagnose to see apis/fields that would be sent to the local language server
    (setq codeium-api-enabled
        (lambda (api)
            (memq api '(GetCompletions Heartbeat CancelRequest GetAuthToken RegisterUser auth-redirect AcceptCompletion))))
    ;; you can also set a config for a single buffer like this:
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local codeium/editor_options/tab_size 4)))

    ;; You can overwrite all the codeium configs!
    ;; for example, we recommend limiting the string sent to codeium for better performance
    (defun my-codeium/document/text ()
        (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (min (+ (point) 1000) (point-max))))
    ;; if you change the text, you should also change the cursor_offset
    ;; warning: this is measured by UTF-8 encoded bytes
    (defun my-codeium/document/cursor_offset ()
        (codeium-utf8-byte-length
            (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (point))))
    (setq codeium/document/text 'my-codeium/document/text)
    (setq codeium/document/cursor_offset 'my-codeium/document/cursor_offset))
#+end_src
** counsel
I could almost merge this chapter with the previous one since counsel
is a package that provides loads of completion functions for ivy. The
ones I find most useful are ~counsel-M-x~ and ~counsel-find-file~.
#+begin_src emacs-lisp
;; (use-package counsel
;;   :straight t
;;   :after recentf
;;   :bind (("M-x"     . counsel-M-x)
;;          ("C-x b"   . counsel-ibuffer)
;;          ("C-x C-f" . counsel-find-file)
;;          :map minibuffer-local-map
;;          ("C-r" . 'counsel-minibuffer-history)))
#+end_src

** consult
#+begin_src emacs-lisp
(use-package consult
  :straight t
  :after projectile
  :init
  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :bind  (;; Related to the control commands.
          ("<help> a" . consult-apropos)
          ("C-x b" . consult-buffer)
          ("C-c h"   . consult-history)
          ("C-c K"   . consult-kmacro)
          ("C-c i"   . consult-info)
          ("C-x M-:" . consult-complex-command)
          ("C-c k" . consult-kmacro)
          ;; Related to the navigation.
          ("M-g a" . consult-org-agenda)
          ("M-g e" . consult-error)
          ("M-g g" . consult-goto-line)
          ("M-g h" . consult-org-heading)
          ("M-g i" . consult-imenu)
          ("M-g I" . consult-imenu-multi)
          ("M-g k" . consult-global-mark)
          ("M-g l" . consult-line)
          ("M-g m" . consult-mark)
          ("M-g o" . consult-outline)
          ("M-g P" . consult-project-imenu)
          ("M-g y" . consult-yank-from-kill-ring)
          ;; Related to the search and selection.
          ;; ("M-f G" . consult-git-grep)
          ;; ("M-f g" . consult-grep)
          ;; ("M-f k" . consult-keep-lines)
          ;; ("M-f l" . consult-locate)
          ;; ("M-f m" . consult-multi-occur)
          ("M-g r" . consult-ripgrep)
          ;; ("M-f u" . consult-focus-lines)
          ("M-g f" . consult-find)
          ;; Isearch integration
          ("M-s e"   . consult-isearch-history)
          ;; Bookmarks
          ("M-s b"   . consult-bookmark)
          :map isearch-mode-map
          ("M-e"     . consult-isearch-history)
          ("M-s e"   . consult-isearch-history)
          ("M-s l"   . consult-line)
          ("M-s L"   . consult-line-multi)
          :map minibuffer-local-map
          ("M-s"     . consult-history)
          ("M-r"     . consult-history)
          ;; Other custom bindings
          ("M-y"     . consult-yank-pop))
  :custom
  (completion-in-region-function #'consult-completion-in-region)
  (consult-narrow-key "<")
  (consult-project-root-function #'projectile-project-root)
  ;; Provides consistent display for both `consult-register' and the register
  ;; preview when editing registers.
  (register-preview-delay 0)
  (register-preview-function #'consult-register-preview))

(use-package consult-projectile
  :after (consult projectile)
  :straight (consult-projectile :type git :host gitlab :repo
                                "OlMon/consult-projectile" :branch "master")
  :commands (consult-projectile))
#+end_src
** Minibuffer completion
*** vertico
#+begin_src emacs-lisp
;; Enable vertico
(defun mpereira/vertico-next-page ()
  (interactive)
  (vertico-scroll-up 1))

(defun mpereira/vertico-previous-page ()
  (interactive)
  (vertico-scroll-down 1))

(use-package vertico
  :straight t
  :bind (:map vertico-map
              ("C-f" . mpereira/vertico-next-page)
              ("C-b" . mpereira/vertico-previous-page)
              ("C-S-j" . vertico-next-group)
              ("C-S-k" . vertico-previous-group)
              ("C-j" . vertico-next)
              ("C-k" . vertico-previous)
              ("C-h" . vertico-first)
              ("C-l" . vertico-last)
              ("C-/" . orderless-filter)
              ;; ("<escape>" . vertico-exit-input)
              :map minibuffer-local-map
              ("<C-backspace>" . backward-kill-word))
  :hook (minibuffer-setup-hook . vertico-repeat-save)
  :custom
  (vertico-cycle t)
  (vertico-count 20)
  :config
  (vertico-mode 1))


;; (use-package vertico-posframe
;;   :straight t
;;   :after vertico
;;   :config (vertico-posframe-mode 1)
;;   (setq vertico-posframe-border-width 2
;;         vertico-posframe-parameters '((internal-border-width . 2)))
;;   (add-hook 'vertico-posframe-mode-hook (set-face-background 'vertico-posframe-border (face-background 'fringe))))


(use-package vertico-repeat
  :ensure nil
  :demand t)

(use-package vertico-directory
  :ensure nil
  :demand t
  :bind (:map vertico-map
              ("<backspace>"   . vertico-directory-delete-char)
              ("C-w"           . vertico-directory-delete-word)
              ("C-<backspace>" . vertico-directory-delete-word)
              ;; ("RET" .           vertico-directory-enter)
              ))

(use-package vertico-multiform
  :ensure nil
  :after vertico
  :config
  (setq vertico-multiform-commands
        '((consult-line buffer)
          (consult-buffer buffer)
          (consult-org-heading buffer)
          (consult-imenu buffer)
          (consult-project-buffer buffer)
          (consult-project-extra-find buffer)))

  ;; (add-to-list 'vertico-multiform-categories
  ;;              '(jinx grid (vertico-grid-annotate . 35)))

  (vertico-multiform-mode))

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :init
  (savehist-mode))

(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))
#+end_src

*** marginalia

#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :after vertico
  :init (marginalia-mode)
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

If like me you like to have icons associated with candidates, you can use
[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]].

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :straight t
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))
#+end_src

*** orderless

By default, =vertico= sorts the candidates according to their history position, then by
length and finally by alphabetical. To improves searching across completion (e.g., by
filter expressions separated by spaces), you should use [[https://github.com/oantolin/orderless][orderless]] (or [[https://github.com/raxod502/prescient.el][prescient]]).

#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :custom
  (completion-category-defaults nil)
  ;; (completion-category-overrides '((file (styles . (partial-completion)))))
  ;; (completion-styles '(orderless)))
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '((file (styles basic partial-completion)))))
#+end_src
*** embark

Finally, [[https://github.com/oantolin/embark/][embark]] is great if like me you like to interact directly with your
files (e.g., for renaming, deleting and copying) through your completion system
without having to go through =dired=.

#+begin_src emacs-lisp
;; Some usefull functions
(defun cust/vsplit-file-open (f)
  (let ((evil-vsplit-window-right t))
    (evil-window-vsplit)
    (find-file f)))

(defun cust/split-file-open (f)
  (let ((evil-split-window-below t))
    (evil-window-split)
    (find-file f)))

(use-package embark
  :straight t
  :after projectile
  :bind (("C-;" . embark-act)
         :map embark-file-map
         ("V" . cust/vsplit-file-open)
         ("X" . cust/split-file-open)))
#+end_src

#+begin_src emacs-lisp
(use-package embark-consult
  :straight t
  :after (consult embark))
#+end_src

** Yasnippet
Yasnippet allows you to insert some pre-made code by just typing a few
characters. It can even generate some string with Elisp expressions
and ask the user for some input in some precise places.
#+begin_src emacs-lisp
(use-package yasnippet
  :defer t
  :straight (:build t)
  :init
  (yas-global-mode)
  :hook ((prog-mode . yas-minor-mode)
         (text-mode . yas-minor-mode)))
#+end_src

Of course, yasnippet wouldn’t be as awesome as it is without pre-made
snippets.
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

Similarly, yatemplate offers pre-made files rather than just strings.
That’s still yasnippet by the way.
#+begin_src emacs-lisp
(use-package yatemplate
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

*** consult-yasnippet
Use ~consult-yasnippet~:
#+begin_src emacs-lisp
(use-package consult-yasnippet
  :defer t
  :after (consult yasnippet)
  :straight (:build t)
  )
#+end_src
