#+title: Emacs — Packages — Autocompletion
#+setupfile: ../../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/autocompletion.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Autocompletion
** Code Autocompletion                                                :todo:
*** corfu
Some useful resources:
- https://www.skfwe.cn/p/corfu-orderless-dabbrev-use/
- https://kristofferbalintona.me/posts/202203130102/
#+begin_src emacs-lisp
(use-package corfu
  :straight t
  :demand t
  :hook ((global-corfu-mode . corfu-popupinfo-mode)
         (lsp-completion-mode . dorneanu/corfu-setup-lsp) ; Use corfu for lsp completion
         )
  :bind (("C-c . p" . completion-at-point)
         :map corfu-map
         ("TAB" . corfu-next)
         ([tab] . corfu-next)
         ("S-TAB" . corfu-previous)
         ([backtab] . corfu-previous)
         ("<escape>" . corfu-quit)
         ("<return>" . corfu-insert)
         ("M-d"      . corfu-info-documentation)
         ("M-l"      . corfu-info-location)
         ("M-."      . corfu-move-to-minibuffer))
  :custom
  ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
  ;; want to perform completion
  (tab-always-indent 'complete)
  (completion-cycle-threshold nil)      ; Always show candidates in menu

  ;; Only use `corfu' when calling `completion-at-point' or
  ;; `indent-for-tab-command'
  (corfu-auto t)
  (corfu-auto-prefix 2)
  (corfu-auto-delay 0.25)

  (corfu-min-width 80)
  (corfu-max-width corfu-min-width)     ; Always have the same width
  ;; (corfu-count 14)
  ;; (corfu-scroll-margin 4)
  (corfu-cycle nil)
  (corfu-preselect 'prompt)

  ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
  ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
  ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
  ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
  ;; configuration already has pre-prepared). Necessary for manual corfu usage with
  ;; orderless, otherwise first component is ignored, unless `corfu-separator'
  ;; is inserted.
  (corfu-quit-at-boundary nil)
  (corfu-separator ?\s)            ; Use space
  (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
  (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
  (corfu-preselect-first t)        ; Preselect first candidate?
  (lsp-completion-provider :none)       ; Use corfu instead for lsp completions

  ;; Other
  ;; (corfu-echo-documentation nil)        ; Already use corfu-popupinfo
  :preface
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
                (bound-and-true-p vertico--input))
      (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
      (corfu-mode 1)))

  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let (completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  :config
  ;; Enable Corfu more generally for every minibuffer, as long as no other
  ;; completion UI is active. If you use Mct or Vertico as your main
  ;; minibuffer completion UI. From
  ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)

  ;; Setup lsp to use corfu for lsp completion
  (defun dorneanu/corfu-setup-lsp ()
    "Use orderless completion style with lsp-capf instead of the default lsp-passthrough."
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless)))

  (global-corfu-mode)
)
#+end_src
**** kind-icon
#+begin_src emacs-lisp
(use-package kind-icon
  :straight (:build t)
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
  (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
  (kind-icon-blend-frac 0.08)
  :config
  ;; (when *is-windows*
  ;;   (setq kind-icon-use-icons nil))   ;; 由于 Windows 上的svg 显示有问题 所以关掉
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'
  )
#+end_src
**** nerd-icons-corfu
#+begin_src emacs-elisp
(use-package nerd-icons-corfu
  :straight t
  :after corfu
  :init (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
**** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :ensure nil
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :bind (:map corfu-map
              ("M-n" . corfu-popupinfo-scroll-up)
              ("M-p" . corfu-popupinfo-scroll-down)
              ([remap corfu-show-documentation] . corfu-popupinfo-toggle))
  :custom
  (corfu-popupinfo-delay 0.5)
  (corfu-popupinfo-max-width 70)
  (corfu-popupinfo-max-height 20)
  ;; Also here to be extra-safe that this is set when `corfu-popupinfo' is
  ;; loaded. I do not want documentation shown in both the echo area and in
  ;; the `corfu-popupinfo' popup.
  (corfu-echo-documentation nil))
#+end_src
**** COMMENT lsp-mode-corfu
#+begin_src emacs-lisp
(use-package lsp-mode-corfu
  :ensure nil
  :after (corfu lsp-mode)
  :custom
  (lsp-completion-provider :none)) ;; we use corfu
#+end_src

*** cape
#+begin_src emacs-lisp
(use-package cape
  :straight t
  :demand t
  :hook ((prog-mode . dorneanu/set-basic-capf)
         (text-mode . dorneanu/set-basic-capf)
         (org-mode . dorneanu/set-basic-capf)
         (go-ts-mode . dorneanu/set-go-capf)
         (lsp-completion-mode . dorneanu/set-lsp-capf))

  :general (:prefix "M-c"              ; I don't really use capitalize-word
                    "p" 'completion-at-point
                    "t" 'complete-tag   ; etags
                    "d" 'cape-dabbrev   ; basically `dabbrev-completion'
                    "f" 'cape-file
                    "k" 'cape-keyword
                    "s" 'cape-symbol
                    "a" 'cape-abbrev
                    "i" 'cape-ispell
                    "l" 'cape-line
                    "w" 'cape-dict
                    "\\" 'cape-tex
                    "_" 'cape-tex
                    "^" 'cape-tex
                    "&" 'cape-sgml
                    "r" 'cape-rfc1345)
  :custom
  (cape-dabbrev-min-length 1)
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  ;; (add-to-list 'completion-at-point-functions #'cape-history)
  ;; (add-to-list 'completion-at-point-functions #'cape-keyword)
  ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block))

;; Disable company
;; (add-hook 'prog-mode-hook (lambda () (company-mode -1)))
;; (global-company-mode -1)

;; Set capfs
(defun dorneanu/set-basic-capf ()
  (setq-local completion-at-point-functions
              (list (cape-capf-super #'cape-symbol #'cape-dabbrev #'cape-dict #'cape-keyword)))
  )

(defun dorneanu/set-lsp-capf ()
  (setq-local completion-at-point-functions
              (list (cape-capf-super #'lsp-completion-at-point #'cape-dabbrev #'cape-dict #'cape-keyword)))
  )

(defun dorneanu/set-go-capf ()
  (setq-local completion-at-point-functions
              (list (cape-capf-super #'lsp-completion-at-point (cape-company-to-capf #'company-go))))
  )


#+end_src

#+RESULTS:
: dorneanu/set-lsp-capf

**** COMMENT elisp-mode-cape

#+begin_src emacs-lisp
(use-package elisp-mode-cape
  :no-require t
  :after (cape elisp-mode)
  :hook (emacs-lisp-mode . my/setup-elisp)
  :preface
  (defun my/setup-elisp ()
    (setq-local completion-at-point-functions
                `(,(cape-super-capf
                    #'elisp-completion-at-point
                    #'cape-dabbrev)
                  cape-file)
                cape-dabbrev-min-length 5)))
#+end_src

*** company
I still need to finish this:

#+begin_src emacs-lisp
(use-package company
  :straight (:build t)
  :disabled t
  :custom
  (company-idle-delay nil) ;; turn off auto-completion
  ;; :hook (company-mode . evil-normalize-keymaps)
  ;; :bind (:map global-map
  ;;             ("<backtab>" . company-complete)
  ;;             :map company-search-map
  ;;             ("C-n" . company-select-next)
  ;;             ("C-p" . company-select-previous)
  ;;             ("M-m q" . company-other-backend)
  ;;             :map company-active-map
  ;;             ("TAB" . company-select-next)
  ;;             ([tab] . company-select-next)
  ;;             ("C-l" . company-show-location)
  ;;             ("C-s" . company-filter-candidates)
  ;;             ("C-d" . company-show-doc-buffer)
  ;;             ("C-n" . company-select-next)
  ;;             ("C-p" . company-select-previous))
  ;; :config
  ;; (setq company-minimum-prefix-length     3
  ;;       company-idle-delay                0.2
  ;;       company-toolsip-limit             14
  ;;       company-tooltip-align-annotations t
  ;;       company-require-match             'never
  ;;       company-global-modes              '(not prog-mode org-mode)
  ;;       company-frontends
  ;;       '(company-pseudo-tooltip-frontend ; always show candidates in overlay tooltip
  ;;         company-echo-metadata-frontend) ; show selected candidate docs in echo area
  ;;       ;; Default backends
  ;;       company-backends '(company-capf)
  ;;       ;; company-auto-commit         t
  ;;       ;; company-auto-complete-chars nil
  ;;       ;; company-dabbrev-other-buffers t
  ;;       ;; company-dabbrev-ignore-case t
  ;;       company-dabbrev-downcase nil)
  )
#+end_src


**** COMMENT company-box
On the other hand, ~company-box~ is a Company front-end which offers
colours, icons, documentation and so on. Very nice.

Declaring all the icons for the variable
~company-box-icons-all-the-icons~ is quite verbose in Elisp, so I do it
with an org-table.
#+name: company-box-icons
| Type          | Icon                     | Color  |
|---------------+--------------------------+--------|
| Unknown       | find_in_page             | purple |
| Text          | text_fields              | green  |
| Method        | functions                | red    |
| Function      | functions                | red    |
| Constructor   | functions                | red    |
| Field         | functions                | red    |
| Variable      | adjust                   | blue   |
| Class         | class                    | red    |
| Interface     | settings_input_component | red    |
| Module        | view_module              | red    |
| Property      | settings                 | red    |
| Unit          | straighten               | red    |
| Value         | filter_1                 | red    |
| Enum          | plus_one                 | red    |
| Keyword       | filter_center_focus      | red    |
| Snippet       | short_text               | red    |
| Color         | color_lens               | red    |
| File          | insert_drive_file        | red    |
| Reference     | collections_bookmark     | red    |
| Folder        | folder                   | red    |
| EnumMember    | people                   | red    |
| Constant      | pause_circle_filled      | red    |
| Struct        | streetview               | red    |
| Event         | event                    | red    |
| Operator      | control_point            | red    |
| TypeParameter | class                    | red    |
| Template      | short_text               | green  |
| ElispFunction | functions                | red    |
| ElispVariable | check_circle             | blue   |
| ElispFeature  | stars                    | orange |
| ElispFace     | format_paint             | pink   |

#+name: gen-company-box-icons
#+headers: :tangle no :noweb yes :exports none :cache yes
#+header: :wrap "src emacs-lisp :exports none :tangle no"
#+begin_src emacs-lisp :var table=company-box-icons
(mapconcat (lambda (row)
             (format "(%s . ,(all-the-icons-material \"%s\" :face 'all-the-icons-%s))"
                     (car row)
                     (cadr row)
                     (caddr row)))
           table
           "\n")
#+end_src

#+RESULTS[8ebf4bb3f7f354571a5d42cf58f8b9ba847ba028]: gen-company-box-icons
#+begin_src emacs-lisp :exports none :tangle no
(Unknown . ,(all-the-icons-material "find_in_page" :face 'all-the-icons-purple))
(Text . ,(all-the-icons-material "text_fields" :face 'all-the-icons-green))
(Method . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Function . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Constructor . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Field . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Variable . ,(all-the-icons-material "adjust" :face 'all-the-icons-blue))
(Class . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Interface . ,(all-the-icons-material "settings_input_component" :face 'all-the-icons-red))
(Module . ,(all-the-icons-material "view_module" :face 'all-the-icons-red))
(Property . ,(all-the-icons-material "settings" :face 'all-the-icons-red))
(Unit . ,(all-the-icons-material "straighten" :face 'all-the-icons-red))
(Value . ,(all-the-icons-material "filter_1" :face 'all-the-icons-red))
(Enum . ,(all-the-icons-material "plus_one" :face 'all-the-icons-red))
(Keyword . ,(all-the-icons-material "filter_center_focus" :face 'all-the-icons-red))
(Snippet . ,(all-the-icons-material "short_text" :face 'all-the-icons-red))
(Color . ,(all-the-icons-material "color_lens" :face 'all-the-icons-red))
(File . ,(all-the-icons-material "insert_drive_file" :face 'all-the-icons-red))
(Reference . ,(all-the-icons-material "collections_bookmark" :face 'all-the-icons-red))
(Folder . ,(all-the-icons-material "folder" :face 'all-the-icons-red))
(EnumMember . ,(all-the-icons-material "people" :face 'all-the-icons-red))
(Constant . ,(all-the-icons-material "pause_circle_filled" :face 'all-the-icons-red))
(Struct . ,(all-the-icons-material "streetview" :face 'all-the-icons-red))
(Event . ,(all-the-icons-material "event" :face 'all-the-icons-red))
(Operator . ,(all-the-icons-material "control_point" :face 'all-the-icons-red))
(TypeParameter . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Template . ,(all-the-icons-material "short_text" :face 'all-the-icons-green))
(ElispFunction . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(ElispVariable . ,(all-the-icons-material "check_circle" :face 'all-the-icons-blue))
(ElispFeature . ,(all-the-icons-material "stars" :face 'all-the-icons-orange))
(ElispFace . ,(all-the-icons-material "format_paint" :face 'all-the-icons-pink))
#+end_src

#+begin_src emacs-lisp
(use-package company-box
  :straight t
  :after (company all-the-icons)
  :hook (prog-mode . company-box-mode)
  :config
  (setq company-box-show-single-candidate t
        company-box-backends-colors       nil
        company-box-max-candidates        50
        company-box-icons-alist           'company-box-icons-all-the-icons
        company-box-icons-all-the-icons
        (let ((all-the-icons-scale-factor 0.8))
          `(
            <<gen-company-box-icons()>>))))
#+end_src

#+RESULTS:
| company-box-mode | rainbow-delimiters-mode | prog-mode-set-symbols-alist | git-gutter-mode | highlight-indent-guides-mode | (lambda nil (setq truncate-lines t)) | undo-hl-mode | smartparens-mode | yas-minor-mode | enable-trailing-whitespace | hs-minor-mode | display-line-numbers-mode | (lambda nil (setq indent-tabs-mode nil)) | editorconfig-major-mode-hook |

**** COMMENT company-shell
#+begin_src emacs-lisp
(use-package company-shell
   :straight t)
#+end_src
**** COMMENT company-dict
This package is a backend for company. It emulates
~ac-source-dictionary~ by proposing text related to the current
major-mode.
#+begin_src emacs-lisp
(use-package company-dict
  :after company
  :straight (:build t)
  :config
  (setq company-dict-dir (expand-file-name "dicts" user-emacs-directory)))
#+end_src

**** COMMENT company-tabnine
A company-mode backend for TabNine, the all-language autocompleter:
#+begin_src emacs-lisp
(use-package company-tabnine
  :ensure t
  :config
  (add-to-list 'company-backends #'company-tabnine))
#+end_src
*** COMMENT codeium
#+begin_src emacs-lisp
;; we recommend using use-package to organize your init.el
(use-package codeium
    ;; if you use straight
    :straight '(:type git :host github :repo "Exafunction/codeium.el")
    ;; otherwise, make sure that the codeium.el file is on load-path

    :init
    ;; use globally
    (add-to-list 'completion-at-point-functions #'codeium-completion-at-point)
    ;; or on a hook
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local completion-at-point-functions '(codeium-completion-at-point))))

    ;; if you want multiple completion backends, use cape (https://github.com/minad/cape):
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local completion-at-point-functions
    ;;             (list (cape-super-capf #'codeium-completion-at-point #'lsp-completion-at-point)))))
    ;; an async company-backend is coming soon!

    ;; codeium-completion-at-point is autoloaded, but you can
    ;; optionally set a timer, which might speed up things as the
    ;; codeium local language server takes ~0.2s to start up
    ;; (add-hook 'emacs-startup-hook
    ;;  (lambda () (run-with-timer 0.1 nil #'codeium-init)))

    ;; :defer t ;; lazy loading, if you want
    :config
    (setq use-dialog-box nil) ;; do not use popup boxes

    ;; if you don't want to use customize to save the api-key
    ;; (setq codeium/metadata/api_key "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")

    ;; get codeium status in the modeline
    (setq codeium-mode-line-enable
        (lambda (api) (not (memq api '(CancelRequest Heartbeat AcceptCompletion)))))
    (add-to-list 'mode-line-format '(:eval (car-safe codeium-mode-line)) t)
    ;; alternatively for a more extensive mode-line
    ;; (add-to-list 'mode-line-format '(-50 "" codeium-mode-line) t)

    ;; use M-x codeium-diagnose to see apis/fields that would be sent to the local language server
    (setq codeium-api-enabled
        (lambda (api)
            (memq api '(GetCompletions Heartbeat CancelRequest GetAuthToken RegisterUser auth-redirect AcceptCompletion))))
    ;; you can also set a config for a single buffer like this:
    ;; (add-hook 'python-mode-hook
    ;;     (lambda ()
    ;;         (setq-local codeium/editor_options/tab_size 4)))

    ;; You can overwrite all the codeium configs!
    ;; for example, we recommend limiting the string sent to codeium for better performance
    (defun my-codeium/document/text ()
        (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (min (+ (point) 1000) (point-max))))
    ;; if you change the text, you should also change the cursor_offset
    ;; warning: this is measured by UTF-8 encoded bytes
    (defun my-codeium/document/cursor_offset ()
        (codeium-utf8-byte-length
            (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (point))))
    (setq codeium/document/text 'my-codeium/document/text)
    (setq codeium/document/cursor_offset 'my-codeium/document/cursor_offset))
#+end_src
** counsel
I could almost merge this chapter with the previous one since counsel
is a package that provides loads of completion functions for ivy. The
ones I find most useful are ~counsel-M-x~ and ~counsel-find-file~.
#+begin_src emacs-lisp
;; (use-package counsel
;;   :straight t
;;   :after recentf
;;   :bind (("M-x"     . counsel-M-x)
;;          ("C-x b"   . counsel-ibuffer)
;;          ("C-x C-f" . counsel-find-file)
;;          :map minibuffer-local-map
;;          ("C-r" . 'counsel-minibuffer-history)))
#+end_src

** consult
#+begin_src emacs-lisp
(use-package consult
  :straight t
  :after projectile
  :init
  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :bind  (;; Related to the control commands.
          ("<help> a" . consult-apropos)
          ("C-x b" . consult-buffer)
          ("C-c h"   . consult-history)
          ("C-c K"   . consult-kmacro)
          ("C-c i"   . consult-info)
          ("C-x M-:" . consult-complex-command)
          ("C-c k" . consult-kmacro)
          ;; Related to the navigation.
          ("M-g a" . consult-org-agenda)
          ("M-g e" . consult-error)
          ("M-g g" . consult-goto-line)
          ("M-g h" . consult-org-heading)
          ("M-g i" . consult-imenu)
          ("M-g I" . consult-imenu-multi)
          ("M-g k" . consult-global-mark)
          ("M-g l" . consult-line)
          ("M-g m" . consult-mark)
          ("M-g o" . consult-outline)
          ("M-g P" . consult-project-imenu)
          ("M-g y" . consult-yank-from-kill-ring)
          ;; Related to the search and selection.
          ;; ("M-f G" . consult-git-grep)
          ;; ("M-f g" . consult-grep)
          ;; ("M-f k" . consult-keep-lines)
          ;; ("M-f l" . consult-locate)
          ;; ("M-f m" . consult-multi-occur)
          ("M-g r" . consult-ripgrep)
          ;; ("M-f u" . consult-focus-lines)
          ("M-g f" . consult-find)
          ;; Isearch integration
          ("M-s e"   . consult-isearch-history)
          ;; Bookmarks
          ("M-g b"   . consult-bookmark)
          :map isearch-mode-map
          ("M-e"     . consult-isearch-history)
          ("M-s e"   . consult-isearch-history)
          ("M-s l"   . consult-line)
          ("M-s L"   . consult-line-multi)
          :map minibuffer-local-map
          ("M-s"     . consult-history)
          ("M-r"     . consult-history)
          ;; Other custom bindings
          ("M-y"     . consult-yank-pop))
  :custom
  (completion-in-region-function #'consult-completion-in-region)
  (consult-narrow-key "<")
  (consult-project-root-function #'projectile-project-root)
  ;; Provides consistent display for both `consult-register' and the register
  ;; preview when editing registers.
  (register-preview-delay 0)
  (register-preview-function #'consult-register-preview))

(use-package consult-projectile
  :after (consult projectile)
  :straight (consult-projectile :type git :host gitlab :repo
                                "OlMon/consult-projectile" :branch "master")
  :commands (consult-projectile))
#+end_src

** Minibuffer completion
*** vertico
#+begin_src emacs-lisp
;; Enable vertico
(defun mpereira/vertico-next-page ()
  (interactive)
  (vertico-scroll-up 1))

(defun mpereira/vertico-previous-page ()
  (interactive)
  (vertico-scroll-down 1))

(use-package vertico
  :straight t
  :bind (:map vertico-map
              ("C-f" . mpereira/vertico-next-page)
              ("C-b" . mpereira/vertico-previous-page)
              ("C-S-j" . vertico-next-group)
              ("C-S-k" . vertico-previous-group)
              ("C-j" . vertico-next)
              ("C-k" . vertico-previous)
              ("C-h" . vertico-first)
              ("C-l" . vertico-last)
              ("C-/" . orderless-filter)
              ;; ("<escape>" . vertico-exit-input)
              :map minibuffer-local-map
              ("<C-backspace>" . backward-kill-word))
  :hook (minibuffer-setup-hook . vertico-repeat-save)
  :custom
  (vertico-cycle t)
  (vertico-count 20)
  :config
  (vertico-mode 1))


;; (use-package vertico-posframe
;;   :straight t
;;   :after vertico
;;   :config (vertico-posframe-mode 1)
;;   (setq vertico-posframe-border-width 2
;;         vertico-posframe-parameters '((internal-border-width . 2)))
;;   (add-hook 'vertico-posframe-mode-hook (set-face-background 'vertico-posframe-border (face-background 'fringe))))


(use-package vertico-repeat
  :ensure nil
  :demand t)

(use-package vertico-directory
  :ensure nil
  :demand t
  :bind (:map vertico-map
              ("<backspace>"   . vertico-directory-delete-char)
              ("C-w"           . vertico-directory-delete-word)
              ("C-<backspace>" . vertico-directory-delete-word)
              ;; ("RET" .           vertico-directory-enter)
              ))

(use-package vertico-multiform
  :ensure nil
  :after vertico
  :config
  (setq vertico-multiform-commands
        '((consult-line buffer)
          (consult-buffer buffer)
          (consult-org-heading buffer)
          (consult-imenu buffer)
          (consult-project-buffer buffer)
          (consult-project-extra-find buffer)))

  ;; (add-to-list 'vertico-multiform-categories
  ;;              '(jinx grid (vertico-grid-annotate . 35)))

  (vertico-multiform-mode))

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :init
  (savehist-mode))

(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))
#+end_src

*** marginalia

#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :after vertico
  :init (marginalia-mode)
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

If like me you like to have icons associated with candidates, you can use
[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]].

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :straight t
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))
#+end_src

*** orderless

By default, =vertico= sorts the candidates according to their history position, then by
length and finally by alphabetical. To improves searching across completion (e.g., by
filter expressions separated by spaces), you should use [[https://github.com/oantolin/orderless][orderless]] (or [[https://github.com/raxod502/prescient.el][prescient]]).

#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :custom
  (completion-category-defaults nil)
  ;; (completion-category-overrides '((file (styles . (partial-completion)))))
  ;; (completion-styles '(orderless)))
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '((file (styles basic partial-completion)))))
#+end_src
*** embark

Finally, [[https://github.com/oantolin/embark/][embark]] is great if like me you like to interact directly with your
files (e.g., for renaming, deleting and copying) through your completion system
without having to go through =dired=.

#+begin_src emacs-lisp
;; Some usefull functions
(defun cust/vsplit-file-open (f)
  (let ((evil-vsplit-window-right t))
    (evil-window-vsplit)
    (find-file f)))

(defun cust/split-file-open (f)
  (let ((evil-split-window-below t))
    (evil-window-split)
    (find-file f)))

(use-package embark
  :straight t
  :after projectile
  :bind (("C-;" . embark-act)
         :map embark-file-map
         ("V" . cust/vsplit-file-open)
         ("X" . cust/split-file-open)))
#+end_src

#+begin_src emacs-lisp
(use-package embark-consult
  :straight t
  :after (consult embark))
#+end_src

** Yasnippet
Yasnippet allows you to insert some pre-made code by just typing a few
characters. It can even generate some string with Elisp expressions
and ask the user for some input in some precise places.
#+begin_src emacs-lisp
(use-package yasnippet
  :defer t
  :straight (:build t)
  :init
  (yas-global-mode)
  :hook ((prog-mode . yas-minor-mode)
         (text-mode . yas-minor-mode)))
#+end_src

Of course, yasnippet wouldn’t be as awesome as it is without pre-made
snippets.
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

Similarly, yatemplate offers pre-made files rather than just strings.
That’s still yasnippet by the way.
#+begin_src emacs-lisp
(use-package yatemplate
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

*** consult-yasnippet
Use ~consult-yasnippet~:
#+begin_src emacs-lisp
(use-package consult-yasnippet
  :defer t
  :after (consult yasnippet)
  :straight (:build t)
  )
#+end_src
