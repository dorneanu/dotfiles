#+title: Emacs — Basic Configuration
#+setupfile: ../headers
#+property: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.config/emacs/lisp/basic-config.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Basic Configuration
** Early Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/early-init.el :mkdirp yes
:header-args:emacs-lisp+: :exports code :results silent :lexical t
:END:
The early init file is the file loaded before anything else in
Emacs. This is where I put some options in order to disable as quickly
as possible some built-in features of Emacs before they can be even
loaded, speeding Emacs up a bit.
#+begin_src emacs-lisp :mkdirp yes
(setq package-enable-at-startup nil
      inhibit-startup-message   t
      frame-resize-pixelwise    t  ; fine resize
      package-native-compile    t) ; native compile packages
(scroll-bar-mode -1)               ; disable scrollbar
(tool-bar-mode -1)                 ; disable toolbar
(tooltip-mode -1)                  ; disable tooltips
(set-fringe-mode 10)               ; give some breathing room
(menu-bar-mode -1)                 ; disable menubar
(blink-cursor-mode 0)              ; disable blinking cursor
;; (setq gc-cons-threshold (* 1024 1024 1024))
#+end_src
*** Unset =file-name-handler-alist=
Every file opened and loaded by Emacs will run through this list to check for a proper handler for the file, but during startup, it won’t need any of them.

#+begin_src emacs-lisp
(defvar file-name-handler-alist-original file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src
*** Disable =site-run-file=
#+begin_src emacs-lisp
(setq site-run-file nil)
#+end_src
*** Defer garbage collection
Defer garbage collection further back in the startup process, according to [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][hlissner]].

#+BEGIN_QUOTE
The GC eats up quite a bit of time, easily doubling startup time. The trick is to turn up the memory threshold as early as possible.
#+END_QUOTE

#+begin_src emacs-lisp
(setq gc-cons-threshold 100000000)
#+end_src

** Garbage Collection
*** Set =gc-cons-threshold= Smaller for Interactive Use
A large =gc-cons-threshold= may cause freezing and stuttering during long-term interactive use.
If you experience freezing, decrease this amount, if you experience stuttering, increase this amount.

#+begin_src emacs-lisp
(defvar better-gc-cons-threshold 134217728 ; 128mb
  "The default value to use for `gc-cons-threshold'.

If you experience freezing, decrease this.  If you experience stuttering, increase this.")

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold better-gc-cons-threshold)
            (setq file-name-handler-alist file-name-handler-alist-original)
            (makunbound 'file-name-handler-alist-original)))
#+end_src

Garbage Collect when Emacs is out of focus and avoid garbage collection when using minibuffer.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (if (boundp 'after-focus-change-function)
                (add-function :after after-focus-change-function
                              (lambda ()
                                (unless (frame-focus-state)
                                  (garbage-collect))))
              (add-hook 'after-focus-change-function 'garbage-collect))
            (defun gc-minibuffer-setup-hook ()
              (setq gc-cons-threshold (* better-gc-cons-threshold 2)))

            (defun gc-minibuffer-exit-hook ()
              (garbage-collect)
              (setq gc-cons-threshold better-gc-cons-threshold))

            (add-hook 'minibuffer-setup-hook #'gc-minibuffer-setup-hook)
            (add-hook 'minibuffer-exit-hook #'gc-minibuffer-exit-hook)))
#+end_src

** Personal Information
#+begin_src emacs-lisp
(setq user-full-name       "Victor Dorneanu"
      user-real-login-name "Victor Dorneanu"
      user-login-name      "dorneanu"
      user-mail-address    "victor __at__ dornea <<-.--> nu")
#+end_src
** Emacs Behavior
*** Editing Text in Emacs
I *never* want to keep trailing spaces in my files, which is why I’m
doing this:
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'whitespace-cleanup)
#+end_src

I don’t understand why some people add two spaces behind a full stop,
I sure don’t. Let’s tell Emacs.
#+begin_src emacs-lisp
(setq-default sentence-end-double-space nil)
#+end_src

There is a minor mode in Emacs which allows having a finer way of
jumping from word to word: ~global-subword-mode~. It detects if what
Emacs usually considers a word can be understood as several words, as
in camelCase words, and allows us to jump words on this finer level.
#+begin_src emacs-lisp
(global-subword-mode 1)
#+end_src

Lastly, I want the default mode for Emacs to be Emacs Lisp.
#+begin_src emacs-lisp
(setq-default initial-major-mode 'emacs-lisp-mode)
#+end_src

**** Indentation
I don’t like tabs. They rarely look good, and if I need it I can
almost always tell Emacs to use them through a ~.dir-locals.el~ file or
through the config file of my code formatter. So by default, let’s
disable them:
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))
#+end_src

*** GPG pinentry
I’d like Emacs to be responsible for decrypting my GPG encrypted files
when in Emacs. This can be done with the following line.
#+begin_src emacs-lisp
(setq epg-pinentry-mode 'loopback)
#+end_src

*** Programming Modes
First off, my definition of what makes a “programming mode” doesn’t exactly
fit mine, so on top of ~prog-mode~, let’s add a few other modes.
#+name: line-number-modes-table
| Modes      |
|------------|
| prog-mode  |
| latex-mode |

#+name: prog-modes-gen
#+header: :cache yes :exports none :tangle no
#+begin_src emacs-lisp :var modes=line-number-modes-table
(mapconcat (lambda (mode) (format "%s-hook" (car mode)))
           modes
           " ")
#+end_src

**** Line Number
Since version 26, Emacs has a built-in capacity of displaying line
numbers on the left-side of the buffer. This is a fantastic feature
that should actually be the default for all programming modes.

#+begin_src emacs-lisp
(dolist (mode '(<<prog-modes-gen()>>))
  (add-hook mode #'display-line-numbers-mode))
#+end_src

**** Folding code
Most programming languages can usually have their code folded, be it
code between curly braces, chunks of comments or code on another level
of indentation (Python, why…?). The minor-mode that enables that is
~hs-minor-mode~, let’s enable it for all of these programming modes:
#+begin_src emacs-lisp
(dolist (mode '(<<prog-modes-gen()>>))
  (add-hook mode #'hs-minor-mode))
#+end_src

*** Stay Clean, Emacs!
As nice as Emacs is, it isn’t very polite or clean by default: open a
file, and it will create backup files in the same directory. But then,
when you open your directory with your favourite file manager and see
almost all of your files duplicated with a =~= appended to the filename,
it looks really uncomfortable! This is why I prefer to tell Emacs to
keep its backup files to itself in a directory it only will access.
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name ".tmp/backups/"
                                                         user-emacs-directory))))
#+end_src

It also loves to litter its ~init.el~ with custom variables here and
there, but the thing is: I regenerate my ~init.el~ each time I tangle
this file! How can I keep Emacs from adding stuff that will be almost
immediately lost? Did someone say /custom file/?
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file) ; Don’t forget to load it, we still need it
  (load custom-file))
#+end_src

If we delete a file, we want it moved to the trash, not simply deleted.
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
#+end_src

Finally, the scratch buffer always has some message at its beginning, I
don’t want it!
#+begin_src emacs-lisp
(setq-default initial-scratch-message nil)
#+end_src

*** Stay Polite, Emacs!
When asking for our opinion on something, Emacs loves asking us to
answer by “yes” or “no”, but *in full*! That’s very rude! Fortunately,
we can fix this. Note that the configuration changed in Emacs 29.
#+begin_src emacs-lisp
(if (version<= emacs-version "28")
    (defalias 'yes-or-no-p 'y-or-n-p)
  (setopt use-short-answers t))
#+end_src

This will make Emacs ask us for either hitting the ~y~ key for “yes”, or
the ~n~ key for “no”. Much more polite!

It is also very impolite to keep a certain version of a file in its
buffer when said file has changed on disk. Let’s change this
behaviour:
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

Much more polite! Note that if the buffer is modified and its changes
haven’t been saved, it will not automatically revert the buffer and
your unsaved changes won’t be lost. Very polite!

*** Misc
Let’s raise Emacs undo memory to 10 MB, and make Emacs auto-save our
files by default.
#+begin_src emacs-lisp
(setq undo-limit        100000000
      auto-save-default t)
#+end_src

#+begin_src emacs-lisp
(setq window-combination-resize t) ; take new window space from all other windows
#+end_src

** Personal Information
Emacs needs to know its master! For various reasons by the way, some
packages rely on these variables to know who it is talking to or
dealing with, such as ~mu4e~ which will guess who you are if you haven’t
set it up correctly.
#+begin_src emacs-lisp
(setq user-full-name       "Victor Dorneanu"
      user-real-login-name "Victor Dorneanu"
      user-login-name      "dorneanu"
      user-mail-address    "no - spam __ dornea <dot> nu")
#+end_src

** Visual Configuration
The first visual setting in this section will activate the visible
bell. What it does is I get a visual feedback each time I do something
Emacs doesn’t agree with, like trying to go up a line when I’m already
at the top of the buffer.
#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

It is nicer to see a cursor cover the actual space of a character.
#+begin_src emacs-lisp
(setq x-stretch-cursor t)
#+end_src

When text is ellipsed, I want the ellipsis marker to be a single
character of three dots. Let’s make it so:
#+begin_src emacs-lisp
(with-eval-after-load 'mule-util
 (setq truncate-string-ellipsis "…"))
#+end_src

With Emacs 29.0.50 onwards, a new frame parameter exists:
~alpha-background~. Unlike ~alpha~, this frame parameter only makes Emacs’
background transparent, excluding images and text.
#+begin_src emacs-lisp
;; (add-to-list 'default-frame-alist '(alpha-background . 0.2))
#+end_src

*** Modeline Modules
I sometimes use Emacs in fullscreen, meaning my usual taskbar will be
hidden. This is why I want the current date and time to be displayed,
in an ISO-8601 style, although not exactly ISO-8601 (this is the best
time format, fight me).
#+begin_src emacs-lisp
(require 'time)
(setq display-time-format "%Y-%m-%d %H:%M")
(display-time-mode 1) ; display time in modeline
#+end_src

Something my taskbar doesn’t have is a battery indicator. However, I
want it enabled only if I am on a laptop or if a battery is available.
#+begin_src emacs-lisp
(let ((battery-str (battery)))
  (unless (or (equal "Battery status not available" battery-str)
              (string-match-p (regexp-quote "N/A") battery-str))
    (display-battery-mode 1)))
#+end_src

This isn’t a modeline module per se, but we have an indicator of the
current line in Emacs. And although it is useful, I also often wish to
know which column I’m on. This can be activated like so:
#+begin_src emacs-lisp
(column-number-mode)
#+end_src

The following code is, as will several chunks of code in this config,
borrowed from [[https://tecosaur.github.io/emacs-config/#theme-modeline][TEC’s configuration]]. It hides the encoding information
of the file if the file itself is a regular UTF-8 file with ~\n~ line
ending. Be aware the ~doom-modeline-buffer-encoding~ variable is usabel
here only because I use the Doom modeline as seen below.
#+begin_src emacs-lisp
(defun modeline-contitional-buffer-encoding ()
  "Hide \"LF UTF-8\" in modeline.

It is expected of files to be encoded with LF UTF-8, so only show
the encoding in the modeline if the encoding is worth notifying
the user."
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))
#+end_src

Now, let’s automate the call to this function in order to apply the
modifications to the modeline each time we open a new file.

#+begin_src emacs-lisp
(add-hook 'after-change-major-mode-hook #'modeline-contitional-buffer-encoding)
#+end_src

*** utf-8 coding system
#+begin_src emacs-lisp
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src
*** Fonts

#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Iosevka-11")
(set-face-attribute 'fixed-pitch nil :font "Iosevka" :height 1.0)
(set-face-attribute 'variable-pitch nil :font "Iosevka")

;; Set for unicode fonts
(set-fontset-font "fontset-default" nil (font-spec :family "Noto Color Emoji"))

;; Resources
;; https://xiangji.me/2015/07/13/a-few-of-my-org-mode-customizations/
;; For tables
#+end_src
**** Change font
From https://github.com/MatthewZMD/.emacs.d/blob/master/elisp/init-fonts.el

#+begin_src emacs-lisp
(defvar font-list '(("Source Code Pro" . 11) ("DejaVu Sans" . 12) ("DejaVu Sans Mono" . 12) ("Iosevka" . 12))
  "List of fonts and sizes.")

(defun dorneanu/change-font ()
  "Interactively change a font from a list a available fonts."
  (interactive)
  (let* (available-fonts font-name font-size font-setting)
    (dolist (font font-list (setq available-fonts (nreverse available-fonts)))
      (when (member (car font) (font-family-list))
        (push font available-fonts)))
    (if (not available-fonts)
        (message "No fonts from the chosen set are available")
      (if (called-interactively-p 'interactive)
          (let* ((chosen (assoc-string (completing-read "What font to use? " available-fonts nil t) available-fonts)))
            (setq font-name (car chosen) font-size (read-number "Font size: " (cdr chosen))))
        (setq font-name (caar available-fonts) font-size (cdar available-fonts)))
      (setq font-setting (format "%s-%d" font-name font-size))
      (set-frame-font font-setting nil t)
      (add-to-list 'default-frame-alist (cons 'font font-setting)))))

#+end_src
*** Frame Title
This is straight-up copied from [[https://tecosaur.github.io/emacs-config/config.html#window-title][TEC]]’s configuration. See their comment
on the matter.
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        "%b"
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p) " ◉ %s" "  ●  %s - Emacs") project-name))))))
#+end_src

*** mouse
I still use the mouse for scrolling, changing frame sizes:

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (xterm-mouse-mode 1))

;; Automatically focus frame
(setq mouse-autoselect-window t)

;; Some keybindings
(global-set-key (kbd "C-S-<wheel-up>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-<wheel-up>") 'enlarge-window)
(global-set-key (kbd "C-S-<mouse-4>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-<mouse-4>") 'enlarge-window)

(global-set-key (kbd "C-S-<wheel-down>") 'shrink-window-horizontally)
(global-set-key (kbd "S-<wheel-down>") 'shrink-window)
(global-set-key (kbd "C-S-<mouse-5>") 'shrink-window-horizontally)
(global-set-key (kbd "S-<mouse-5>") 'shrink-window)
#+end_src

*** scrolling
#+begin_src emacs-lisp
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq fast-but-imprecise-scrolling nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)

;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
#+end_src
** Global functionalities
*** crux
#+begin_src emacs-lisp
(use-package crux
  :straight t
  :bind
  (("C-a" . crux-move-beginning-of-line)
   ("C-x 4 t" . crux-transpose-windows)
   ("C-x K" . crux-kill-other-buffers)
   ("C-k" . crux-smart-kill-line))
  :config
  (crux-with-region-or-buffer indent-region)
  (crux-with-region-or-buffer untabify)
  (crux-with-region-or-point-to-eol kill-ring-save)
  (defalias 'rename-file-and-buffer #'crux-rename-file-and-buffer))

#+end_src
*** discover-my-major
#+begin_src emacs-lisp
(use-package discover-my-major
  :bind ("C-h C-m" . discover-my-major))
#+end_src

** A better custom variable setter
Something people often forget about custom variables in Elisp is they
can have a custom setter that will run some code if we set the
variable properly with ~customize-set-variable~, so ~setq~ shouldn’t be
the user’s choice by default. But repeatedly writing
~customize-set-variable~ can get tiring and boring. So why not take the
best of both world and create ~csetq~, a ~setq~ that uses
~customize-set-variable~ under the hood while it keeps a syntax similar
to the one ~setq~ uses?
#+begin_src emacs-lisp
(defmacro csetq (&rest forms)
  "Bind each custom variable FORM to the value of its VAL.

FORMS is a list of pairs of values [FORM VAL].
`customize-set-variable' is called sequentially on each pair
contained in FORMS. This means `csetq' has a similar behaviour as
`setq': each VAL expression is evaluated sequentially, i.e. the
first VAL is evaluated before the second, and so on. This means
the value of the first FORM can be used to set the second FORM.

The return value of `csetq' is the value of the last VAL.

\(fn [FORM VAL]...)"
  (declare (debug (&rest sexp form))
           (indent 1))
  ;; Check if we have an even number of arguments
  (when (= (mod (length forms) 2) 1)
    (signal 'wrong-number-of-arguments (list 'csetq (1+ (length forms)))))
  ;; Transform FORMS into a list of pairs (FORM . VALUE)
  (let (sexps)
    (while forms
      (let ((form  (pop forms))
            (value (pop forms)))
        (push `(customize-set-variable ',form ,value)
              sexps)))
    `(progn ,@(nreverse sexps))))
#+end_src

I first got inspired by [[https://oremacs.com/2015/01/17/setting-up-ediff/][this blog article]] (archived article, just in
case) but it seems the code snippet no longer works properly, so not
only did I have to modify it to make it work with an arbitrary amount
of arguments (as long as it’s pairs of variables and their value), but
I also had to make the code simply work.
